68K GAS   			page 1


   1               	/*
   0               	
   0               	
   2               		DWORD do_div(PLARGE_INTEGER pli, DWORD base)  
   3               		DWORD div64(PLARGE_INTEGER pli, DWORD base) 
   4               		DWORD div32(DWORD *divident, DWORD base)  	
   5               		div_t       div(int __numer, int __denom);
   6               		ldiv_t      ldiv(long __numer, long __denom);
   7               	
   8               	
   9               		typedef struct _LARGE_INTEGER {
  10               			    DWORD HighPart;
  11               			    DWORD LowPart;
  12               		} LARGE_INTEGER, *PLARGE_INTEGER;
  13               	
  14               		typedef struct {
  15               	        	int     quot;
  16               	        	int     rem;
  17               		} div_t;
  18               	
  19               		typedef struct {
  20               	        	long    quot;
  21               	        	long    rem;
  22               		} ldiv_t;
  23               	
  24               	*/
  25               	
  26               		.text
  27               		.global div32, div64, do_div, div,ldiv
  28               	/*	.global __umoddi3, __udivdi3 müssen noch realisiert werden, oder finden sich in fpgnulib_unstri
  29               	
  30               	
  31               	#ifdef M68020
  32               	/*******************************************   Routinen für 68020 ********************************
  33               	/*
  34               	
  35               	DWORD do_div(PLARGE_INTEGER pli, DWORD base) 
  36               	{
  37               				
  38               	} 
  39               	
  40               	 DIVU.L  < ea > ,Dr:Dq 64/32 ® 32r – 32q    // Dr:Dq/<ea>   -> Dq = Quotient, Dr=Rest (Division 
  41               	 DIVUL.L < ea > ,Dr:Dq 32/32 ® 32r – 32q    // Dq/<ea>      -> Dq = Quotient, Dr=Rest (Division 
  42               	
  43               	*  Stack bei *1):
  44               	*   :
  45               	*   :
  46               	* +0012                                <- sp=sp* vor dem Sprung ins Unterprogramm
  47               	* +0008	base			<- parameter 1 upper 32 bit (0x00001234) fp+12   sp*-4
  48               	* +0004	pn			<- parameter 1 Pointer to LONGLONG       fp+ 8   sp*-8
  49               	* +0000	Rücksprungadresse
  50               	* -0004 	Alter Wert von %fp	<-%fp
  51               	* -0008	__rem                                     fp-4
  52               	* -0012   __upper                                    fp-8
  53               	* -0016   __n.n32[1]                                 fp-12
  54               	* -0020   __n.n32[0]		<-%sp         fp-16
  55               	*   :
68K GAS   			page 2


  56               	*   :
  57               	*
  58               	*
  59               	*/
  60               	
  61               	div64:
  62               	do_div:
  63 0000 4E56 FFF0 		link.w %fp,#-16			// lokalen Stack-Bereich aufbauen
  64 0004 48E7 2000 		movem.l %d2,-(%sp)	 	// *1) Register sichern	(%a0.%a1/%d0..%d1 sind scratch register und müssen n
  65               	
  66 0008 206E 0008 		move.l (8,%fp),%a0		// Zeiger auf li
  67 000c 2D50 FFF0 		move.l (%a0),-16(%fp)    	// __n.n64 = (li)// (part 1)
  68 0010 2D68 0004 		move.l 4(%a0),-12(%fp)	  	// __n.n64 = (li)// (part 2)
  68      FFF4 
  69 0016 2D6E FFF0 		move.l -16(%fp),-4(%fp)	 	// if ((__upper = __n.n32[0])) {	
  69      FFFC 
  70 001c 4AAE FFFC 		tst.l -4(%fp)
  71 0020 6718      		jeq .L3				// beq.s wäre der "korrekte" Befehl .... (jeq gibt es eigentlich nicht)	
  72               	
  73 0022 202E FFF0 		move.l  -16(%fp), %d0		// move.l __n.n32[0],%d0
  74 0026 222E FFFC 		move.l 	 -4(%fp), %d1		// move.l __upper,%d1
  75 002a 242E 000C 		move.l 	 12(%fp), %d2  		// move.l base,%d2
  76               		
  77 002e 4C42 0001 		divul.l %d2,%d1:%d0		// __n.n32[0] / base ==> %d0 = Quotient, %d1 = Rest
  78               	
  79 0032 2D40 FFF0 		move.l %d0, -16(%fp)		// Ergebnis/Quotient nach __n.n32[0]
  80 0036 2D41 FFFC 		move.l %d1,  -4(%fp)		// Rest nach __upper
  81               		
  82               		.L3:
  83               		
  84 003a 202E FFF4 		move.l  -12(%fp), %d0		// move.l __n.n32[1],%d0
  85 003e 222E FFFC 		move.l 	 -4(%fp), %d1		// move.l __upper,%d1
  86 0042 242E 000C 		move.l 	 12(%fp), %d2  		// move.l base,%d2
  87               	
  88 0046 4C42 0401 		divu.l %d2,%d1:%d0		// __n.n32[0] / base ==> %d0 = Quotient, %d1 = Rest
  89               	
  90 004a 2D40 FFF4 		move.l %d0, -12(%fp)		// Ergebnis/Quotient nach __n.n32[1]
  91 004e 2D41 FFF8 		move.l %d1, -8(%fp)		// Rest nach __rem
  92               		/* +++++++++ */
  93               	
  94               	
  95 0052 20AE FFF0 		move.l -16(%fp),(%a0)
  96 0056 216E FFF4 		move.l -12(%fp),4(%a0)
  96      0004 
  97 005c 202E FFF8 		move.l -8(%fp),%d0
  98 0060 4CDF 0004 		movem.l (%sp)+,%d2		// Register wieder herstellen
  99 0064 4E5E      		unlk %fp			// lokalen Stack-Bereich freigeben
 100 0066 4E75      		rts
 101               	
 102               	
 103               	//
 104               	//
 105               	//  Für 68020 konzipiert
 106               	// 
 107               	//   DWORD div32 ( DWORD *didident32, DWORD divisor32) - Für Aufruf aus C-Funktion
 108               	//   _div32 (dident32, divisor32)  
 109               	//
68K GAS   			page 3


 110               	//  DIVUL.L < ea > ,Dr:Dq 32/32 ® 32r – 32q    // Dq/<ea>      -> Dq = Quotient, Dr=Rest (Divisi
 111               	//
 112               	//  Rückgabe: D1=Quotient, D0=Rest
 113               	//
 114               	// Stack *1):
 115               	//  Divisor						<-%fp+12
 116               	//  *Divident/Divident		    <-%fp+8
 117               	//  Rücksprungadresse			<-%fp+4
 118               	//  %fp alt						<-%fp,%sp
 119               	//
 120               	
 121               	div32:
 122 0068 4E56 0000 	       link    %fp,#0
 123               	                 						// *1)
 124 006c 206E 0008 	       movea.l  8(%fp),%A0      			// Divident nach D0
 125 0070 2010      	       move.l (%a0),%D0
 126 0072 222E 000C 	       move.l  12(%fp),%D1     			// Divisor nach D1
 127               	
 128 0076 6118      	       bsr.s  _div32_0
 129 0078 2081      	       move.l %D1,(%A0)                  // Quotient zurückliefern
 130 007a 4E5E      	       unlk  %fp
 131 007c 4E75      	       rts
 132               	
 133               	_div32:
 134 007e 4E56 0000 	       link    %fp,#0
 135               	                 						// *1)
 136 0082 222E 0008 	       move.l  8(%fp),%D1      			// Divident nach D1
 137 0086 202E 000C 	       move.l  12(%fp),%D0     			// Divisor nach D0
 138               	
 139 008a 6104      	       bsr.s  _div32_0
 140 008c 4E5E      	       unlk  %fp
 141 008e 4E75      	       rts
 142               	
 143               	_div32_0:
 144               	
 145 0090 4C40 1000 	       divul.l %d0,%d0:%d1		// %d1/%d0  => Q=%d1, R=%d0
 146 0094 4E75      	       rts
 147               	
 148               	/*
 149               		uint64 __udivdi3(uint64 a, uint64 b)  
 150               	
 151               		Return a / b
 152               	
 153               	
 154               	__udivdi3:
 155               		rts
 156               	*/
 157               	
 158               	
 159               	/*
 160               		uint64 __umoddi3(uint64 a, uint64 b)  
 161               	
 162               		
 163               	
 164               	
 165               	__umoddi3:
 166               		rts
68K GAS   			page 4


 167               	
 168               	*/
 169               	
 170               	#endif
 171               	
 172               	
 173               	#ifdef M68000
 174               	/*******************************************   Routinen für 68000 ********************************
 175               	
 176               	//  Für 68000 konzipiert
 177               	//
 178               	//  DWORD do_div_(PLARGE_INTEGER pli, DWORD base)
 179               	//
 180               	//
 181               	//   DIVU.L  < ea > ,Dr:Dq 64/32 Â® 32r â€“ 32q    // Dr:Dq/<ea>   -> Dq = Quotient, Dr=Rest
 182               	//   DIVUL.L < ea > ,Dr:Dq 32/32 Â® 32r â€“ 32q    // Dq/<ea>      -> Dq = Quotient, Dr=Rest
 183               	//
 184               	//
 185               	//  Stack bei *1):
 186               	//   :
 187               	//   :
 188               	// +0012                 <- sp=sp* vor dem Sprung ins Unterprogramm
 189               	// +0008	base			<- parameter 1 upper 32 bit (0x00001234) fp+12   sp*-4
 190               	// +0004	pn				<- parameter 1 Pointer to LONGLONG       fp+ 8   sp*-8
 191               	// +0000	Rücksprungadresse
 192               	// -0004 	Alter Wert von 	%fp	<-%fp
 193               	// -0008	  __rem                                      fp-4
 194               	// -0012   __upper                                    fp-8
 195               	// -0010              __n.n16[3]                      fp-10
 196               	// -0016   __n.n32[1] __n.n16[2]                      fp-12
 197               	// -0018              __n.n16[1]						 fp-14
 198               	// -0020   __n.n32[0] __n.n16[0]		   <-%sp         fp-16
 199               	//   :
 200               	//   :
 201               	//
 202               	//
 203               	
 204               	div64:
 205               	do_div:
 206               		link.w %fp,#-16	      // lokalen Stack-Bereich aufbauen
 207               		movem.l %a0/%d1-%d3,-(%sp)	 	     // Register sichern      *1)
 208               	
 209               	    	move.l (8,%fp),%a0                // Zeiger auf LONGLONG nach a0
 210               		move.l (%a0),-16(%fp)    	      	// __n.n32[0]
 211               		move.l 4(%a0),-12(%fp)	  	    // __n.n32[1]
 212               		clr.l %d0
 213               	
 214               		// Step 1:			// Im ersten Step können bereits die oberen 32Bit des Divisors bearbeitet werden,
 215               						// da noch kein Rest aus einer vorhergehenden Division berücksichtigt werden muss.
 216               	
 217               		move.l 12(%fp),-(%sp)				// Divisor auf den Stack
 218               		move.l -16(%fp),%d0				// Divident auf den Stack
 219               		move.l %d0,-(%sp)
 220               		bsr.s _div32					// D1=Q1, D0=Rest
 221               		addq.l  #8,%sp					// Stackpointer korrigieren
 222               		move.l %d1,-16(%fp)				// Q1 zurück
 223               	
68K GAS   			page 5


 224               	//	// Step 2:
 225               	//
 226               	//	move.l 12(%fp),-(%sp)				// Divisor auf den Stack
 227               	//	swap.l %d0
 228               	//	move.w -14(%fp),%d0				// Divident auf den Stack
 229               	//	move.l %d0,-(%sp)
 230               	//	bsr.s __div32					// D1=Q2, D0=Rest
 231               	//	addq.l  #8,%sp					// Stackpointer korrigieren
 232               	//	move.w %d1,-14(%fp)				// Q2 zurück
 233               	
 234               		// Step 3:
 235               	
 236               		move.l 12(%fp),-(%sp)				// Divisor auf den Stack
 237               		swap %d0
 238               		move.w -12(%fp),%d0				// Divident auf den Stack
 239               		move.l %d0,-(%sp)
 240               		bsr.s _div32					// D1=Q3, D0=Rest
 241               		addq.l  #8,%sp					// Stackpointer korrigieren
 242               		move.w %d1,-12(%fp)				// Q3 zurück
 243               	
 244               		// Step 4:
 245               	
 246               		move.l 12(%fp),-(%sp)				// Divisor auf den Stack
 247               		swap %d0
 248               		move.w -10(%fp),%d0				// Divident auf den Stack
 249               		move.l %d0,-(%sp)
 250               		bsr.s _div32					// D1=Quotient, D0=Rest
 251               		addq.l  #8,%sp					// Stackpointer korrigieren
 252               		move.w %d1,-10(%fp)				// Q4 zurück
 253               	
 254               		// Ergebnis zurückliefern
 255               	
 256               		move.l -16(%fp),(%a0)		// Ergebnis zurück nach n
 257               		move.l -12(%fp),4(%a0)
 258               				// Rest in %d0
 259               	
 260               		movem.l (%sp)+,%a0/%d1-%d3	// Register wieder herstellen
 261               		unlk %fp			// lokalen Stack-Bereich freigeben
 262               		rts
 263               	
 264               	
 265               	//
 266               	//
 267               	//  Für 68000 konzipiert
 268               	// 
 269               	//   DWORD div32 ( DWORD *didident32, DWORD divisor32) - Für Aufruf aus C-Funktion
 270               	//   _div32 (dident32, divisor32)  - Für Aufruf aus ASM (_div64_)
 271               	//
 272               	//  Rückgabe: D1=Quotient, D0=Rest
 273               	//
 274               	// Stack *1):
 275               	//  Divisor						<-%fp+12
 276               	//  *Divident/Divident		    <-%fp+8
 277               	//  Rücksprungadresse			<-%fp+4
 278               	//  %fp alt						<-%fp,%sp
 279               	//
 280               	div32:
68K GAS   			page 6


 281               	       link    %fp,#0
 282               	                 						// *1)
 283               	       movea.l  8(%fp),%A0      			// Divident nach D0
 284               	       move.l (%a0),%D0
 285               	       move.l  12(%fp),%D1     			// Divisor nach D1
 286               	
 287               	       bsr.s  _div32_0
 288               	       move.l %D1,(%A0)                  // Quotient zurückliefern
 289               	       unlk  %fp
 290               	       rts
 291               	
 292               	_div32:
 293               	       link    %fp,#0
 294               	                 						// *1)
 295               	       move.l  8(%fp),%D0      			// Divident nach D0
 296               	       move.l  12(%fp),%D1     			// Divisor nach D1
 297               	
 298               	       bsr.s  _div32_0
 299               	       unlk  %fp
 300               	       rts
 301               	
 302               	_div32_0:
 303               	
 304               	       cmpi.l  #0xFFFF,%D1     		// D1-$ffff: wenn  D1 > 16bit => Carry/Zero Flag gesetzt
 305               	
 306               	       bhi.s   _div32_2       		// Divident D1>$ffff ? ja, verzweige nach _div32_2
 307               	       								// nein, weiter
 308               	       cmpi.l  #0xFFFF,%D0     		// D0-$ffff: wenn D0 > 16bit => Carry/Zero Flag gesetzt
 309               	
 310               	       bhi.s   _div32_1       		// Divisor D0>$ffff ? ja, verzweige nach _div32_1
 311               	       								// nein, dann weiter
 312               	
 313               	       								// hier sind D1 und D0 16 Bit gross und können direkt
 314               	       								// dividiert werden....
 315               	       divu    %D1,%D0         		// D0 = D0 / D1  => D0 = [Rest|Quotient]
 316               	       move.l  %D0,%D1         		// D1 = D0
 317               	       clr.w   %D0            		// lösche Quotient
 318               	       swap    %D0            		// Rest nach D0
 319               	       andi.l  #0xFFFF,%D1     		// Quotient nach D1
 320               	       rts
 321               	
 322               	
 323               	_div32_1:                     		// Divident D0 ist 16 Bit, Divisor D1 32 Bit gross
 324               	       movem.l %D0/%D2,-(%sp)   		// Register sichern
 325               	       clr.w   %D0            		// HiWord des Dividenten nach D0 ...
 326               	       swap    %D0            		// ...
 327               	       divu    %D1,%D0         		// D0 = D0/D1  (Division des HiWords des Divisors)   => D0 = [HiRe
 328               	       move.w  %D0,%D2         		// => D2 = HiQuotient
 329               	       addq    #2,%sp                   // Stack korrigieren
 330               	       move.w  (%sp)+,%D0      		// LowWord des Dividenten nach D0.w => D0 = [HiRest|LowDivisor]
 331               	       divu    %D1,%D0         		// D0 = D0/D1  (Division HiRest|LowDivisor)   => D0 = [LowRest|Low
 332               	       clr.l   %D1                      // D1 löschen
 333               	       move.w  %D0,%D1         		// LowQuotient nach D1
 334               	       swap    %D2					// D2 = [HiQuotient|0]
 335               	       move.w  %D1,%D2         		// LoQuotient.w nach D2 => D2 = [HiQuotient|LowQuotient]
 336               	       move.l  %d2,%d1				// Quotient Zurückliefern
 337               	       clr.w   %d0					// LowQuotient in d0 löschen
68K GAS   			page 7


 338               	       swap    %d0					// Rest in d0
 339               	       movem.l  (%sp)+,%D2      		// Register wieder herstellen
 340               	       rts                   		// Rücksprung
 341               	
 342               	
 343               	
 344               	
 345               	
 346               	       								// Hier folgt ein "böser" Algorithmus ...
 347               	_div32_2:							// Divisor D1 ist 32 Bit gross, Divident D0 ist 16 oder 32 Bit gross
 348               	       movem.l %D2/%D3/%D4,-(%sp)		// Register D2..D4 sichern
 349               	       move.l  %D1,%D2         		// Divisor nach D2
 350               	       clr.w   %D2            		// D2 = HiDivisor ...
 351               	       swap    %D2            		// ...
 352               	       addq.l  #1,%D2         		// D2 = HiDivisor + 1
 353               	       move.l  %D0,%D3         		// Divident nach D3
 354               	       move.l  %D1,%D4         		// Divisor nach D4
 355               	       move.l  %D2,%D1         		// HiDivisor+1 nach D1
 356               	       bsr.s   _div32_1       		// (HiDivisor+1) / Divident  =>  D0=Q1,  D1=R1
 357               	       move.l  %D4,%D1         		// Divisor nach D1
 358               	       divu    %D2,%D1         		// D1 = D1/D2 i.e. Divisor/(HiDivisor+1)
 359               	       divu    %D1,%D0         		// D0 = D0/D1
 360               	       andi.l  #0xFFFF,%D0     		// lösche Rest der leten Division
 361               	
 362               	_div32_3:
 363               	       move.l  %D4,%D1         		// Divisor nach D1
 364               	       move.l  %D4,%D2         		// Divisor nach D2
 365               	       swap    %D2            		//
 366               	       mulu    %D0,%D1
 367               	       mulu    %D0,%D2
 368               	       swap    %D2
 369               	       add.l   %D2,%D1
 370               	       sub.l   %D3,%D1
 371               	       bhi.s   _div32_4
 372               	       neg.l   %D1
 373               	       cmp.l   %D1,%D4
 374               	       bhi.s   _div32_5
 375               	       addq.l  #1,%D0
 376               	       bra.s   _div32_3
 377               	_div32_4:
 378               	       subq.l  #1,%D0
 379               	       bra.s   _div32_3
 380               	_div32_5:
 381               	       move.l  %d0,%d2				// Quotient Zurückliefern
 382               	       move.l  %d1,%d0				// Rest nach d0
 383               	       move.l  %d2,%d1				// Quotient nach D1
 384               	       movem.l (%sp)+,%D2/%D3/%	D4		// Register wieder herstellen
 385               	       rts                   		// Rücksprung
 386               	
 387               	
 388               	/*
 389               		uint64 __udivdi3(uint64 a, uint64 b)  
 390               	
 391               		Return a / b
 392               	
 393               	
 394               	__udivdi3:
68K GAS   			page 8


 395               		rts
 396               	
 397               	*/
 398               	
 399               	/*
 400               		uint64 __umoddi3(uint64 a, uint64 b)  
 401               	
 402               		
 403               	
 404               	
 405               	__umoddi3:
 406               		rts
 407               	
 408               	*/
 409               	#endif
 410               	
 411               	
 412               	/*
 413               		div_t       div(int __numer, int __denom);
 414               		ldiv_t      ldiv(long __numer, long __denom);
 415               		
 416               		(__numer / __denom = div_t)
 417               		
 418               		typedef struct {
 419               	        	int     quot;
 420               	        	int     rem;
 421               		} div_t;
 422               	
 423               		typedef struct {
 424               	        	long    quot;
 425               	        	long    rem;
 426               		} ldiv_t;
 427               	
 428               	
 429               		Aufruf für ldiv und div:
 430               	
 431               		link.w %fp,#-24
 432               	  	move.l -8(%fp),-(%sp)		// larg2 __denom
 433               	  	move.l -4(%fp),-(%sp)		// larg1 __numer
 434               	  	jsr ldiv
 435               	  	addq.l #8,%sp
 436               	  	move.l %d0,-24(%fp)		// ldiv.quot
 437               	  	move.l %d1,-20(%fp)		// ldiv.rem
 438               	
 439               	  	unlk %fp
 440               	*/
 441               	div:
 442               	ldiv:
 443 0096 41EF 0004 		lea.l	(4,%A7),%A0	/* get pointer to parameters */
 444               	
 445 009a 2F28 0004 		move.l	(4,%a0),-(%A7)	/* arg2 __denom 	*/
 446 009e 2F10      		move.l	(%a0),-(%A7)   	/* arg1 __numer 	*/
 447               	
 448 00a0 6100 FFDC 		bsr	_div32		/* call div32 		*/	
 449               	
 450 00a4 508F      		add.l #8,%sp		/* Stack aufräumen 	*/
 451               	
68K GAS   			page 9


 452 00a6 2F00      		move.l %d0,-(%sp)	/* Quotient -> D0 ! 	*/
 453 00a8 2F01      		move.l %d1,-(%sp)	/* Rest -> D1 ! 	*/
 454 00aa 201F      		move.l (%sp)+,%d0	/* swap d0<->d1 	*/
 455 00ac 221F      		move.l (%sp)+,%d1
 456               		
 457               	
 458 00ae 4E75      		rts
68K GAS   			page 10


DEFINED SYMBOLS
          divmod64.S:121    .text:00000068 div32
          divmod64.S:61     .text:00000000 div64
          divmod64.S:62     .text:00000000 do_div
          divmod64.S:441    .text:00000096 div
          divmod64.S:442    .text:00000096 ldiv
          divmod64.S:143    .text:00000090 _div32_0
          divmod64.S:133    .text:0000007e _div32

NO UNDEFINED SYMBOLS
