68K GAS   			page 1


   1               	#include "../nkc/nkc.h"
   0               	
   0               	
   1               	#ifndef __EQU_H
   2               	#include "../nkc/macros.h"
   1               	#ifndef __MACROS_H
   2               	#define __MACROS_H
   3               	
   4               	
   5               	/* DEBUG MACROS */
   6               	#ifdef CONFIG_DEBUG_GIDE_S
   7               	
   8               	.macro dbg msg
   9               	        writeln \msg
  10               	.endm   
  11               	
  12               	.macro dbgwait
  13               	        waitcr
  14               	.endm
  15               	
  16               	
  17               	#else
  18               	.macro dbg msg
  19               	.endm
  20               	
  21               	.macro dbgwait
  22               	.endm
  23               	#endif     
  24               	
  25               	/*
  26               	   Ermittelt die PC-realtive effekive Addresse von var und legt sie in a0 ab.
  27               	   Wird für 68000 gebraucht, da dieser nur 64KB Addressierung kennt:
  28               		lea var(pc),a0 ; funktioniert i.A. nur ab 68020
  29               		LEA32A0 var    ; erledigt das für den 68000
  30               	
  31               		Die Subroutine _LEA32A0 liegt in start00.S
  32               	*/
  33               	
  34               	#ifdef M68000
  35               	.macro LEA32A0 var
  36               		move.l #\var,-(%sp)
  37               		move.l #1f,-(%sp)
  38               		jsr _LEA32A0
  39               	1:	addq.l #8,%sp
  40               	.endm
  41               	
  42               	.macro LEA32 var,reg
  43               		move.l #\var,-(%sp)
  44               		move.l #1f,-(%sp)
  45               		jsr _LEA32A0
  46               	1:	addq.l #8,%sp
  47               		movea.l %a0,\reg
  48               	.endm
  49               	
  50               	/* pea kann auch nur mit 16Bit Displacements ! i.e. "pea d16(pc)" */
  51               	.macro _LEA var,reg
  52               		pea #\var
68K GAS   			page 2


  53               		move.l (%sp)+,\reg
  54               	.endm
  55               	#endif
  56               	
  57               	
  58               	/* Gibt Text an momentaner Cursor Position aus */
  59               	.macro writeln  text             
  60               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
  61               	#ifdef M68000
  62               		LEA32A0 \text
  63               	#else
  64               	        lea \text,%a0
  65               	#endif
  66               	1:
  67               	        move.b (%a0)+,%d0
  68               	        beq 2f
  69               	        moveq #_CO2,%d7
  70               	        trap #1
  71               	        bra 1b
  72               	2:
  73               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
  74               	.endm
  75               	
  76               	.macro prntdot             
  77               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
  78               	        move.b #'.',%d0
  79               	        moveq #_CO2,%d7
  80               	        trap #1
  81               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
  82               	.endm
  83               	
  84               	
  85               	.macro crlf                      
  86               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
  87               	        moveq #_CRLF,%d7
  88               	        trap #1
  89               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
  90               	.endm
  91               	
  92               	
  93               	/* jumps to x,y position */
  94               	
  95               	.macro gotoxy x y           
  96               	 	movem.l %a0-%a6/%d0-%d7,-(%a7)
  97               	 	move.b #\x,%d1           /* d1=X (0..79)*/
  98               	 	move.b #\y,%d2           /* d2=Y (0..23)*/
  99               	 	moveq #_SETCURXY,%d7
 100               	 	trap #1
 101               	 	movem.l (%a7)+,%a0-%a6/%d0-%d7
 102               	.endm
 103               	
 104               	
 105               	.macro getxy x y           
 106               	 	movem.l %a0-%a6/%d0-%d7,-(%a7)
 107               	 	moveq #_GETCURXY,%d7
 108               	 	trap #1
 109               	 	move.b %d1,#\x           /* d1=X (0..79)*/
68K GAS   			page 3


 110               	 	move.b %d2,#\y           /* d2=Y (0..23)*/
 111               	 	movem.l (%a7)+,%a0-%a6/%d0-%d7
 112               	.endm
 113               	
 114               	.macro writexy size x y text            /* gibt einen text an x/y position aus*/
 115               	                            	   	/* TextGrüsse,X,Y,TextAddr (Nullterminiert)*/
 116               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 117               	        move.b #\size,%d0
 118               	        move.w #\x,%d1
 119               	        move.w #\y,%d2
 120               	        lea \text,%a0
 121               	        moveq #_WRITE,%d7
 122               	        trap #1
 123               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 124               	.endm
 125               	
 126               	
 127               	
 128               	.macro clrscr                    /* loescht den Bildschirm */
 129               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 130               	        moveq #_CLRSCREEN,%d7
 131               	        trap #1
 132               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 133               	.endm
 134               	
 135               	
 136               	
 137               	
 138               	.macro prthex2  value                 	/* gibt 2stellige HEX Zahl aus*/
 139               	                                	/* IN: WERT*/
 140               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 141               	        move.l \value,%d0
 142               	        lea buffer(%pc),%a0
 143               	        moveq #_PRINT2X,%d7
 144               	        trap #1
 145               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 146               	.endm
 147               	
 148               	
 149               	.macro prthex8  value            /* gibt 8stellige Hex Zahl aus */
 150               	                                 /* In: WERT */
 151               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 152               	        move.l \value,%d0
 153               	#ifdef M68000
 154               		LEA32A0 buffer
 155               	#else
 156               	        lea buffer(%pc),%a0
 157               	#endif
 158               	        moveq #_PRINT8X,%d7
 159               	        trap #1
 160               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 161               	.endm
 162               	
 163               	.macro waitcr                    /* Wartet auf CR (Enter) */
 164               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 165               	1:
 166               	        moveq #_CI,%d7
68K GAS   			page 4


 167               	        trap #1
 168               	        cmp.b #0xd,%d0
 169               	        bne.s 1b
 170               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 171               	.endm
 172               	
 173               	
 174               	.macro CMOS_READ index
 175               		movem.l %a0-%a1,-(%a7)
 176               		clr.l %d0
 177               		move.b \index,RTC_DS12887_INDEX.w
 178               		move.b RTC_DS12887_DATA.w,%d0
 179               		movem.l (%a7)+,%a0-%a1
 180               	.endm
 181               	
 182               	.macro BCD_TO_BIN
 183               		movem.l %d1,-(%a7)
 184               		move.l %d0,%d1
 185               		andi #0x0f,%d0
 186               		lsr #4,%d1
 187               		mulu #10,%d1
 188               		add %d1,%d0
 189               		movem.l (%a7)+,%d1
 190               	.endm
 191               	
 192               	.macro BIN_TO_BCD		/*ist zwar 2 Befehle länger, aber schneller und für alle 68xxx*/
 193               		movem.l %d1,-(%a7)
 194               		and.l #0xff,%d0		/*nur Byte gültig*/
 195               		divu #10,%d0
 196               		move %d0,%d1
 197               		lsl #4, %d1
 198               		swap %d0
 199               		add %d0, %d1
 200               		exg %d0, %d1
 201               		movem.l (%a7)+,%d1
 202               	.endm
 203               	
   3               	
   4               	
   5               		.text
   6               		.global _ll_gettime, _ll_ticks, _ll_getenv, _ll_system, timerinit, timerclose
   7               	
   8               	/************************************************************************
   9               	 * struct tm *_ll_gettime(struct tm *tm2)
  10               	 ************************************************************************/
  11               	/*
  12               		 * Only the values that we read from the RTC are set. We leave
  13               		 * tm_wday, tm_yday and tm_isdst untouched. Even though the
  14               		 * RTC has RTC_DAY_OF_WEEK, we ignore it, as it is only updated
  15               		 * by the RTC when initially set to a non-zero value.
  16               		 
  17               			 struct tm
  18               			{
  19               			  int   tm_sec;   int = 32bit 
  20               			  int   tm_min;
  21               			  int   tm_hour;
  22               			  int   tm_mday;
68K GAS   			page 5


  23               			  int   tm_mon;
  24               			  int   tm_year;
  25               			  int   tm_wday;
  26               			  int   tm_yday;
  27               			  int   tm_isdst;
  28               			};
  29               	
  30               	*/ 
  31               	
  32               	
  33               	_ll_gettime:
  34 0000 48E7 0020 		movem.l %a2,-(%sp)
  35               		
  36 0004 246F 0008 		move.l 8(%sp),%a2 /* *tm */		
  37               		
  38 0008 48E7 00C0 		CMOS_READ #RTC_SECONDS
  38      4280 11FC 
  38      0000 FFE8 
  38      1038 FFEC 
  38      4CDF 0300 
  39 001c 48E7 4000 		BCD_TO_BIN
  39      2200 0240 
  39      000F E849 
  39      C2FC 000A 
  39      D041 4CDF 
  40 0032 2480      		move.l %d0,0(%a2)
  41               		
  42 0034 48E7 00C0 		CMOS_READ #RTC_MINUTES
  42      4280 11FC 
  42      0002 FFE8 
  42      1038 FFEC 
  42      4CDF 0300 
  43 0048 48E7 4000 		BCD_TO_BIN
  43      2200 0240 
  43      000F E849 
  43      C2FC 000A 
  43      D041 4CDF 
  44 005e 2540 0004 		move.l %d0,4(%a2)
  45               	
  46 0062 48E7 00C0 		CMOS_READ #RTC_HOURS
  46      4280 11FC 
  46      0004 FFE8 
  46      1038 FFEC 
  46      4CDF 0300 
  47 0076 48E7 4000 		BCD_TO_BIN	
  47      2200 0240 
  47      000F E849 
  47      C2FC 000A 
  47      D041 4CDF 
  48 008c 2540 0008 		move.l %d0,8(%a2)
  49               		
  50 0090 48E7 00C0 		CMOS_READ #RTC_DAY_OF_MONTH
  50      4280 11FC 
  50      0007 FFE8 
  50      1038 FFEC 
  50      4CDF 0300 
  51 00a4 48E7 4000 		BCD_TO_BIN
68K GAS   			page 6


  51      2200 0240 
  51      000F E849 
  51      C2FC 000A 
  51      D041 4CDF 
  52 00ba 2540 000C 		move.l %d0,12(%a2)
  53               		
  54 00be 48E7 00C0 		CMOS_READ #RTC_MONTH
  54      4280 11FC 
  54      0008 FFE8 
  54      1038 FFEC 
  54      4CDF 0300 
  55 00d2 48E7 4000 		BCD_TO_BIN	
  55      2200 0240 
  55      000F E849 
  55      C2FC 000A 
  55      D041 4CDF 
  56 00e8 5380      		sub.l #1,%d0
  57 00ea 2540 0010 		move.l %d0,16(%a2)
  58               		
  59 00ee 48E7 00C0 		CMOS_READ #RTC_YEAR	
  59      4280 11FC 
  59      0009 FFE8 
  59      1038 FFEC 
  59      4CDF 0300 
  60 0102 48E7 4000 		BCD_TO_BIN
  60      2200 0240 
  60      000F E849 
  60      C2FC 000A 
  60      D041 4CDF 
  61 0118 2540 0014 		move.l %d0,20(%a2)
  62               		
  63 011c 48E7 00C0 		CMOS_READ #RTC_DAY_OF_WEEK	
  63      4280 11FC 
  63      0006 FFE8 
  63      1038 FFEC 
  63      4CDF 0300 
  64 0130 48E7 4000 		BCD_TO_BIN
  64      2200 0240 
  64      000F E849 
  64      C2FC 000A 
  64      D041 4CDF 
  65 0146 2540 0018 		move.l %d0,24(%a2)
  66               	
  67 014a 200A      		move.l %a2,%d0
  68               		
  69 014c 4CDF 0400 		movem.l (%sp)+,%a2
  70 0150 4E75      		rts
  71               	/************************************************************************
  72               	 * int _ll_ticks(void)
  73               	 	returns processor time since start of program execution
  74               	 	_ll_ticks / CLOCKS_PER_SEC ist time in seconds
  75               	 	
  76               	 	In MSDOS this function is done in BIOS (1Ah,0) and returns
  77               	 	the time in ticks since system start.
  78               	 	
  79               	 	so we must initialize some variable which in turn needs
  80               	 	to be updated using the timer interrupt....
68K GAS   			page 7


  81               	 	--> initialization in startup.S via timerinit
  82               	 ************************************************************************/
  83               	_ll_ticks:
  84               	
  85               	/*
  86               	
  87               	(long)clock_t clock(void)
  88               	{
  89               	        return _ll_ticks();
  90               	}
  91               	
  92               	*/
  93               	#ifdef M68000
  94               		lea ticks,%a0
  95               	#else
  96 0152 41FB 0170 		lea ticks(%pc),%a0
  96      0000 0000 
  97               	#endif
  98 015a 2010      		move.l (%a0),%d0
  99 015c 4E75      		rts
 100               		
 101               	timerinit:
 102               	#ifdef M68000
 103               		lea kqstart, %a0		/* clear Key-Queue Vars */
 104               		clr (%a0)
 105               		lea kqend, %a0
 106               		clr (%a0) 
 107               		lea kqanz, %a0
 108               		clr (%a0)
 109               	
 110               		lea oldint7c,%a0
 111               	        move.l 0x7c, (%a0)       	/* save old int vector */
 112               		lea oldint74,%a0
 113               		move.l 0x74, (%a0)
 114               	        lea trap1F,%a0
 115               	#else
 116 015e 41FB 0170 		lea kqstart(%pc), %a0		/* clear Key-Queue Vars */
 116      0000 0000 
 117 0166 4250      		clr (%a0)
 118 0168 41FB 0170 		lea kqend(%pc), %a0
 118      0000 0000 
 119 0170 4250      		clr (%a0) 
 120 0172 41FB 0170 		lea kqanz(%pc), %a0
 120      0000 0000 
 121 017a 4250      		clr (%a0)
 122               	
 123 017c 41FB 0170 		lea oldint7c(%pc),%a0
 123      0000 0000 
 124 0184 20B8 007C 	        move.l 0x7c, (%a0)       	/* save old int vector */
 125 0188 41FB 0170 		lea oldint74(%pc),%a0
 125      0000 0000 
 126 0190 20B8 0074 		move.l 0x74, (%a0)
 127 0194 41FA 005E 	        lea trap1F(%pc),%a0	
 128               	#endif
 129 0198 21C8 007C 	        move.l %a0, 0x7c         	/* install new int vector */
 130 019c 21C8 0074 		move.l %a0, 0x74
 131               	        
68K GAS   			page 8


 132               	#ifdef M68000
 133               	        lea ticks,%a0
 134               	#else
 135 01a0 41FB 0170 	        lea ticks(%pc),%a0
 135      0000 0000 
 136               	#endif
 137 01a8 10BC 0000 	        move.b #0x0,(%a0)
 138               	        
 139 01ac 41F8 FFD0 	        lea TIMER1_CTRL.w,%a0        	/* adresse ctrl-reg in a0 	*/
 140 01b0 43F8 FFD4 	        lea TIMER1_HI.w,%a1          	/* adresse hi-reg in a1	*/
 141 01b4 45F8 FFD8 	        lea TIMER1_LO.w,%a2          	/* adresse lo-reg in a2 */
 142               	
 143 01b8 10BC 0004 	        move.b #4,(%a0)          	/* schreibe preset und timer register */
 144               	        				/* timer counts with 1Mhz, CLOCKS_PER_SEC = 1000 => counter=1000=0x03e8 => overflow aft
 145 01bc 12BC 0003 	        move.b #0x03,(%a1)        	/* hi-byte */
 146 01c0 14BC 00E8 	        move.b #0xe8,(%a2)        	/* low-byte */
 147 01c4 10BC 0081 	        move.b #0b10000001,(%a0)  	/* start timer, enable interupt */
 148 01c8 027C F8FF 		andi #0xf8ff, %sr		/* Interrups freigeben	*/
 149 01cc 4E75      		rts
 150               		
 151               	timerclose:
 152 01ce 41F8 FFD0 		lea TIMER1_CTRL.w,%a0        	/* adresse ctrl-reg in a0 */
 153 01d2 10BC 0000 		move.b #0,(%a0)          	/* stop timer and interrupts */
 154 01d6 007C 0700 	        ori #0x0700, %sr		/* Interrupts aus	*/
 155               	#ifdef M68000
 156               	        lea oldint7c,%a0
 157               	#else
 158 01da 41FB 0170 	        lea oldint7c(%pc),%a0
 158      0000 0000 
 159               	#endif
 160 01e2 21D0 007C 	        move.l (%a0),0x7c       	/* restore old interrupt */
 161               	#ifdef M68000
 162               		lea oldint74,%a0
 163               	#else
 164 01e6 41FB 0170 		lea oldint74(%pc),%a0
 164      0000 0000 
 165               	#endif
 166 01ee 21D0 0074 	        move.l (%a0),0x74       	/* restore old interrupt */
 167 01f2 4E75      	        rts
 168               			
 169               	/* TIMER INTERRUPT ROUTINE */	
 170               	trap1F:
 171 01f4 48E7 FFFE 	        movem.l %a0-%a6/%d0-%d7,-(%sp)
 172 01f8 40E7      	        move %sr,-(%sp)
 173 01fa 007C 0700 		ori #0x0700, %sr			/* Interrupts aus */
 174               	/*
 175               	        lea TIMER1_CTRL.w,%a0
 176               	        move.b #0b10000001,(%a0)  /* clear ovl bit(6), continue running(0), enable INT(7) */	
 177               	*/        
 178               	#ifdef M68000
 179               	        lea ticks,%a0
 180               	#else
 181 01fe 41FB 0170 	        lea ticks(%pc),%a0
 181      0000 0000 
 182               	#endif
 183 0206 5290      	        add.l #1,(%a0)			/* increment tick counter */
 184               		
68K GAS   			page 9


 185               		/*----- Ctrl-C check -------*/
 186               	checkkbd:
 187 0208 1038 FDA0 		move.b NKC_KEY_DATA.w, %d0
 188 020c 6B68      		bmi.s tr1Fend				/* kein neues Zeichen -> Ende */
 189               		
 190 020e 0C00 0003 		cmp.b #0x03, %d0			/* check Ctrl-C (incl. Strobe-Flag) */
 191 0212 6630      	 	bne.s getkbd	 			/* kein ctrl-c 	*/
 192               	 	
 193 0214 4A38 FDA4 	        tst.b NKC_KEY_DIP.w			/* Reset Strobe-Flag */
 194               	        
 195               	#ifdef M68000
 196               	        writeln ctrlctxt
 197               	#else
 198 0218 48E7 FFFE 		writeln ctrlctxt(%pc)
 198      41FB 0170 
 198      0000 0000 
 198      1018 6700 
 198      000A 7E21 
 199               	#endif
 200               	        
 201               	        /* - SIG senden */
 202 0236 2F3C 0000 	        move.l #21,-(%sp)			/* raise(SIGBREAK); (sollte es raise(SIGINT) sein ?)*/
 202      0015 
 203               	        /*bsr.l raise Problem mit 68000 (illegal instruction) => dem Compiler überlassen */
 204 023c 6100 0000 	        bsr raise
 205               	
 206               	        /* muss hier noch ein bra tr1Fend rein oder kommt man hier nie an? */
 207               	        /* im Grunde kommt man hier nie an, weil raise(SIGBREAK) das Programm beendet */
 208 0240 6000 0034 	        bra tr1Fend /* so ist es "sauberer" */
 209               	        
 210               	getkbd:
 211               	#ifdef M68000
 212               		lea keyqueue, %a0
 213               		lea kqanz, %a1
 214               		lea kqend, %a2
 215               	#else
 216 0244 41FB 0170 		lea keyqueue(%pc), %a0
 216      0000 0000 
 217 024c 43FB 0170 		lea kqanz(%pc), %a1
 217      0000 0000 
 218 0254 45FB 0170 		lea kqend(%pc), %a2
 218      0000 0000 
 219               	#endif	
 220 025c 0C51 0100 		cmp #256, (%a1)			/* kqanz			*/
 221 0260 6C14      		bge.s tr1Fend			/* Queue voll			*/
 222               	
 223 0262 5251      		addq #1, (%a1)			/* kqanz - ein Zeichen mehr	*/
 224 0264 3212      		move (%a2), %d1			/* kqend			*/
 225 0266 1180 1000 		move.b %d0, 0(%a0, %d1.w)	/* Zeichen speichern		*/
 226 026a 4A38 FDA4 	        tst.b NKC_KEY_DIP.w		/* Reset Strobe-Flag		*/
 227 026e 5241      		addq #1, %d1
 228 0270 0241 00FF 		and #0xff, %d1			/* auf 0..255			*/
 229 0274 3481      		move %d1, (%a2)			/* kqend			*/
 230               	
 231               		/*----------------------------*/
 232               		
 233               	tr1Fend:
68K GAS   			page 10


 234               		
 235 0276 41F8 FFD0 		lea TIMER1_CTRL.w,%a0
 236 027a 10BC 0081 	        move.b #0b10000001,(%a0)  /* clear ovl bit(6), continue running(0), enable INT(7) */	
 237               	        
 238 027e 46DF      	        move (%sp)+,%sr 
 239 0280 4CDF 7FFF 	        movem.l (%sp)+,%a0-%a6/%d0-%d7
 240               	
 241 0284 4E73      	        rte
 242               	
 243               	
 244               				
 245               	/************************************************************************
 246               	 * int _ll_system(char *name)
 247               	 	executes the "name" command, then resumes execution
 248               	 ************************************************************************/
 249               	_ll_system:
 250 0286 48E7 0002 		movem.l %a6,-(%a7)	/* used by jados frame-pointer */
 251 028a 206F 0008 		movea.l 8(%sp),%a0
 252 028e 7E5C      		moveq #__cmdexec,%d7
 253 0290 4E46      		trap #6
 254 0292 4CDF 4000 		movem.l (%a7)+,%a6
 255 0296 7000      		moveq.l #0,%d0
 256 0298 4E75      		rts
 257               	/************************************************************************
 258               	 * int _ll_getenv(char *buf, int id)
 259               	 	returns number of environment-variables
 260               	 	for now we return NULL
 261               	 	*buf is a pointer to the env variables
 262               	 ************************************************************************/
 263               	_ll_getenv:
 264 029a 7000      		move.l #0,%d0
 265 029c 4E75      		rts
 266               		
 267               	/*
 268               	char keyci(void);
 269               	*/
 270               	keyci:	.global keyci
 271 029e 48E7 41E0 		movem.l %d1/%d7/%a0-%a2, -(%sp)
 272               	#ifdef M68000
 273               		lea keyqueue, %a0
 274               		lea kqanz, %a1
 275               		lea kqstart, %a2
 276               	#else
 277 02a2 41FB 0170 		lea keyqueue(%pc), %a0
 277      0000 0000 
 278 02aa 43FB 0170 		lea kqanz(%pc), %a1
 278      0000 0000 
 279 02b2 45FB 0170 		lea kqstart(%pc), %a2
 279      0000 0000 
 280               	#endif
 281 02ba 3E3C 003D 		move #_CURSEIN, %d7
 282 02be 4E41      		trap #1
 283               	keyci01:
 284 02c0 3E3C 003C 		move #_AUTOFLIP, %d7
 285 02c4 4E41      		trap #1
 286 02c6 4A51      	 	tst (%a1)			// kqanz
 287 02c8 67F6      		beq.s keyci01			// Warten auf Zeichen
68K GAS   			page 11


 288               	
 289 02ca 3212      		move (%a2), %d1			// kqstart
 290 02cc 1030 1000 		move.b 0(%a0, %d1.w), %d0
 291 02d0 5241      		addq #1, %d1			// Queue-Start ein nach hinten
 292 02d2 0241 00FF 		and #0xff, %d1			// auf 0..255 bringen
 293 02d6 3481      		move %d1, (%a2)			// kqstart speichern
 294 02d8 5351      		sub #1, (%a1)			// kqanz - Anzahl reduzieren
 295               		
 296 02da 3E3C 003E 		move #_CURSAUS, %d7
 297 02de 4E41      		trap #1
 298               		
 299 02e0 4CDF 0782 		movem.l (%sp)+, %d1/%d7/%a0-%a2
 300 02e4 4E75      		rts   
 301               			
 302               	.data
 303               	
 304 0000 0000 0000 	oldint74:	ds.l 1	
 305 0004 0000 0000 	oldint7c:	ds.l 1	
 306 0008 0000 0000 	ticks:		ds.l 1
 307               	
 308               	/* Key Variablen */
 309               	
 310 000c 0000 0000 	keyqueue:	ds.b 256		/* 256B Zeichenpuffer */
 310      0000 0000 
 310      0000 0000 
 310      0000 0000 
 310      0000 0000 
 311 010c 0000      	kqstart:	ds.w 1
 312 010e 0000      	kqend:		ds.w 1
 313 0110 0000      	kqanz:		ds.w 1
 314               	
 315               	
 316 0112 2043 7472 	ctrlctxt: 	.ascii " Ctrl-C"
 316      6C2D 43
 317 0119 0D0A 00   			.byte 0x0d,0x0a,0x00
 318 011c 2E        	dot: 		.ascii "."
 319 011d 00        			.byte 0x00		
68K GAS   			page 12


DEFINED SYMBOLS
            llmisc.S:33     .text:00000000 _ll_gettime
            llmisc.S:83     .text:00000152 _ll_ticks
            llmisc.S:263    .text:0000029a _ll_getenv
            llmisc.S:249    .text:00000286 _ll_system
            llmisc.S:101    .text:0000015e timerinit
            llmisc.S:151    .text:000001ce timerclose
            llmisc.S:306    .data:00000008 ticks
            llmisc.S:311    .data:0000010c kqstart
            llmisc.S:312    .data:0000010e kqend
            llmisc.S:313    .data:00000110 kqanz
            llmisc.S:305    .data:00000004 oldint7c
            llmisc.S:304    .data:00000000 oldint74
            llmisc.S:170    .text:000001f4 trap1F
            llmisc.S:186    .text:00000208 checkkbd
            llmisc.S:233    .text:00000276 tr1Fend
            llmisc.S:210    .text:00000244 getkbd
            llmisc.S:316    .data:00000112 ctrlctxt
            llmisc.S:310    .data:0000000c keyqueue
            llmisc.S:270    .text:0000029e keyci
            llmisc.S:283    .text:000002c0 keyci01
            llmisc.S:318    .data:0000011c dot

UNDEFINED SYMBOLS
raise
