68K GAS   			page 1


   1               	#include "../nkc/nkc.h"
   0               	
   0               	
   1               	#ifndef __EQU_H
   2               	#include "../nkc/macros.h"
   1               	#ifndef __MACROS_H
   2               	#define __MACROS_H
   3               	
   4               	
   5               	/* DEBUG MACROS */
   6               	#ifdef CONFIG_DEBUG_GIDE_S
   7               	
   8               	.macro dbg msg
   9               	        writeln \msg
  10               	.endm   
  11               	
  12               	.macro dbgwait
  13               	        waitcr
  14               	.endm
  15               	
  16               	
  17               	#else
  18               	.macro dbg msg
  19               	.endm
  20               	
  21               	.macro dbgwait
  22               	.endm
  23               	#endif     
  24               	
  25               	/*
  26               	   Ermittelt die PC-realtive effekive Addresse von var und legt sie in a0 ab.
  27               	   Wird für 68000 gebraucht, da dieser nur 64KB Addressierung kennt:
  28               		lea var(pc),a0 ; funktioniert i.A. nur ab 68020
  29               		LEA32A0 var    ; erledigt das für den 68000
  30               	
  31               		Die Subroutine _LEA32A0 liegt in start00.S
  32               	*/
  33               	
  34               	#ifdef M68000
  35               	.macro LEA32A0 var
  36               		move.l #\var,-(%sp)
  37               		move.l #1f,-(%sp)
  38               		jsr _LEA32A0
  39               	1:	addq.l #8,%sp
  40               	.endm
  41               	
  42               	.macro LEA32 var,reg
  43               		move.l #\var,-(%sp)
  44               		move.l #1f,-(%sp)
  45               		jsr _LEA32A0
  46               	1:	addq.l #8,%sp
  47               		movea.l %a0,\reg
  48               	.endm
  49               	
  50               	/* pea kann auch nur mit 16Bit Displacements ! i.e. "pea d16(pc)" */
  51               	.macro _LEA var,reg
  52               		pea #\var
68K GAS   			page 2


  53               		move.l (%sp)+,\reg
  54               	.endm
  55               	#endif
  56               	
  57               	
  58               	/* Gibt Text an momentaner Cursor Position aus */
  59               	.macro writeln  text             
  60               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
  61               	#ifdef M68000
  62               		LEA32A0 \text
  63               	#else
  64               	        lea \text,%a0
  65               	#endif
  66               	1:
  67               	        move.b (%a0)+,%d0
  68               	        beq 2f
  69               	        moveq #_CO2,%d7
  70               	        trap #1
  71               	        bra 1b
  72               	2:
  73               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
  74               	.endm
  75               	
  76               	.macro prntdot             
  77               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
  78               	        move.b #'.',%d0
  79               	        moveq #_CO2,%d7
  80               	        trap #1
  81               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
  82               	.endm
  83               	
  84               	
  85               	.macro crlf                      
  86               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
  87               	        moveq #_CRLF,%d7
  88               	        trap #1
  89               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
  90               	.endm
  91               	
  92               	
  93               	/* jumps to x,y position */
  94               	
  95               	.macro gotoxy x y           
  96               	 	movem.l %a0-%a6/%d0-%d7,-(%a7)
  97               	 	move.b #\x,%d1           /* d1=X (0..79)*/
  98               	 	move.b #\y,%d2           /* d2=Y (0..23)*/
  99               	 	moveq #_SETCURXY,%d7
 100               	 	trap #1
 101               	 	movem.l (%a7)+,%a0-%a6/%d0-%d7
 102               	.endm
 103               	
 104               	
 105               	.macro getxy x y           
 106               	 	movem.l %a0-%a6/%d0-%d7,-(%a7)
 107               	 	moveq #_GETCURXY,%d7
 108               	 	trap #1
 109               	 	move.b %d1,#\x           /* d1=X (0..79)*/
68K GAS   			page 3


 110               	 	move.b %d2,#\y           /* d2=Y (0..23)*/
 111               	 	movem.l (%a7)+,%a0-%a6/%d0-%d7
 112               	.endm
 113               	
 114               	.macro writexy size x y text            /* gibt einen text an x/y position aus*/
 115               	                            	   	/* TextGrüsse,X,Y,TextAddr (Nullterminiert)*/
 116               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 117               	        move.b #\size,%d0
 118               	        move.w #\x,%d1
 119               	        move.w #\y,%d2
 120               	        lea \text,%a0
 121               	        moveq #_WRITE,%d7
 122               	        trap #1
 123               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 124               	.endm
 125               	
 126               	
 127               	
 128               	.macro clrscr                    /* loescht den Bildschirm */
 129               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 130               	        moveq #_CLRSCREEN,%d7
 131               	        trap #1
 132               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 133               	.endm
 134               	
 135               	
 136               	
 137               	
 138               	.macro prthex2  value                 	/* gibt 2stellige HEX Zahl aus*/
 139               	                                	/* IN: WERT*/
 140               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 141               	        move.l \value,%d0
 142               	        lea buffer(%pc),%a0
 143               	        moveq #_PRINT2X,%d7
 144               	        trap #1
 145               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 146               	.endm
 147               	
 148               	
 149               	.macro prthex8  value            /* gibt 8stellige Hex Zahl aus */
 150               	                                 /* In: WERT */
 151               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 152               	        move.l \value,%d0
 153               	#ifdef M68000
 154               		LEA32A0 buffer
 155               	#else
 156               	        lea buffer(%pc),%a0
 157               	#endif
 158               	        moveq #_PRINT8X,%d7
 159               	        trap #1
 160               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 161               	.endm
 162               	
 163               	.macro waitcr                    /* Wartet auf CR (Enter) */
 164               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 165               	1:
 166               	        moveq #_CI,%d7
68K GAS   			page 4


 167               	        trap #1
 168               	        cmp.b #0xd,%d0
 169               	        bne.s 1b
 170               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 171               	.endm
 172               	
 173               	
 174               	.macro CMOS_READ index
 175               		movem.l %a0-%a1,-(%a7)
 176               		clr.l %d0
 177               		move.b \index,RTC_DS12887_INDEX.w
 178               		move.b RTC_DS12887_DATA.w,%d0
 179               		movem.l (%a7)+,%a0-%a1
 180               	.endm
 181               	
 182               	.macro BCD_TO_BIN
 183               		movem.l %d1,-(%a7)
 184               		move.l %d0,%d1
 185               		andi #0x0f,%d0
 186               		lsr #4,%d1
 187               		mulu #10,%d1
 188               		add %d1,%d0
 189               		movem.l (%a7)+,%d1
 190               	.endm
 191               	
 192               	.macro BIN_TO_BCD		/*ist zwar 2 Befehle länger, aber schneller und für alle 68xxx*/
 193               		movem.l %d1,-(%a7)
 194               		and.l #0xff,%d0		/*nur Byte gültig*/
 195               		divu #10,%d0
 196               		move %d0,%d1
 197               		lsl #4, %d1
 198               		swap %d0
 199               		add %d0, %d1
 200               		exg %d0, %d1
 201               		movem.l (%a7)+,%d1
 202               	.endm
 203               	
   3               	
   4               	/*
   5               	#define _F_READ	= 1
   6               	#define _F_WRIT = 2
   7               	#define _F_LBUF = 8
   8               	#define FILTOK = 0x444c  
   9               	#define _N_FILE = 100
  10               	*/
  11               	.equ	_F_READ,1
  12               	.equ	_F_WRIT,2
  13               	.equ	_F_LBUF,8
  14               	.equ	FILTOK,0x444c
  15               	.equ	NOFILTOK,0x5555
  16               	.equ	_N_FILE,100
  17               	
  18               		.data 
  19               		.global stdin, stdout, stderr
  20               		.global output_file, error_file
  21               	
  22 0000 0000 0000 	inbuf:	.space	512,0
68K GAS   			page 5


  22      0000 0000 
  22      0000 0000 
  22      0000 0000 
  22      0000 0000 
  23 0200 0000 0000 	outbuf:	.space	512,0
  23      0000 0000 
  23      0000 0000 
  23      0000 0000 
  23      0000 0000 
  24 0400 0000 0000 	errbuf:	.space	512,0
  24      0000 0000 
  24      0000 0000 
  24      0000 0000 
  24      0000 0000 
  25               	
  26               	output_file:
  27 0600 0000 0000 		dc.l 0					/* level 	+0  */
  28 0604 0000 000B 		dc.l (_F_WRIT | _F_READ | _F_LBUF)	/* flags 	+4  */
  29 0608 01        		dc.b 1					/* fd    	+8  */
  30 0609 00        		dc.b 0					/* hold  	+9  */
  31 060a 0000 0001 		dc.l 1					/* bsize 	+10 */
  32 060e 0000 0000 		dc.l inbuf				/* bufp  	+14 */
  33 0612 0000 0000 		dc.l outbuf				/* curp  	+18 */
  34 0616 0000 0000 		dc.l 0					/* istemp	+22 */
  35 061a 444C      		dc.w FILTOK				/* token 	+26 */
  36               		
  37               	error_file:
  38 061c 0000 0000 		dc.l 0					/* level */
  39 0620 0000 000A 		dc.l (_F_WRIT |  _F_LBUF)		/* flags */
  40 0624 02        		dc.b 2					/* fd    */
  41 0625 00        		dc.b 0					/* hold  */
  42 0626 0000 0001 		dc.l 1					/* bsize */
  43 062a 0000 0000 		dc.l errbuf				/* bufp  */
  44 062e 0000 0000 		dc.l errbuf				/* curp  */
  45 0632 0000 0000 		dc.l 0					/* istemp*/
  46 0636 444C      		dc.w FILTOK				/* token */
  47               		
  48 0638 0000 0000 	stdin:	dc.l	output_file
  49 063c 0000 0000 	stdout:	dc.l	output_file
  50 0640 0000 0000 	stderr:	dc.l	error_file
  51               	
  52               		.text
  53               		.global   _ll_read, _ll_write
  54               	
  55               	
  56               	/*****************************************************************************
  57               	 * int _ll_write(int fd, void *buf, int size)
  58               	 *****************************************************************************/ 
  59               	_ll_write:
  60 0000 48E7 3F3E 		movem.l %a2-%a6/%d2-%d7,-(%a7)  /* save registers */
  61               	
  62               		//writeln msg05(%pc)
  63               		
  64 0004 202F 0034 	 	move.l 52(%sp),%d0		/* *buf */
  65 0008 222F 0038 		move.l 56(%sp),%d1		/* size */
  66 000c 242F 0030 		move.l 48(%sp),%d2		/* fd   */	
  67               		
68K GAS   			page 6


  68               		
  69 0010 0C82 0000 		cmp.l #1,%d2			/* stdout ? */	
  69      0001 
  70 0016 6700 0010 		beq _ll_write_L0		/* ja -> Ausgabe auf Bldschirm */
  71 001a 0C82 0000 		cmp.l #2,%d2			/* stderr ? */	
  71      0002 
  72 0020 6700 0006 		beq _ll_write_L0		/* ja -> Ausgabe auf Bldschirm */
  73               		
  74 0024 6000 0018 		bra _ll_write_file		/* nein -> Ausgabe in Datei */
  75               		
  76               	_ll_write_L0:	
  77 0028 2040      		move.l %d0,%a0	  		/* Buffer ausgeben */
  78 002a 5381      		sub.l #1,%d1			/* Schleifenzähler */
  79               	_ll_write_L1:
  80 002c 1018      	        move.b (%a0)+,%d0
  81 002e 7E21      	        moveq #_CO2,%d7
  82 0030 4E41      	        trap #1        
  83 0032 51C9 FFF8 	        dbra %d1, _ll_write_L1
  84               	        
  85               	_ll_write_L2:	  
  86 0036 202F 0038 		move.l 56(%sp),%d0		/* wir geben jetzt einfach mal size zurück */
  87 003a 6000 001C 		bra _ll_write_end
  88               		
  89               		
  90               	_ll_write_file:				/* Ausgabe in Datei (Handle in %d2) */							
  91 003e 2F01      		move.l %d1,-(%sp)
  92 0040 2F00      		move.l %d0,-(%sp)
  93 0042 2F02      		move.l %d2,-(%sp)
  94               		//jsr jfwrite(%pc)
  95 0044 4EBB 0170 		jsr __ll_write(%pc)
  95      0000 0000 
  96 004c DFFC 0000 		add.l #12,%sp
  96      000C 
  97               		
  98 0052 6000 0004 		bra _ll_write_end	
  99               		
 100               	_ll_write_err:
 101 0056 4280      		clr.l %d0			/* return NULL */
 102               						/* return value nach d0 */
 103               	_ll_write_end:					
 104 0058 4CDF 7CFC 		movem.l (%a7)+,%a2-%a6/%d2-%d7	/* restore registers */
 105 005c 4E75      		rts
 106               	/*****************************************************************************
 107               	 * int _ll_read(int fd, void *buf, int size)
 108               	   returns number of read characters
 109               	 *****************************************************************************/ 
 110               	_ll_read:
 111 005e 48E7 3F3E 		movem.l %a2-%a6/%d2-%d7,-(%a7)  /* save registers: -> 11x4(saved registers) + 1x4(saved pc) = 48(s
 112               	
 113               		//writeln msg01(%pc)
 114               		
 115 0062 202F 0034 	 	move.l 52(%sp),%d0		/* *buf */
 116 0066 222F 0038 		move.l 56(%sp),%d1		/* size */
 117 006a 242F 0030 		move.l 48(%sp),%d2		/* fd   */	
 118               		
 119               		
 120 006e 0C82 0000 		cmp.l #1,%d2			/* stdin ? */	
68K GAS   			page 7


 120      0001 
 121 0074 6700 0006 		beq _ll_read_L0			/* ja -> Tastatur abfragen */
 122 0078 6000 0018 		bra _ll_read_file		/* nein -> Aus Datei lesen */	
 123               		
 124               	_ll_read_L0:	
 125 007c 2040      		move.l %d0,%a0	  		/* Buffer laden */
 126 007e 5381      		sub.l #1,%d1			/* Schleifenzähler */
 127               	_ll_read_L1:        
 128               	
 129               		/*bsr.l keyci Problem mit 68000 (illegal instruction) => dem Compiler überlassen */
 130               	#ifdef M68000
 131               		jsr keyci
 132               	#else
 133 0080 6100 0000 		bsr keyci
 134               	#endif
 135               	
 136               	_ll_read_L2:         
 137 0084 10C0      	        move.b %d0,(%a0)+
 138 0086 51C9 FFF8 	        dbra %d1, _ll_read_L1	
 139               	
 140               	_ll_read_L3:	  
 141 008a 202F 0038 		move.l 56(%sp),%d0		/* wir geben jetzt einfach mal size zurück */
 142 008e 6000 001C 		bra _ll_read_end
 143               		
 144               		
 145               	_ll_read_file:				/* Lesen aus Datei Datei (Handle in %d2) */							
 146 0092 2F01      		move.l %d1,-(%sp)		/* size */
 147 0094 2F00      		move.l %d0,-(%sp)		/* *buf */
 148 0096 2F02      		move.l %d2,-(%sp)		/* fd */
 149               		//jsr jfread(%pc)
 150 0098 4EBB 0170 		jsr __ll_read(%pc)
 150      0000 0000 
 151 00a0 DFFC 0000 		add.l #12,%sp
 151      000C 
 152 00a6 6000 0004 		bra _ll_read_end	
 153               		
 154               	_ll_read_err:
 155 00aa 4280      		clr.l %d0			/* return NULL */
 156               						/* return value nach d0 */
 157               	_ll_read_end:						
 158 00ac 4CDF 7CFC 		movem.l (%a7)+,%a2-%a6/%d2-%d7	/* restore registers */
 159 00b0 4E75      		rts
 160               		
 161               		
 162               	
 163               	// the lea instruction can only load (d16,pc) addresses on 68000 (on 68020 (d32,pc) is possible)
 164               	// separation of data leads to "relocation truncated to fit: R_68K_PC16 against `.data'"
 165               	
 166               	
 167               	.data
 168               	
 169               	
 170 0644 0000 0000 	buffer:		ds.b 256 
 170      0000 0000 
 170      0000 0000 
 170      0000 0000 
 170      0000 0000 
68K GAS   			page 8


 171               	
 172 0744 5F6C 6C5F 	msg01:	.ascii "_ll_read_"
 172      7265 6164 
 172      5F
 173 074d 0D0A 00   		.byte	0xd,0xa,0
 174               		
 175               		
 176 0750 2062 7566 	msg02:	.asciz " buffer = 0x"
 176      6665 7220 
 176      3D20 3078 
 176      00
 177 075d 2073 697A 	msg03:	.asciz " size   = 0x"
 177      6520 2020 
 177      3D20 3078 
 177      00
 178 076a 2066 6420 	msg04:	.asciz " fd     = 0x"
 178      2020 2020 
 178      3D20 3078 
 178      00
 179               	
 180 0777 5F6C 6C5F 	msg05:	.ascii "_ll_write_"
 180      7772 6974 
 180      655F 
 181 0781 0D0A 00   		.byte	0xd,0xa,0
 182               		
 183 0784 0D0A 00   	crlf:    .byte 0xd,0xa,0
68K GAS   			page 9


DEFINED SYMBOLS
             llstd.S:11     *ABS*:00000001 _F_READ
             llstd.S:12     *ABS*:00000002 _F_WRIT
             llstd.S:13     *ABS*:00000008 _F_LBUF
             llstd.S:14     *ABS*:0000444c FILTOK
             llstd.S:15     *ABS*:00005555 NOFILTOK
             llstd.S:16     *ABS*:00000064 _N_FILE
             llstd.S:48     .data:00000638 stdin
             llstd.S:49     .data:0000063c stdout
             llstd.S:50     .data:00000640 stderr
             llstd.S:26     .data:00000600 output_file
             llstd.S:37     .data:0000061c error_file
             llstd.S:22     .data:00000000 inbuf
             llstd.S:23     .data:00000200 outbuf
             llstd.S:24     .data:00000400 errbuf
             llstd.S:110    .text:0000005e _ll_read
             llstd.S:59     .text:00000000 _ll_write
             llstd.S:76     .text:00000028 _ll_write_L0
             llstd.S:90     .text:0000003e _ll_write_file
             llstd.S:79     .text:0000002c _ll_write_L1
             llstd.S:85     .text:00000036 _ll_write_L2
             llstd.S:103    .text:00000058 _ll_write_end
             llstd.S:100    .text:00000056 _ll_write_err
             llstd.S:124    .text:0000007c _ll_read_L0
             llstd.S:145    .text:00000092 _ll_read_file
             llstd.S:127    .text:00000080 _ll_read_L1
             llstd.S:136    .text:00000084 _ll_read_L2
             llstd.S:140    .text:0000008a _ll_read_L3
             llstd.S:157    .text:000000ac _ll_read_end
             llstd.S:154    .text:000000aa _ll_read_err
             llstd.S:170    .data:00000644 buffer
             llstd.S:172    .data:00000744 msg01
             llstd.S:176    .data:00000750 msg02
             llstd.S:177    .data:0000075d msg03
             llstd.S:178    .data:0000076a msg04
             llstd.S:180    .data:00000777 msg05
             llstd.S:183    .data:00000784 crlf

UNDEFINED SYMBOLS
__ll_write
keyci
__ll_read
