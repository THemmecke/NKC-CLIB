68K GAS   			page 1


   1               	/* libgcc routines for 68000 w/o floating-point hardware.
   0               	
   0               	
   2               	   Copyright (C) 1994, 1996, 1997, 1998, 2008, 2009 Free Software Foundation, Inc.
   3               	
   4               	This file is part of GCC.
   5               	
   6               	GCC is free software; you can redistribute it and/or modify it
   7               	under the terms of the GNU General Public License as published by the
   8               	Free Software Foundation; either version 3, or (at your option) any
   9               	later version.
  10               	
  11               	This file is distributed in the hope that it will be useful, but
  12               	WITHOUT ANY WARRANTY; without even the implied warranty of
  13               	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14               	General Public License for more details.
  15               	
  16               	Under Section 7 of GPL version 3, you are granted additional
  17               	permissions described in the GCC Runtime Library Exception, version
  18               	3.1, as published by the Free Software Foundation.
  19               	
  20               	You should have received a copy of the GNU General Public License and
  21               	a copy of the GCC Runtime Library Exception along with this program;
  22               	see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
  23               	<http://www.gnu.org/licenses/>.  */
  24               	
  25               	/* Use this one for any 680x0; assumes no floating point hardware.
  26               	   The trailing " '" appearing on some lines is for ANSI preprocessors.  Yuk.
  27               	   Some of this code comes from MINIX, via the folks at ericsson.
  28               	   D. V. Henkel-Wallace (gumby@cygnus.com) Fete Bastille, 1992
  29               	*/
  30               	
  31               	/* These are predefined by new versions of GNU cpp.  */
  32               	
  33               	#ifndef __USER_LABEL_PREFIX__
  34               	#define __USER_LABEL_PREFIX__ _
  35               	#endif
  36               	
  37               	#ifndef __REGISTER_PREFIX__
  38               	#define __REGISTER_PREFIX__
  39               	#endif
  40               	
  41               	#ifndef __IMMEDIATE_PREFIX__
  42               	#define __IMMEDIATE_PREFIX__ #
  43               	#endif
  44               	
  45               	/* ANSI concatenation macros.  */
  46               	
  47               	#define CONCAT1(a, b) CONCAT2(a, b)
  48               	#define CONCAT2(a, b) a ## b
  49               	
  50               	/* Use the right prefix for global labels.  */
  51               	
  52               	#define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)
  53               	
  54               	/* Note that X is a function.  */
  55               		
68K GAS   			page 2


  56               	#ifdef __ELF__
  57               	#define FUNC(x) .type SYM(x),function
  58               	#else
  59               	/* The .proc pseudo-op is accepted, but ignored, by GAS.  We could just	
  60               	   define this to the empty string for non-ELF systems, but defining it
  61               	   to .proc means that the information is available to the assembler if
  62               	   the need arises.  */
  63               	#define FUNC(x) .proc
  64               	#endif
  65               			
  66               	/* Use the right prefix for registers.  */
  67               	
  68               	#define REG(x) CONCAT1 (__REGISTER_PREFIX__, x)
  69               	
  70               	/* Use the right prefix for immediate values.  */
  71               	
  72               	#define IMM(x) CONCAT1 (__IMMEDIATE_PREFIX__, x)
  73               	
  74               	#define d0 REG (d0)
  75               	#define d1 REG (d1)
  76               	#define d2 REG (d2)
  77               	#define d3 REG (d3)
  78               	#define d4 REG (d4)
  79               	#define d5 REG (d5)
  80               	#define d6 REG (d6)
  81               	#define d7 REG (d7)
  82               	#define a0 REG (a0)
  83               	#define a1 REG (a1)
  84               	#define a2 REG (a2)
  85               	#define a3 REG (a3)
  86               	#define a4 REG (a4)
  87               	#define a5 REG (a5)
  88               	#define a6 REG (a6)
  89               	#define fp REG (fp)
  90               	#define sp REG (sp)
  91               	#define pc REG (pc)
  92               	
  93               	/* Provide a few macros to allow for PIC code support.
  94               	 * With PIC, data is stored A5 relative so we've got to take a bit of special
  95               	 * care to ensure that all loads of global data is via A5.  PIC also requires
  96               	 * jumps and subroutine calls to be PC relative rather than absolute.  We cheat
  97               	 * a little on this and in the PIC case, we use short offset branches and
  98               	 * hope that the final object code is within range (which it should be).
  99               	 */
 100               	#ifndef __PIC__
 101               	
 102               		/* Non PIC (absolute/relocatable) versions */
 103               	
 104               		.macro PICCALL addr
 105               		jbsr	\addr
 106               		.endm
 107               	
 108               		.macro PICJUMP addr
 109               		jmp	\addr
 110               		.endm
 111               	
 112               		.macro PICLEA sym, reg
68K GAS   			page 3


 113               		lea	\sym, \reg
 114               		.endm
 115               	
 116               		.macro PICPEA sym, areg
 117               		pea	\sym
 118               		.endm
 119               	
 120               	#else /* __PIC__ */
 121               	
 122               	# if defined (__uClinux__)
 123               	
 124               		/* Versions for uClinux */
 125               	
 126               	#  if defined(__ID_SHARED_LIBRARY__)
 127               	
 128               		/* -mid-shared-library versions  */
 129               	
 130               		.macro PICLEA sym, reg
 131               		movel	a5@(_current_shared_library_a5_offset_), \reg
 132               		movel	\sym@GOT(\reg), \reg
 133               		.endm
 134               	
 135               		.macro PICPEA sym, areg
 136               		movel	a5@(_current_shared_library_a5_offset_), \areg
 137               		movel	\sym@GOT(\areg), sp@-
 138               		.endm
 139               	
 140               		.macro PICCALL addr
 141               		PICLEA	\addr,a0
 142               		jsr	a0@
 143               		.endm
 144               	
 145               		.macro PICJUMP addr
 146               		PICLEA	\addr,a0
 147               		jmp	a0@
 148               		.endm
 149               	
 150               	#  else /* !__ID_SHARED_LIBRARY__ */
 151               	
 152               		/* Versions for -msep-data */
 153               	
 154               		.macro PICLEA sym, reg
 155               		movel	\sym@GOT(a5), \reg
 156               		.endm
 157               	
 158               		.macro PICPEA sym, areg
 159               		movel	\sym@GOT(a5), sp@-
 160               		.endm
 161               	
 162               		.macro PICCALL addr
 163               	#if defined (__mcoldfire__) && !defined (__mcfisab__) && !defined (__mcfisac__)
 164               		lea	\addr-.-8,a0
 165               		jsr	pc@(a0)
 166               	#else
 167               		jbsr	\addr
 168               	#endif
 169               		.endm
68K GAS   			page 4


 170               	
 171               		.macro PICJUMP addr
 172               		/* ISA C has no bra.l instruction, and since this assembly file
 173               		   gets assembled into multiple object files, we avoid the
 174               		   bra instruction entirely.  */
 175               	#if defined (__mcoldfire__) && !defined (__mcfisab__)
 176               		lea	\addr-.-8,a0
 177               		jmp	pc@(a0)
 178               	#else
 179               		bra	\addr
 180               	#endif
 181               		.endm
 182               	
 183               	#  endif
 184               	
 185               	# else /* !__uClinux__ */
 186               	
 187               		/* Versions for Linux */
 188               	
 189               		.macro PICLEA sym, reg
 190               		movel	#_GLOBAL_OFFSET_TABLE_@GOTPC, \reg
 191               		lea	(-6, pc, \reg), \reg
 192               		movel	\sym@GOT(\reg), \reg
 193               		.endm
 194               	
 195               		.macro PICPEA sym, areg
 196               		movel	#_GLOBAL_OFFSET_TABLE_@GOTPC, \areg
 197               		lea	(-6, pc, \areg), \areg
 198               		movel	\sym@GOT(\areg), sp@-
 199               		.endm
 200               	
 201               		.macro PICCALL addr
 202               	#if defined (__mcoldfire__) && !defined (__mcfisab__) && !defined (__mcfisac__)
 203               		lea	\addr-.-8,a0
 204               		jsr	pc@(a0)
 205               	#else
 206               		jbsr	\addr
 207               	#endif
 208               		.endm
 209               	
 210               		.macro PICJUMP addr
 211               		/* ISA C has no bra.l instruction, and since this assembly file
 212               		   gets assembled into multiple object files, we avoid the
 213               		   bra instruction entirely.  */
 214               	#if defined (__mcoldfire__) && !defined (__mcfisab__)
 215               		lea	\addr-.-8,a0
 216               		jmp	pc@(a0)
 217               	#else
 218               		bra	\addr
 219               	#endif
 220               		.endm
 221               	
 222               	# endif
 223               	#endif /* __PIC__ */
 224               	
 225               	
 226               	#ifdef L_floatex
68K GAS   			page 5


 227               	
 228               	| This is an attempt at a decent floating point (single, double and 
 229               	| extended double) code for the GNU C compiler. It should be easy to
 230               	| adapt to other compilers (but beware of the local labels!).
 231               	
 232               	| Starting date: 21 October, 1990
 233               	
 234               	| It is convenient to introduce the notation (s,e,f) for a floating point
 235               	| number, where s=sign, e=exponent, f=fraction. We will call a floating
 236               	| point number fpn to abbreviate, independently of the precision.
 237               	| Let MAX_EXP be in each case the maximum exponent (255 for floats, 1023 
 238               	| for doubles and 16383 for long doubles). We then have the following 
 239               	| different cases:
 240               	|  1. Normalized fpns have 0 < e < MAX_EXP. They correspond to 
 241               	|     (-1)^s x 1.f x 2^(e-bias-1).
 242               	|  2. Denormalized fpns have e=0. They correspond to numbers of the form
 243               	|     (-1)^s x 0.f x 2^(-bias).
 244               	|  3. +/-INFINITY have e=MAX_EXP, f=0.
 245               	|  4. Quiet NaN (Not a Number) have all bits set.
 246               	|  5. Signaling NaN (Not a Number) have s=0, e=MAX_EXP, f=1.
 247               	
 248               	|=============================================================================
 249               	|                                  exceptions
 250               	|=============================================================================
 251               	
 252               	| This is the floating point condition code register (_fpCCR):
 253               	|
 254               	| struct {
 255               	|   short _exception_bits;	
 256               	|   short _trap_enable_bits;	
 257               	|   short _sticky_bits;
 258               	|   short _rounding_mode;
 259               	|   short _format;
 260               	|   short _last_operation;
 261               	|   union {
 262               	|     float sf;
 263               	|     double df;
 264               	|   } _operand1;
 265               	|   union {
 266               	|     float sf;
 267               	|     double df;
 268               	|   } _operand2;
 269               	| } _fpCCR;
 270               	
 271               		.data
 272               		.even
 273               	
 274               		.globl	SYM (_fpCCR)
 275               		
 276               	SYM (_fpCCR):
 277               	__exception_bits:
 278               		.word	0
 279               	__trap_enable_bits:
 280               		.word	0
 281               	__sticky_bits:
 282               		.word	0
 283               	__rounding_mode:
68K GAS   			page 6


 284               		.word	ROUND_TO_NEAREST
 285               	__format:
 286               		.word	NIL
 287               	__last_operation:
 288               		.word	NOOP
 289               	__operand1:
 290               		.long	0
 291               		.long	0
 292               	__operand2:
 293               		.long 	0
 294               		.long	0
 295               	
 296               	| Offsets:
 297               	EBITS  = __exception_bits - SYM (_fpCCR)
 298               	TRAPE  = __trap_enable_bits - SYM (_fpCCR)
 299               	STICK  = __sticky_bits - SYM (_fpCCR)
 300               	ROUND  = __rounding_mode - SYM (_fpCCR)
 301               	FORMT  = __format - SYM (_fpCCR)
 302               	LASTO  = __last_operation - SYM (_fpCCR)
 303               	OPER1  = __operand1 - SYM (_fpCCR)
 304               	OPER2  = __operand2 - SYM (_fpCCR)
 305               	
 306               	| The following exception types are supported:
 307               	INEXACT_RESULT 		= 0x0001
 308               	UNDERFLOW 		= 0x0002
 309               	OVERFLOW 		= 0x0004
 310               	DIVIDE_BY_ZERO 		= 0x0008
 311               	INVALID_OPERATION 	= 0x0010
 312               	
 313               	| The allowed rounding modes are:
 314               	UNKNOWN           = -1
 315               	ROUND_TO_NEAREST  = 0 | round result to nearest representable value
 316               	ROUND_TO_ZERO     = 1 | round result towards zero
 317               	ROUND_TO_PLUS     = 2 | round result towards plus infinity
 318               	ROUND_TO_MINUS    = 3 | round result towards minus infinity
 319               	
 320               	| The allowed values of format are:
 321               	NIL          = 0
 322               	SINGLE_FLOAT = 1
 323               	DOUBLE_FLOAT = 2
 324               	LONG_FLOAT   = 3
 325               	
 326               	| The allowed values for the last operation are:
 327               	NOOP         = 0
 328               	ADD          = 1
 329               	MULTIPLY     = 2
 330               	DIVIDE       = 3
 331               	NEGATE       = 4
 332               	COMPARE      = 5
 333               	EXTENDSFDF   = 6
 334               	TRUNCDFSF    = 7
 335               	
 336               	|=============================================================================
 337               	|                           __clear_sticky_bits
 338               	|=============================================================================
 339               	
 340               	| The sticky bits are normally not cleared (thus the name), whereas the 
68K GAS   			page 7


 341               	| exception type and exception value reflect the last computation. 
 342               	| This routine is provided to clear them (you can also write to _fpCCR,
 343               	| since it is globally visible).
 344               	
 345               		.globl  SYM (__clear_sticky_bit)
 346               	
 347               		.text
 348               		.even
 349               	
 350               	| void __clear_sticky_bits(void);
 351               	SYM (__clear_sticky_bit):		
 352               		PICLEA	SYM (_fpCCR),a0
 353               	#ifndef __mcoldfire__
 354               		movew	IMM (0),a0@(STICK)
 355               	#else
 356               		clr.w	a0@(STICK)
 357               	#endif
 358               		rts
 359               	
 360               	|=============================================================================
 361               	|                           $_exception_handler
 362               	|=============================================================================
 363               	
 364               		.globl  $_exception_handler
 365               	
 366               		.text
 367               		.even
 368               	
 369               	| This is the common exit point if an exception occurs.
 370               	| NOTE: it is NOT callable from C!
 371               	| It expects the exception type in d7, the format (SINGLE_FLOAT,
 372               	| DOUBLE_FLOAT or LONG_FLOAT) in d6, and the last operation code in d5.
 373               	| It sets the corresponding exception and sticky bits, and the format. 
 374               	| Depending on the format if fills the corresponding slots for the 
 375               	| operands which produced the exception (all this information is provided
 376               	| so if you write your own exception handlers you have enough information
 377               	| to deal with the problem).
 378               	| Then checks to see if the corresponding exception is trap-enabled, 
 379               	| in which case it pushes the address of _fpCCR and traps through 
 380               	| trap FPTRAP (15 for the moment).
 381               	
 382               	FPTRAP = 15
 383               	
 384               	$_exception_handler:
 385               		PICLEA	SYM (_fpCCR),a0
 386               		movew	d7,a0@(EBITS)	| set __exception_bits
 387               	#ifndef __mcoldfire__
 388               		orw	d7,a0@(STICK)	| and __sticky_bits
 389               	#else
 390               		movew	a0@(STICK),d4
 391               		orl	d7,d4
 392               		movew	d4,a0@(STICK)
 393               	#endif
 394               		movew	d6,a0@(FORMT)	| and __format
 395               		movew	d5,a0@(LASTO)	| and __last_operation
 396               	
 397               	| Now put the operands in place:
68K GAS   			page 8


 398               	#ifndef __mcoldfire__
 399               		cmpw	IMM (SINGLE_FLOAT),d6
 400               	#else
 401               		cmpl	IMM (SINGLE_FLOAT),d6
 402               	#endif
 403               		beq	1f
 404               		movel	a6@(8),a0@(OPER1)
 405               		movel	a6@(12),a0@(OPER1+4)
 406               		movel	a6@(16),a0@(OPER2)
 407               		movel	a6@(20),a0@(OPER2+4)
 408               		bra	2f
 409               	1:	movel	a6@(8),a0@(OPER1)
 410               		movel	a6@(12),a0@(OPER2)
 411               	2:
 412               	| And check whether the exception is trap-enabled:
 413               	#ifndef __mcoldfire__
 414               		andw	a0@(TRAPE),d7	| is exception trap-enabled?
 415               	#else
 416               		clrl	d6
 417               		movew	a0@(TRAPE),d6
 418               		andl	d6,d7
 419               	#endif
 420               		beq	1f		| no, exit
 421               		PICPEA	SYM (_fpCCR),a1	| yes, push address of _fpCCR
 422               		trap	IMM (FPTRAP)	| and trap
 423               	#ifndef __mcoldfire__
 424               	1:	moveml	sp@+,d2-d7	| restore data registers
 425               	#else
 426               	1:	moveml	sp@,d2-d7
 427               		| XXX if frame pointer is ever removed, stack pointer must
 428               		| be adjusted here.
 429               	#endif
 430               		unlk	a6		| and return
 431               		rts
 432               	#endif /* L_floatex */
 433               	
 434               	#ifdef  L_mulsi3
 435               		.text
 436               		FUNC(__mulsi3)
 437               		.globl	SYM (__mulsi3)
 438               	SYM (__mulsi3):
 439               		movew	sp@(4), d0	/* x0 -> d0 */
 440               		muluw	sp@(10), d0	/* x0*y1 */
 441               		movew	sp@(6), d1	/* x1 -> d1 */
 442               		muluw	sp@(8), d1	/* x1*y0 */
 443               	#ifndef __mcoldfire__
 444               		addw	d1, d0
 445               	#else
 446               		addl	d1, d0
 447               	#endif
 448               		swap	d0
 449               		clrw	d0
 450               		movew	sp@(6), d1	/* x1 -> d1 */
 451               		muluw	sp@(10), d1	/* x1*y1 */
 452               		addl	d1, d0
 453               	
 454               		rts
68K GAS   			page 9


 455               	#endif /* L_mulsi3 */
 456               	
 457               	#ifdef  L_udivsi3
 458               		.text
 459               		FUNC(__udivsi3)
 460               		.globl	SYM (__udivsi3)
 461               	SYM (__udivsi3):
 462               	#ifndef __mcoldfire__
 463               		movel	d2, sp@-
 464               		movel	sp@(12), d1	/* d1 = divisor */
 465               		movel	sp@(8), d0	/* d0 = dividend */
 466               	
 467               		cmpl	IMM (0x10000), d1 /* divisor >= 2 ^ 16 ?   */
 468               		jcc	L3		/* then try next algorithm */
 469               		movel	d0, d2
 470               		clrw	d2
 471               		swap	d2
 472               		divu	d1, d2          /* high quotient in lower word */
 473               		movew	d2, d0		/* save high quotient */
 474               		swap	d0
 475               		movew	sp@(10), d2	/* get low dividend + high rest */
 476               		divu	d1, d2		/* low quotient */
 477               		movew	d2, d0
 478               		jra	L6
 479               	
 480               	L3:	movel	d1, d2		/* use d2 as divisor backup */
 481               	L4:	lsrl	IMM (1), d1	/* shift divisor */
 482               		lsrl	IMM (1), d0	/* shift dividend */
 483               		cmpl	IMM (0x10000), d1 /* still divisor >= 2 ^ 16 ?  */
 484               		jcc	L4
 485               		divu	d1, d0		/* now we have 16-bit divisor */
 486               		andl	IMM (0xffff), d0 /* mask out divisor, ignore remainder */
 487               	
 488               	/* Multiply the 16-bit tentative quotient with the 32-bit divisor.  Because of
 489               	   the operand ranges, this might give a 33-bit product.  If this product is
 490               	   greater than the dividend, the tentative quotient was too large. */
 491               		movel	d2, d1
 492               		mulu	d0, d1		/* low part, 32 bits */
 493               		swap	d2
 494               		mulu	d0, d2		/* high part, at most 17 bits */
 495               		swap	d2		/* align high part with low part */
 496               		tstw	d2		/* high part 17 bits? */
 497               		jne	L5		/* if 17 bits, quotient was too large */
 498               		addl	d2, d1		/* add parts */
 499               		jcs	L5		/* if sum is 33 bits, quotient was too large */
 500               		cmpl	sp@(8), d1	/* compare the sum with the dividend */
 501               		jls	L6		/* if sum > dividend, quotient was too large */
 502               	L5:	subql	IMM (1), d0	/* adjust quotient */
 503               	
 504               	L6:	movel	sp@+, d2
 505               		rts
 506               	
 507               	#else /* __mcoldfire__ */
 508               	
 509               	/* ColdFire implementation of non-restoring division algorithm from
 510               	   Hennessy & Patterson, Appendix A. */
 511               		link	a6,IMM (-12)
68K GAS   			page 10


 512               		moveml	d2-d4,sp@
 513               		movel	a6@(8),d0
 514               		movel	a6@(12),d1
 515               		clrl	d2		| clear p
 516               		moveq	IMM (31),d4
 517               	L1:	addl	d0,d0		| shift reg pair (p,a) one bit left
 518               		addxl	d2,d2
 519               		movl	d2,d3		| subtract b from p, store in tmp.
 520               		subl	d1,d3
 521               		jcs	L2		| if no carry,
 522               		bset	IMM (0),d0	| set the low order bit of a to 1,
 523               		movl	d3,d2		| and store tmp in p.
 524               	L2:	subql	IMM (1),d4
 525               		jcc	L1
 526               		moveml	sp@,d2-d4	| restore data registers
 527               		unlk	a6		| and return
 528               		rts
 529               	#endif /* __mcoldfire__ */
 530               	
 531               	#endif /* L_udivsi3 */
 532               	
 533               	#ifdef  L_divsi3
 534               		.text
 535               		FUNC(__divsi3)
 536               		.globl	SYM (__divsi3)
 537               	SYM (__divsi3):
 538               		movel	d2, sp@-
 539               	
 540               		moveq	IMM (1), d2	/* sign of result stored in d2 (=1 or =-1) */
 541               		movel	sp@(12), d1	/* d1 = divisor */
 542               		jpl	L1
 543               		negl	d1
 544               	#ifndef __mcoldfire__
 545               		negb	d2		/* change sign because divisor <0  */
 546               	#else
 547               		negl	d2		/* change sign because divisor <0  */
 548               	#endif
 549               	L1:	movel	sp@(8), d0	/* d0 = dividend */
 550               		jpl	L2
 551               		negl	d0
 552               	#ifndef __mcoldfire__
 553               		negb	d2
 554               	#else
 555               		negl	d2
 556               	#endif
 557               	
 558               	L2:	movel	d1, sp@-
 559               		movel	d0, sp@-
 560               		PICCALL	SYM (__udivsi3)	/* divide abs(dividend) by abs(divisor) */
 561               		addql	IMM (8), sp
 562               	
 563               		tstb	d2
 564               		jpl	L3
 565               		negl	d0
 566               	
 567               	L3:	movel	sp@+, d2
 568               		rts
68K GAS   			page 11


 569               	#endif /* L_divsi3 */
 570               	
 571               	#ifdef  L_umodsi3
 572               		.text
 573               		FUNC(__umodsi3)
 574               		.globl	SYM (__umodsi3)
 575               	SYM (__umodsi3):
 576               		movel	sp@(8), d1	/* d1 = divisor */
 577               		movel	sp@(4), d0	/* d0 = dividend */
 578               		movel	d1, sp@-
 579               		movel	d0, sp@-
 580               		PICCALL	SYM (__udivsi3)
 581               		addql	IMM (8), sp
 582               		movel	sp@(8), d1	/* d1 = divisor */
 583               	#ifndef __mcoldfire__
 584               		movel	d1, sp@-
 585               		movel	d0, sp@-
 586               		PICCALL	SYM (__mulsi3)	/* d0 = (a/b)*b */
 587               		addql	IMM (8), sp
 588               	#else
 589               		mulsl	d1,d0
 590               	#endif
 591               		movel	sp@(4), d1	/* d1 = dividend */
 592               		subl	d0, d1		/* d1 = a - (a/b)*b */
 593               		movel	d1, d0
 594               		rts
 595               	#endif /* L_umodsi3 */
 596               	
 597               	#ifdef  L_modsi3
 598               		.text
 599               		FUNC(__modsi3)
 600               		.globl	SYM (__modsi3)
 601               	SYM (__modsi3):
 602               		movel	sp@(8), d1	/* d1 = divisor */
 603               		movel	sp@(4), d0	/* d0 = dividend */
 604               		movel	d1, sp@-
 605               		movel	d0, sp@-
 606               		PICCALL	SYM (__divsi3)
 607               		addql	IMM (8), sp
 608               		movel	sp@(8), d1	/* d1 = divisor */
 609               	#ifndef __mcoldfire__
 610               		movel	d1, sp@-
 611               		movel	d0, sp@-
 612               		PICCALL	SYM (__mulsi3)	/* d0 = (a/b)*b */
 613               		addql	IMM (8), sp
 614               	#else
 615               		mulsl	d1,d0
 616               	#endif
 617               		movel	sp@(4), d1	/* d1 = dividend */
 618               		subl	d0, d1		/* d1 = a - (a/b)*b */
 619               		movel	d1, d0
 620               		rts
 621               	#endif /* L_modsi3 */
 622               	
 623               	
 624               	#ifdef  L_double
 625               	
68K GAS   			page 12


 626               		.globl	SYM (_fpCCR)
 627               		.globl  $_exception_handler
 628               	
 629               	QUIET_NaN      = 0xffffffff
 630               	
 631               	D_MAX_EXP      = 0x07ff
 632               	D_BIAS         = 1022
 633               	DBL_MAX_EXP    = D_MAX_EXP - D_BIAS
 634               	DBL_MIN_EXP    = 1 - D_BIAS
 635               	DBL_MANT_DIG   = 53
 636               	
 637               	INEXACT_RESULT 		= 0x0001
 638               	UNDERFLOW 		= 0x0002
 639               	OVERFLOW 		= 0x0004
 640               	DIVIDE_BY_ZERO 		= 0x0008
 641               	INVALID_OPERATION 	= 0x0010
 642               	
 643               	DOUBLE_FLOAT = 2
 644               	
 645               	NOOP         = 0
 646               	ADD          = 1
 647               	MULTIPLY     = 2
 648               	DIVIDE       = 3
 649               	NEGATE       = 4
 650               	COMPARE      = 5
 651               	EXTENDSFDF   = 6
 652               	TRUNCDFSF    = 7
 653               	
 654               	UNKNOWN           = -1
 655               	ROUND_TO_NEAREST  = 0 | round result to nearest representable value
 656               	ROUND_TO_ZERO     = 1 | round result towards zero
 657               	ROUND_TO_PLUS     = 2 | round result towards plus infinity
 658               	ROUND_TO_MINUS    = 3 | round result towards minus infinity
 659               	
 660               	| Entry points:
 661               	
 662               		.globl SYM (__adddf3)
 663               		.globl SYM (__subdf3)
 664               		.globl SYM (__muldf3)
 665               		.globl SYM (__divdf3)
 666               		.globl SYM (__negdf2)
 667               		.globl SYM (__cmpdf2)
 668               		.globl SYM (__cmpdf2_internal)
 669               		.hidden SYM (__cmpdf2_internal)
 670               	
 671               		.text
 672               		.even
 673               	
 674               	| These are common routines to return and signal exceptions.	
 675               	
 676               	Ld$den:
 677               	| Return and signal a denormalized number
 678               		orl	d7,d0
 679               		movew	IMM (INEXACT_RESULT+UNDERFLOW),d7
 680               		moveq	IMM (DOUBLE_FLOAT),d6
 681               		PICJUMP	$_exception_handler
 682               	
68K GAS   			page 13


 683               	Ld$infty:
 684               	Ld$overflow:
 685               	| Return a properly signed INFINITY and set the exception flags 
 686               		movel	IMM (0x7ff00000),d0
 687               		movel	IMM (0),d1
 688               		orl	d7,d0
 689               		movew	IMM (INEXACT_RESULT+OVERFLOW),d7
 690               		moveq	IMM (DOUBLE_FLOAT),d6
 691               		PICJUMP	$_exception_handler
 692               	
 693               	Ld$underflow:
 694               	| Return 0 and set the exception flags 
 695               		movel	IMM (0),d0
 696               		movel	d0,d1
 697               		movew	IMM (INEXACT_RESULT+UNDERFLOW),d7
 698               		moveq	IMM (DOUBLE_FLOAT),d6
 699               		PICJUMP	$_exception_handler
 700               	
 701               	Ld$inop:
 702               	| Return a quiet NaN and set the exception flags
 703               		movel	IMM (QUIET_NaN),d0
 704               		movel	d0,d1
 705               		movew	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
 706               		moveq	IMM (DOUBLE_FLOAT),d6
 707               		PICJUMP	$_exception_handler
 708               	
 709               	Ld$div$0:
 710               	| Return a properly signed INFINITY and set the exception flags
 711               		movel	IMM (0x7ff00000),d0
 712               		movel	IMM (0),d1
 713               		orl	d7,d0
 714               		movew	IMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7
 715               		moveq	IMM (DOUBLE_FLOAT),d6
 716               		PICJUMP	$_exception_handler
 717               	
 718               	|=============================================================================
 719               	|=============================================================================
 720               	|                         double precision routines
 721               	|=============================================================================
 722               	|=============================================================================
 723               	
 724               	| A double precision floating point number (double) has the format:
 725               	|
 726               	| struct _double {
 727               	|  unsigned int sign      : 1;  /* sign bit */ 
 728               	|  unsigned int exponent  : 11; /* exponent, shifted by 126 */
 729               	|  unsigned int fraction  : 52; /* fraction */
 730               	| } double;
 731               	| 
 732               	| Thus sizeof(double) = 8 (64 bits). 
 733               	|
 734               	| All the routines are callable from C programs, and return the result 
 735               	| in the register pair d0-d1. They also preserve all registers except 
 736               	| d0-d1 and a0-a1.
 737               	
 738               	|=============================================================================
 739               	|                              __subdf3
68K GAS   			page 14


 740               	|=============================================================================
 741               	
 742               	| double __subdf3(double, double);
 743               		FUNC(__subdf3)
 744               	SYM (__subdf3):
 745               		bchg	IMM (31),sp@(12) | change sign of second operand
 746               					| and fall through, so we always add
 747               	|=============================================================================
 748               	|                              __adddf3
 749               	|=============================================================================
 750               	
 751               	| double __adddf3(double, double);
 752               		FUNC(__adddf3)
 753               	SYM (__adddf3):
 754               	#ifndef __mcoldfire__
 755               		link	a6,IMM (0)	| everything will be done in registers
 756               		moveml	d2-d7,sp@-	| save all data registers and a2 (but d0-d1)
 757               	#else
 758               		link	a6,IMM (-24)
 759               		moveml	d2-d7,sp@
 760               	#endif
 761               		movel	a6@(8),d0	| get first operand
 762               		movel	a6@(12),d1	| 
 763               		movel	a6@(16),d2	| get second operand
 764               		movel	a6@(20),d3	| 
 765               	
 766               		movel	d0,d7		| get d0's sign bit in d7 '
 767               		addl	d1,d1		| check and clear sign bit of a, and gain one
 768               		addxl	d0,d0		| bit of extra precision
 769               		beq	Ladddf$b	| if zero return second operand
 770               	
 771               		movel	d2,d6		| save sign in d6 
 772               		addl	d3,d3		| get rid of sign bit and gain one bit of
 773               		addxl	d2,d2		| extra precision
 774               		beq	Ladddf$a	| if zero return first operand
 775               	
 776               		andl	IMM (0x80000000),d7 | isolate a's sign bit '
 777               	        swap	d6		| and also b's sign bit '
 778               	#ifndef __mcoldfire__
 779               		andw	IMM (0x8000),d6	|
 780               		orw	d6,d7		| and combine them into d7, so that a's sign '
 781               					| bit is in the high word and b's is in the '
 782               					| low word, so d6 is free to be used
 783               	#else
 784               		andl	IMM (0x8000),d6
 785               		orl	d6,d7
 786               	#endif
 787               		movel	d7,a0		| now save d7 into a0, so d7 is free to
 788               	                		| be used also
 789               	
 790               	| Get the exponents and check for denormalized and/or infinity.
 791               	
 792               		movel	IMM (0x001fffff),d6 | mask for the fraction
 793               		movel	IMM (0x00200000),d7 | mask to put hidden bit back
 794               	
 795               		movel	d0,d4		| 
 796               		andl	d6,d0		| get fraction in d0
68K GAS   			page 15


 797               		notl	d6		| make d6 into mask for the exponent
 798               		andl	d6,d4		| get exponent in d4
 799               		beq	Ladddf$a$den	| branch if a is denormalized
 800               		cmpl	d6,d4		| check for INFINITY or NaN
 801               		beq	Ladddf$nf       | 
 802               		orl	d7,d0		| and put hidden bit back
 803               	Ladddf$1:
 804               		swap	d4		| shift right exponent so that it starts
 805               	#ifndef __mcoldfire__
 806               		lsrw	IMM (5),d4	| in bit 0 and not bit 20
 807               	#else
 808               		lsrl	IMM (5),d4	| in bit 0 and not bit 20
 809               	#endif
 810               	| Now we have a's exponent in d4 and fraction in d0-d1 '
 811               		movel	d2,d5		| save b to get exponent
 812               		andl	d6,d5		| get exponent in d5
 813               		beq	Ladddf$b$den	| branch if b is denormalized
 814               		cmpl	d6,d5		| check for INFINITY or NaN
 815               		beq	Ladddf$nf
 816               		notl	d6		| make d6 into mask for the fraction again
 817               		andl	d6,d2		| and get fraction in d2
 818               		orl	d7,d2		| and put hidden bit back
 819               	Ladddf$2:
 820               		swap	d5		| shift right exponent so that it starts
 821               	#ifndef __mcoldfire__
 822               		lsrw	IMM (5),d5	| in bit 0 and not bit 20
 823               	#else
 824               		lsrl	IMM (5),d5	| in bit 0 and not bit 20
 825               	#endif
 826               	
 827               	| Now we have b's exponent in d5 and fraction in d2-d3. '
 828               	
 829               	| The situation now is as follows: the signs are combined in a0, the 
 830               	| numbers are in d0-d1 (a) and d2-d3 (b), and the exponents in d4 (a)
 831               	| and d5 (b). To do the rounding correctly we need to keep all the
 832               	| bits until the end, so we need to use d0-d1-d2-d3 for the first number
 833               	| and d4-d5-d6-d7 for the second. To do this we store (temporarily) the
 834               	| exponents in a2-a3.
 835               	
 836               	#ifndef __mcoldfire__
 837               		moveml	a2-a3,sp@-	| save the address registers
 838               	#else
 839               		movel	a2,sp@-	
 840               		movel	a3,sp@-	
 841               		movel	a4,sp@-	
 842               	#endif
 843               	
 844               		movel	d4,a2		| save the exponents
 845               		movel	d5,a3		| 
 846               	
 847               		movel	IMM (0),d7	| and move the numbers around
 848               		movel	d7,d6		|
 849               		movel	d3,d5		|
 850               		movel	d2,d4		|
 851               		movel	d7,d3		|
 852               		movel	d7,d2		|
 853               	
68K GAS   			page 16


 854               	| Here we shift the numbers until the exponents are the same, and put 
 855               	| the largest exponent in a2.
 856               	#ifndef __mcoldfire__
 857               		exg	d4,a2		| get exponents back
 858               		exg	d5,a3		|
 859               		cmpw	d4,d5		| compare the exponents
 860               	#else
 861               		movel	d4,a4		| get exponents back
 862               		movel	a2,d4
 863               		movel	a4,a2
 864               		movel	d5,a4
 865               		movel	a3,d5
 866               		movel	a4,a3
 867               		cmpl	d4,d5		| compare the exponents
 868               	#endif
 869               		beq	Ladddf$3	| if equal don't shift '
 870               		bhi	9f		| branch if second exponent is higher
 871               	
 872               	| Here we have a's exponent larger than b's, so we have to shift b. We do 
 873               	| this by using as counter d2:
 874               	1:	movew	d4,d2		| move largest exponent to d2
 875               	#ifndef __mcoldfire__
 876               		subw	d5,d2		| and subtract second exponent
 877               		exg	d4,a2		| get back the longs we saved
 878               		exg	d5,a3		|
 879               	#else
 880               		subl	d5,d2		| and subtract second exponent
 881               		movel	d4,a4		| get back the longs we saved
 882               		movel	a2,d4
 883               		movel	a4,a2
 884               		movel	d5,a4
 885               		movel	a3,d5
 886               		movel	a4,a3
 887               	#endif
 888               	| if difference is too large we don't shift (actually, we can just exit) '
 889               	#ifndef __mcoldfire__
 890               		cmpw	IMM (DBL_MANT_DIG+2),d2
 891               	#else
 892               		cmpl	IMM (DBL_MANT_DIG+2),d2
 893               	#endif
 894               		bge	Ladddf$b$small
 895               	#ifndef __mcoldfire__
 896               		cmpw	IMM (32),d2	| if difference >= 32, shift by longs
 897               	#else
 898               		cmpl	IMM (32),d2	| if difference >= 32, shift by longs
 899               	#endif
 900               		bge	5f
 901               	2:
 902               	#ifndef __mcoldfire__
 903               		cmpw	IMM (16),d2	| if difference >= 16, shift by words	
 904               	#else
 905               		cmpl	IMM (16),d2	| if difference >= 16, shift by words	
 906               	#endif
 907               		bge	6f
 908               		bra	3f		| enter dbra loop
 909               	
 910               	4:
68K GAS   			page 17


 911               	#ifndef __mcoldfire__
 912               		lsrl	IMM (1),d4
 913               		roxrl	IMM (1),d5
 914               		roxrl	IMM (1),d6
 915               		roxrl	IMM (1),d7
 916               	#else
 917               		lsrl	IMM (1),d7
 918               		btst	IMM (0),d6
 919               		beq	10f
 920               		bset	IMM (31),d7
 921               	10:	lsrl	IMM (1),d6
 922               		btst	IMM (0),d5
 923               		beq	11f
 924               		bset	IMM (31),d6
 925               	11:	lsrl	IMM (1),d5
 926               		btst	IMM (0),d4
 927               		beq	12f
 928               		bset	IMM (31),d5
 929               	12:	lsrl	IMM (1),d4
 930               	#endif
 931               	3:
 932               	#ifndef __mcoldfire__
 933               		dbra	d2,4b
 934               	#else
 935               		subql	IMM (1),d2
 936               		bpl	4b	
 937               	#endif
 938               		movel	IMM (0),d2
 939               		movel	d2,d3	
 940               		bra	Ladddf$4
 941               	5:
 942               		movel	d6,d7
 943               		movel	d5,d6
 944               		movel	d4,d5
 945               		movel	IMM (0),d4
 946               	#ifndef __mcoldfire__
 947               		subw	IMM (32),d2
 948               	#else
 949               		subl	IMM (32),d2
 950               	#endif
 951               		bra	2b
 952               	6:
 953               		movew	d6,d7
 954               		swap	d7
 955               		movew	d5,d6
 956               		swap	d6
 957               		movew	d4,d5
 958               		swap	d5
 959               		movew	IMM (0),d4
 960               		swap	d4
 961               	#ifndef __mcoldfire__
 962               		subw	IMM (16),d2
 963               	#else
 964               		subl	IMM (16),d2
 965               	#endif
 966               		bra	3b
 967               		
68K GAS   			page 18


 968               	9:
 969               	#ifndef __mcoldfire__
 970               		exg	d4,d5
 971               		movew	d4,d6
 972               		subw	d5,d6		| keep d5 (largest exponent) in d4
 973               		exg	d4,a2
 974               		exg	d5,a3
 975               	#else
 976               		movel	d5,d6
 977               		movel	d4,d5
 978               		movel	d6,d4
 979               		subl	d5,d6
 980               		movel	d4,a4
 981               		movel	a2,d4
 982               		movel	a4,a2
 983               		movel	d5,a4
 984               		movel	a3,d5
 985               		movel	a4,a3
 986               	#endif
 987               	| if difference is too large we don't shift (actually, we can just exit) '
 988               	#ifndef __mcoldfire__
 989               		cmpw	IMM (DBL_MANT_DIG+2),d6
 990               	#else
 991               		cmpl	IMM (DBL_MANT_DIG+2),d6
 992               	#endif
 993               		bge	Ladddf$a$small
 994               	#ifndef __mcoldfire__
 995               		cmpw	IMM (32),d6	| if difference >= 32, shift by longs
 996               	#else
 997               		cmpl	IMM (32),d6	| if difference >= 32, shift by longs
 998               	#endif
 999               		bge	5f
 1000               	2:
 1001               	#ifndef __mcoldfire__
 1002               		cmpw	IMM (16),d6	| if difference >= 16, shift by words	
 1003               	#else
 1004               		cmpl	IMM (16),d6	| if difference >= 16, shift by words	
 1005               	#endif
 1006               		bge	6f
 1007               		bra	3f		| enter dbra loop
 1008               	
 1009               	4:
 1010               	#ifndef __mcoldfire__
 1011               		lsrl	IMM (1),d0
 1012               		roxrl	IMM (1),d1
 1013               		roxrl	IMM (1),d2
 1014               		roxrl	IMM (1),d3
 1015               	#else
 1016               		lsrl	IMM (1),d3
 1017               		btst	IMM (0),d2
 1018               		beq	10f
 1019               		bset	IMM (31),d3
 1020               	10:	lsrl	IMM (1),d2
 1021               		btst	IMM (0),d1
 1022               		beq	11f
 1023               		bset	IMM (31),d2
 1024               	11:	lsrl	IMM (1),d1
68K GAS   			page 19


 1025               		btst	IMM (0),d0
 1026               		beq	12f
 1027               		bset	IMM (31),d1
 1028               	12:	lsrl	IMM (1),d0
 1029               	#endif
 1030               	3:
 1031               	#ifndef __mcoldfire__
 1032               		dbra	d6,4b
 1033               	#else
 1034               		subql	IMM (1),d6
 1035               		bpl	4b
 1036               	#endif
 1037               		movel	IMM (0),d7
 1038               		movel	d7,d6
 1039               		bra	Ladddf$4
 1040               	5:
 1041               		movel	d2,d3
 1042               		movel	d1,d2
 1043               		movel	d0,d1
 1044               		movel	IMM (0),d0
 1045               	#ifndef __mcoldfire__
 1046               		subw	IMM (32),d6
 1047               	#else
 1048               		subl	IMM (32),d6
 1049               	#endif
 1050               		bra	2b
 1051               	6:
 1052               		movew	d2,d3
 1053               		swap	d3
 1054               		movew	d1,d2
 1055               		swap	d2
 1056               		movew	d0,d1
 1057               		swap	d1
 1058               		movew	IMM (0),d0
 1059               		swap	d0
 1060               	#ifndef __mcoldfire__
 1061               		subw	IMM (16),d6
 1062               	#else
 1063               		subl	IMM (16),d6
 1064               	#endif
 1065               		bra	3b
 1066               	Ladddf$3:
 1067               	#ifndef __mcoldfire__
 1068               		exg	d4,a2	
 1069               		exg	d5,a3
 1070               	#else
 1071               		movel	d4,a4
 1072               		movel	a2,d4
 1073               		movel	a4,a2
 1074               		movel	d5,a4
 1075               		movel	a3,d5
 1076               		movel	a4,a3
 1077               	#endif
 1078               	Ladddf$4:	
 1079               	| Now we have the numbers in d0--d3 and d4--d7, the exponent in a2, and
 1080               	| the signs in a4.
 1081               	
68K GAS   			page 20


 1082               	| Here we have to decide whether to add or subtract the numbers:
 1083               	#ifndef __mcoldfire__
 1084               		exg	d7,a0		| get the signs 
 1085               		exg	d6,a3		| a3 is free to be used
 1086               	#else
 1087               		movel	d7,a4
 1088               		movel	a0,d7
 1089               		movel	a4,a0
 1090               		movel	d6,a4
 1091               		movel	a3,d6
 1092               		movel	a4,a3
 1093               	#endif
 1094               		movel	d7,d6		|
 1095               		movew	IMM (0),d7	| get a's sign in d7 '
 1096               		swap	d6              |
 1097               		movew	IMM (0),d6	| and b's sign in d6 '
 1098               		eorl	d7,d6		| compare the signs
 1099               		bmi	Lsubdf$0	| if the signs are different we have 
 1100               					| to subtract
 1101               	#ifndef __mcoldfire__
 1102               		exg	d7,a0		| else we add the numbers
 1103               		exg	d6,a3		|
 1104               	#else
 1105               		movel	d7,a4
 1106               		movel	a0,d7
 1107               		movel	a4,a0
 1108               		movel	d6,a4
 1109               		movel	a3,d6
 1110               		movel	a4,a3
 1111               	#endif
 1112               		addl	d7,d3		|
 1113               		addxl	d6,d2		|
 1114               		addxl	d5,d1		| 
 1115               		addxl	d4,d0           |
 1116               	
 1117               		movel	a2,d4		| return exponent to d4
 1118               		movel	a0,d7		| 
 1119               		andl	IMM (0x80000000),d7 | d7 now has the sign
 1120               	
 1121               	#ifndef __mcoldfire__
 1122               		moveml	sp@+,a2-a3	
 1123               	#else
 1124               		movel	sp@+,a4	
 1125               		movel	sp@+,a3	
 1126               		movel	sp@+,a2	
 1127               	#endif
 1128               	
 1129               	| Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider
 1130               	| the case of denormalized numbers in the rounding routine itself).
 1131               	| As in the addition (not in the subtraction!) we could have set 
 1132               	| one more bit we check this:
 1133               		btst	IMM (DBL_MANT_DIG+1),d0	
 1134               		beq	1f
 1135               	#ifndef __mcoldfire__
 1136               		lsrl	IMM (1),d0
 1137               		roxrl	IMM (1),d1
 1138               		roxrl	IMM (1),d2
68K GAS   			page 21


 1139               		roxrl	IMM (1),d3
 1140               		addw	IMM (1),d4
 1141               	#else
 1142               		lsrl	IMM (1),d3
 1143               		btst	IMM (0),d2
 1144               		beq	10f
 1145               		bset	IMM (31),d3
 1146               	10:	lsrl	IMM (1),d2
 1147               		btst	IMM (0),d1
 1148               		beq	11f
 1149               		bset	IMM (31),d2
 1150               	11:	lsrl	IMM (1),d1
 1151               		btst	IMM (0),d0
 1152               		beq	12f
 1153               		bset	IMM (31),d1
 1154               	12:	lsrl	IMM (1),d0
 1155               		addl	IMM (1),d4
 1156               	#endif
 1157               	1:
 1158               		lea	pc@(Ladddf$5),a0 | to return from rounding routine
 1159               		PICLEA	SYM (_fpCCR),a1	| check the rounding mode
 1160               	#ifdef __mcoldfire__
 1161               		clrl	d6
 1162               	#endif
 1163               		movew	a1@(6),d6	| rounding mode in d6
 1164               		beq	Lround$to$nearest
 1165               	#ifndef __mcoldfire__
 1166               		cmpw	IMM (ROUND_TO_PLUS),d6
 1167               	#else
 1168               		cmpl	IMM (ROUND_TO_PLUS),d6
 1169               	#endif
 1170               		bhi	Lround$to$minus
 1171               		blt	Lround$to$zero
 1172               		bra	Lround$to$plus
 1173               	Ladddf$5:
 1174               	| Put back the exponent and check for overflow
 1175               	#ifndef __mcoldfire__
 1176               		cmpw	IMM (0x7ff),d4	| is the exponent big?
 1177               	#else
 1178               		cmpl	IMM (0x7ff),d4	| is the exponent big?
 1179               	#endif
 1180               		bge	1f
 1181               		bclr	IMM (DBL_MANT_DIG-1),d0
 1182               	#ifndef __mcoldfire__
 1183               		lslw	IMM (4),d4	| put exponent back into position
 1184               	#else
 1185               		lsll	IMM (4),d4	| put exponent back into position
 1186               	#endif
 1187               		swap	d0		| 
 1188               	#ifndef __mcoldfire__
 1189               		orw	d4,d0		|
 1190               	#else
 1191               		orl	d4,d0		|
 1192               	#endif
 1193               		swap	d0		|
 1194               		bra	Ladddf$ret
 1195               	1:
68K GAS   			page 22


 1196               		moveq	IMM (ADD),d5
 1197               		bra	Ld$overflow
 1198               	
 1199               	Lsubdf$0:
 1200               	| Here we do the subtraction.
 1201               	#ifndef __mcoldfire__
 1202               		exg	d7,a0		| put sign back in a0
 1203               		exg	d6,a3		|
 1204               	#else
 1205               		movel	d7,a4
 1206               		movel	a0,d7
 1207               		movel	a4,a0
 1208               		movel	d6,a4
 1209               		movel	a3,d6
 1210               		movel	a4,a3
 1211               	#endif
 1212               		subl	d7,d3		|
 1213               		subxl	d6,d2		|
 1214               		subxl	d5,d1		|
 1215               		subxl	d4,d0		|
 1216               		beq	Ladddf$ret$1	| if zero just exit
 1217               		bpl	1f		| if positive skip the following
 1218               		movel	a0,d7		|
 1219               		bchg	IMM (31),d7	| change sign bit in d7
 1220               		movel	d7,a0		|
 1221               		negl	d3		|
 1222               		negxl	d2		|
 1223               		negxl	d1              | and negate result
 1224               		negxl	d0              |
 1225               	1:	
 1226               		movel	a2,d4		| return exponent to d4
 1227               		movel	a0,d7
 1228               		andl	IMM (0x80000000),d7 | isolate sign bit
 1229               	#ifndef __mcoldfire__
 1230               		moveml	sp@+,a2-a3	|
 1231               	#else
 1232               		movel	sp@+,a4
 1233               		movel	sp@+,a3
 1234               		movel	sp@+,a2
 1235               	#endif
 1236               	
 1237               	| Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider
 1238               	| the case of denormalized numbers in the rounding routine itself).
 1239               	| As in the addition (not in the subtraction!) we could have set 
 1240               	| one more bit we check this:
 1241               		btst	IMM (DBL_MANT_DIG+1),d0	
 1242               		beq	1f
 1243               	#ifndef __mcoldfire__
 1244               		lsrl	IMM (1),d0
 1245               		roxrl	IMM (1),d1
 1246               		roxrl	IMM (1),d2
 1247               		roxrl	IMM (1),d3
 1248               		addw	IMM (1),d4
 1249               	#else
 1250               		lsrl	IMM (1),d3
 1251               		btst	IMM (0),d2
 1252               		beq	10f
68K GAS   			page 23


 1253               		bset	IMM (31),d3
 1254               	10:	lsrl	IMM (1),d2
 1255               		btst	IMM (0),d1
 1256               		beq	11f
 1257               		bset	IMM (31),d2
 1258               	11:	lsrl	IMM (1),d1
 1259               		btst	IMM (0),d0
 1260               		beq	12f
 1261               		bset	IMM (31),d1
 1262               	12:	lsrl	IMM (1),d0
 1263               		addl	IMM (1),d4
 1264               	#endif
 1265               	1:
 1266               		lea	pc@(Lsubdf$1),a0 | to return from rounding routine
 1267               		PICLEA	SYM (_fpCCR),a1	| check the rounding mode
 1268               	#ifdef __mcoldfire__
 1269               		clrl	d6
 1270               	#endif
 1271               		movew	a1@(6),d6	| rounding mode in d6
 1272               		beq	Lround$to$nearest
 1273               	#ifndef __mcoldfire__
 1274               		cmpw	IMM (ROUND_TO_PLUS),d6
 1275               	#else
 1276               		cmpl	IMM (ROUND_TO_PLUS),d6
 1277               	#endif
 1278               		bhi	Lround$to$minus
 1279               		blt	Lround$to$zero
 1280               		bra	Lround$to$plus
 1281               	Lsubdf$1:
 1282               	| Put back the exponent and sign (we don't have overflow). '
 1283               		bclr	IMM (DBL_MANT_DIG-1),d0	
 1284               	#ifndef __mcoldfire__
 1285               		lslw	IMM (4),d4	| put exponent back into position
 1286               	#else
 1287               		lsll	IMM (4),d4	| put exponent back into position
 1288               	#endif
 1289               		swap	d0		| 
 1290               	#ifndef __mcoldfire__
 1291               		orw	d4,d0		|
 1292               	#else
 1293               		orl	d4,d0		|
 1294               	#endif
 1295               		swap	d0		|
 1296               		bra	Ladddf$ret
 1297               	
 1298               	| If one of the numbers was too small (difference of exponents >= 
 1299               	| DBL_MANT_DIG+1) we return the other (and now we don't have to '
 1300               	| check for finiteness or zero).
 1301               	Ladddf$a$small:
 1302               	#ifndef __mcoldfire__
 1303               		moveml	sp@+,a2-a3	
 1304               	#else
 1305               		movel	sp@+,a4
 1306               		movel	sp@+,a3
 1307               		movel	sp@+,a2
 1308               	#endif
 1309               		movel	a6@(16),d0
68K GAS   			page 24


 1310               		movel	a6@(20),d1
 1311               		PICLEA	SYM (_fpCCR),a0
 1312               		movew	IMM (0),a0@
 1313               	#ifndef __mcoldfire__
 1314               		moveml	sp@+,d2-d7	| restore data registers
 1315               	#else
 1316               		moveml	sp@,d2-d7
 1317               		| XXX if frame pointer is ever removed, stack pointer must
 1318               		| be adjusted here.
 1319               	#endif
 1320               		unlk	a6		| and return
 1321               		rts
 1322               	
 1323               	Ladddf$b$small:
 1324               	#ifndef __mcoldfire__
 1325               		moveml	sp@+,a2-a3	
 1326               	#else
 1327               		movel	sp@+,a4	
 1328               		movel	sp@+,a3	
 1329               		movel	sp@+,a2	
 1330               	#endif
 1331               		movel	a6@(8),d0
 1332               		movel	a6@(12),d1
 1333               		PICLEA	SYM (_fpCCR),a0
 1334               		movew	IMM (0),a0@
 1335               	#ifndef __mcoldfire__
 1336               		moveml	sp@+,d2-d7	| restore data registers
 1337               	#else
 1338               		moveml	sp@,d2-d7
 1339               		| XXX if frame pointer is ever removed, stack pointer must
 1340               		| be adjusted here.
 1341               	#endif
 1342               		unlk	a6		| and return
 1343               		rts
 1344               	
 1345               	Ladddf$a$den:
 1346               		movel	d7,d4		| d7 contains 0x00200000
 1347               		bra	Ladddf$1
 1348               	
 1349               	Ladddf$b$den:
 1350               		movel	d7,d5           | d7 contains 0x00200000
 1351               		notl	d6
 1352               		bra	Ladddf$2
 1353               	
 1354               	Ladddf$b:
 1355               	| Return b (if a is zero)
 1356               		movel	d2,d0
 1357               		movel	d3,d1
 1358               		bne	1f			| Check if b is -0
 1359               		cmpl	IMM (0x80000000),d0
 1360               		bne	1f
 1361               		andl	IMM (0x80000000),d7	| Use the sign of a
 1362               		clrl	d0
 1363               		bra	Ladddf$ret
 1364               	Ladddf$a:
 1365               		movel	a6@(8),d0
 1366               		movel	a6@(12),d1
68K GAS   			page 25


 1367               	1:
 1368               		moveq	IMM (ADD),d5
 1369               	| Check for NaN and +/-INFINITY.
 1370               		movel	d0,d7         		|
 1371               		andl	IMM (0x80000000),d7	|
 1372               		bclr	IMM (31),d0		|
 1373               		cmpl	IMM (0x7ff00000),d0	|
 1374               		bge	2f			|
 1375               		movel	d0,d0           	| check for zero, since we don't  '
 1376               		bne	Ladddf$ret		| want to return -0 by mistake
 1377               		bclr	IMM (31),d7		|
 1378               		bra	Ladddf$ret		|
 1379               	2:
 1380               		andl	IMM (0x000fffff),d0	| check for NaN (nonzero fraction)
 1381               		orl	d1,d0			|
 1382               		bne	Ld$inop         	|
 1383               		bra	Ld$infty		|
 1384               		
 1385               	Ladddf$ret$1:
 1386               	#ifndef __mcoldfire__
 1387               		moveml	sp@+,a2-a3	| restore regs and exit
 1388               	#else
 1389               		movel	sp@+,a4
 1390               		movel	sp@+,a3
 1391               		movel	sp@+,a2
 1392               	#endif
 1393               	
 1394               	Ladddf$ret:
 1395               	| Normal exit.
 1396               		PICLEA	SYM (_fpCCR),a0
 1397               		movew	IMM (0),a0@
 1398               		orl	d7,d0		| put sign bit back
 1399               	#ifndef __mcoldfire__
 1400               		moveml	sp@+,d2-d7
 1401               	#else
 1402               		moveml	sp@,d2-d7
 1403               		| XXX if frame pointer is ever removed, stack pointer must
 1404               		| be adjusted here.
 1405               	#endif
 1406               		unlk	a6
 1407               		rts
 1408               	
 1409               	Ladddf$ret$den:
 1410               	| Return a denormalized number.
 1411               	#ifndef __mcoldfire__
 1412               		lsrl	IMM (1),d0	| shift right once more
 1413               		roxrl	IMM (1),d1	|
 1414               	#else
 1415               		lsrl	IMM (1),d1
 1416               		btst	IMM (0),d0
 1417               		beq	10f
 1418               		bset	IMM (31),d1
 1419               	10:	lsrl	IMM (1),d0
 1420               	#endif
 1421               		bra	Ladddf$ret
 1422               	
 1423               	Ladddf$nf:
68K GAS   			page 26


 1424               		moveq	IMM (ADD),d5
 1425               	| This could be faster but it is not worth the effort, since it is not
 1426               	| executed very often. We sacrifice speed for clarity here.
 1427               		movel	a6@(8),d0	| get the numbers back (remember that we
 1428               		movel	a6@(12),d1	| did some processing already)
 1429               		movel	a6@(16),d2	| 
 1430               		movel	a6@(20),d3	| 
 1431               		movel	IMM (0x7ff00000),d4 | useful constant (INFINITY)
 1432               		movel	d0,d7		| save sign bits
 1433               		movel	d2,d6		| 
 1434               		bclr	IMM (31),d0	| clear sign bits
 1435               		bclr	IMM (31),d2	| 
 1436               	| We know that one of them is either NaN of +/-INFINITY
 1437               	| Check for NaN (if either one is NaN return NaN)
 1438               		cmpl	d4,d0		| check first a (d0)
 1439               		bhi	Ld$inop		| if d0 > 0x7ff00000 or equal and
 1440               		bne	2f
 1441               		tstl	d1		| d1 > 0, a is NaN
 1442               		bne	Ld$inop		| 
 1443               	2:	cmpl	d4,d2		| check now b (d1)
 1444               		bhi	Ld$inop		| 
 1445               		bne	3f
 1446               		tstl	d3		| 
 1447               		bne	Ld$inop		| 
 1448               	3:
 1449               	| Now comes the check for +/-INFINITY. We know that both are (maybe not
 1450               	| finite) numbers, but we have to check if both are infinite whether we
 1451               	| are adding or subtracting them.
 1452               		eorl	d7,d6		| to check sign bits
 1453               		bmi	1f
 1454               		andl	IMM (0x80000000),d7 | get (common) sign bit
 1455               		bra	Ld$infty
 1456               	1:
 1457               	| We know one (or both) are infinite, so we test for equality between the
 1458               	| two numbers (if they are equal they have to be infinite both, so we
 1459               	| return NaN).
 1460               		cmpl	d2,d0		| are both infinite?
 1461               		bne	1f		| if d0 <> d2 they are not equal
 1462               		cmpl	d3,d1		| if d0 == d2 test d3 and d1
 1463               		beq	Ld$inop		| if equal return NaN
 1464               	1:	
 1465               		andl	IMM (0x80000000),d7 | get a's sign bit '
 1466               		cmpl	d4,d0		| test now for infinity
 1467               		beq	Ld$infty	| if a is INFINITY return with this sign
 1468               		bchg	IMM (31),d7	| else we know b is INFINITY and has
 1469               		bra	Ld$infty	| the opposite sign
 1470               	
 1471               	|=============================================================================
 1472               	|                              __muldf3
 1473               	|=============================================================================
 1474               	
 1475               	| double __muldf3(double, double);
 1476               		FUNC(__muldf3)
 1477               	SYM (__muldf3):
 1478               	#ifndef __mcoldfire__
 1479               		link	a6,IMM (0)
 1480               		moveml	d2-d7,sp@-
68K GAS   			page 27


 1481               	#else
 1482               		link	a6,IMM (-24)
 1483               		moveml	d2-d7,sp@
 1484               	#endif
 1485               		movel	a6@(8),d0		| get a into d0-d1
 1486               		movel	a6@(12),d1		| 
 1487               		movel	a6@(16),d2		| and b into d2-d3
 1488               		movel	a6@(20),d3		|
 1489               		movel	d0,d7			| d7 will hold the sign of the product
 1490               		eorl	d2,d7			|
 1491               		andl	IMM (0x80000000),d7	|
 1492               		movel	d7,a0			| save sign bit into a0 
 1493               		movel	IMM (0x7ff00000),d7	| useful constant (+INFINITY)
 1494               		movel	d7,d6			| another (mask for fraction)
 1495               		notl	d6			|
 1496               		bclr	IMM (31),d0		| get rid of a's sign bit '
 1497               		movel	d0,d4			| 
 1498               		orl	d1,d4			| 
 1499               		beq	Lmuldf$a$0		| branch if a is zero
 1500               		movel	d0,d4			|
 1501               		bclr	IMM (31),d2		| get rid of b's sign bit '
 1502               		movel	d2,d5			|
 1503               		orl	d3,d5			| 
 1504               		beq	Lmuldf$b$0		| branch if b is zero
 1505               		movel	d2,d5			| 
 1506               		cmpl	d7,d0			| is a big?
 1507               		bhi	Lmuldf$inop		| if a is NaN return NaN
 1508               		beq	Lmuldf$a$nf		| we still have to check d1 and b ...
 1509               		cmpl	d7,d2			| now compare b with INFINITY
 1510               		bhi	Lmuldf$inop		| is b NaN?
 1511               		beq	Lmuldf$b$nf 		| we still have to check d3 ...
 1512               	| Here we have both numbers finite and nonzero (and with no sign bit).
 1513               	| Now we get the exponents into d4 and d5.
 1514               		andl	d7,d4			| isolate exponent in d4
 1515               		beq	Lmuldf$a$den		| if exponent zero, have denormalized
 1516               		andl	d6,d0			| isolate fraction
 1517               		orl	IMM (0x00100000),d0	| and put hidden bit back
 1518               		swap	d4			| I like exponents in the first byte
 1519               	#ifndef __mcoldfire__
 1520               		lsrw	IMM (4),d4		| 
 1521               	#else
 1522               		lsrl	IMM (4),d4		| 
 1523               	#endif
 1524               	Lmuldf$1:			
 1525               		andl	d7,d5			|
 1526               		beq	Lmuldf$b$den		|
 1527               		andl	d6,d2			|
 1528               		orl	IMM (0x00100000),d2	| and put hidden bit back
 1529               		swap	d5			|
 1530               	#ifndef __mcoldfire__
 1531               		lsrw	IMM (4),d5		|
 1532               	#else
 1533               		lsrl	IMM (4),d5		|
 1534               	#endif
 1535               	Lmuldf$2:				|
 1536               	#ifndef __mcoldfire__
 1537               		addw	d5,d4			| add exponents
68K GAS   			page 28


 1538               		subw	IMM (D_BIAS+1),d4	| and subtract bias (plus one)
 1539               	#else
 1540               		addl	d5,d4			| add exponents
 1541               		subl	IMM (D_BIAS+1),d4	| and subtract bias (plus one)
 1542               	#endif
 1543               	
 1544               	| We are now ready to do the multiplication. The situation is as follows:
 1545               	| both a and b have bit 52 ( bit 20 of d0 and d2) set (even if they were 
 1546               	| denormalized to start with!), which means that in the product bit 104 
 1547               	| (which will correspond to bit 8 of the fourth long) is set.
 1548               	
 1549               	| Here we have to do the product.
 1550               	| To do it we have to juggle the registers back and forth, as there are not
 1551               	| enough to keep everything in them. So we use the address registers to keep
 1552               	| some intermediate data.
 1553               	
 1554               	#ifndef __mcoldfire__
 1555               		moveml	a2-a3,sp@-	| save a2 and a3 for temporary use
 1556               	#else
 1557               		movel	a2,sp@-
 1558               		movel	a3,sp@-
 1559               		movel	a4,sp@-
 1560               	#endif
 1561               		movel	IMM (0),a2	| a2 is a null register
 1562               		movel	d4,a3		| and a3 will preserve the exponent
 1563               	
 1564               	| First, shift d2-d3 so bit 20 becomes bit 31:
 1565               	#ifndef __mcoldfire__
 1566               		rorl	IMM (5),d2	| rotate d2 5 places right
 1567               		swap	d2		| and swap it
 1568               		rorl	IMM (5),d3	| do the same thing with d3
 1569               		swap	d3		|
 1570               		movew	d3,d6		| get the rightmost 11 bits of d3
 1571               		andw	IMM (0x07ff),d6	|
 1572               		orw	d6,d2		| and put them into d2
 1573               		andw	IMM (0xf800),d3	| clear those bits in d3
 1574               	#else
 1575               		moveq	IMM (11),d7	| left shift d2 11 bits
 1576               		lsll	d7,d2
 1577               		movel	d3,d6		| get a copy of d3
 1578               		lsll	d7,d3		| left shift d3 11 bits
 1579               		andl	IMM (0xffe00000),d6 | get the top 11 bits of d3
 1580               		moveq	IMM (21),d7	| right shift them 21 bits
 1581               		lsrl	d7,d6
 1582               		orl	d6,d2		| stick them at the end of d2
 1583               	#endif
 1584               	
 1585               		movel	d2,d6		| move b into d6-d7
 1586               		movel	d3,d7           | move a into d4-d5
 1587               		movel	d0,d4           | and clear d0-d1-d2-d3 (to put result)
 1588               		movel	d1,d5           |
 1589               		movel	IMM (0),d3	|
 1590               		movel	d3,d2           |
 1591               		movel	d3,d1           |
 1592               		movel	d3,d0	        |
 1593               	
 1594               	| We use a1 as counter:	
68K GAS   			page 29


 1595               		movel	IMM (DBL_MANT_DIG-1),a1		
 1596               	#ifndef __mcoldfire__
 1597               		exg	d7,a1
 1598               	#else
 1599               		movel	d7,a4
 1600               		movel	a1,d7
 1601               		movel	a4,a1
 1602               	#endif
 1603               	
 1604               	1:
 1605               	#ifndef __mcoldfire__
 1606               		exg	d7,a1		| put counter back in a1
 1607               	#else
 1608               		movel	d7,a4
 1609               		movel	a1,d7
 1610               		movel	a4,a1
 1611               	#endif
 1612               		addl	d3,d3		| shift sum once left
 1613               		addxl	d2,d2           |
 1614               		addxl	d1,d1           |
 1615               		addxl	d0,d0           |
 1616               		addl	d7,d7		|
 1617               		addxl	d6,d6		|
 1618               		bcc	2f		| if bit clear skip the following
 1619               	#ifndef __mcoldfire__
 1620               		exg	d7,a2		|
 1621               	#else
 1622               		movel	d7,a4
 1623               		movel	a2,d7
 1624               		movel	a4,a2
 1625               	#endif
 1626               		addl	d5,d3		| else add a to the sum
 1627               		addxl	d4,d2		|
 1628               		addxl	d7,d1		|
 1629               		addxl	d7,d0		|
 1630               	#ifndef __mcoldfire__
 1631               		exg	d7,a2		| 
 1632               	#else
 1633               		movel	d7,a4
 1634               		movel	a2,d7
 1635               		movel	a4,a2
 1636               	#endif
 1637               	2:
 1638               	#ifndef __mcoldfire__
 1639               		exg	d7,a1		| put counter in d7
 1640               		dbf	d7,1b		| decrement and branch
 1641               	#else
 1642               		movel	d7,a4
 1643               		movel	a1,d7
 1644               		movel	a4,a1
 1645               		subql	IMM (1),d7
 1646               		bpl	1b
 1647               	#endif
 1648               	
 1649               		movel	a3,d4		| restore exponent
 1650               	#ifndef __mcoldfire__
 1651               		moveml	sp@+,a2-a3
68K GAS   			page 30


 1652               	#else
 1653               		movel	sp@+,a4
 1654               		movel	sp@+,a3
 1655               		movel	sp@+,a2
 1656               	#endif
 1657               	
 1658               	| Now we have the product in d0-d1-d2-d3, with bit 8 of d0 set. The 
 1659               	| first thing to do now is to normalize it so bit 8 becomes bit 
 1660               	| DBL_MANT_DIG-32 (to do the rounding); later we will shift right.
 1661               		swap	d0
 1662               		swap	d1
 1663               		movew	d1,d0
 1664               		swap	d2
 1665               		movew	d2,d1
 1666               		swap	d3
 1667               		movew	d3,d2
 1668               		movew	IMM (0),d3
 1669               	#ifndef __mcoldfire__
 1670               		lsrl	IMM (1),d0
 1671               		roxrl	IMM (1),d1
 1672               		roxrl	IMM (1),d2
 1673               		roxrl	IMM (1),d3
 1674               		lsrl	IMM (1),d0
 1675               		roxrl	IMM (1),d1
 1676               		roxrl	IMM (1),d2
 1677               		roxrl	IMM (1),d3
 1678               		lsrl	IMM (1),d0
 1679               		roxrl	IMM (1),d1
 1680               		roxrl	IMM (1),d2
 1681               		roxrl	IMM (1),d3
 1682               	#else
 1683               		moveq	IMM (29),d6
 1684               		lsrl	IMM (3),d3
 1685               		movel	d2,d7
 1686               		lsll	d6,d7
 1687               		orl	d7,d3
 1688               		lsrl	IMM (3),d2
 1689               		movel	d1,d7
 1690               		lsll	d6,d7
 1691               		orl	d7,d2
 1692               		lsrl	IMM (3),d1
 1693               		movel	d0,d7
 1694               		lsll	d6,d7
 1695               		orl	d7,d1
 1696               		lsrl	IMM (3),d0
 1697               	#endif
 1698               		
 1699               	| Now round, check for over- and underflow, and exit.
 1700               		movel	a0,d7		| get sign bit back into d7
 1701               		moveq	IMM (MULTIPLY),d5
 1702               	
 1703               		btst	IMM (DBL_MANT_DIG+1-32),d0
 1704               		beq	Lround$exit
 1705               	#ifndef __mcoldfire__
 1706               		lsrl	IMM (1),d0
 1707               		roxrl	IMM (1),d1
 1708               		addw	IMM (1),d4
68K GAS   			page 31


 1709               	#else
 1710               		lsrl	IMM (1),d1
 1711               		btst	IMM (0),d0
 1712               		beq	10f
 1713               		bset	IMM (31),d1
 1714               	10:	lsrl	IMM (1),d0
 1715               		addl	IMM (1),d4
 1716               	#endif
 1717               		bra	Lround$exit
 1718               	
 1719               	Lmuldf$inop:
 1720               		moveq	IMM (MULTIPLY),d5
 1721               		bra	Ld$inop
 1722               	
 1723               	Lmuldf$b$nf:
 1724               		moveq	IMM (MULTIPLY),d5
 1725               		movel	a0,d7		| get sign bit back into d7
 1726               		tstl	d3		| we know d2 == 0x7ff00000, so check d3
 1727               		bne	Ld$inop		| if d3 <> 0 b is NaN
 1728               		bra	Ld$overflow	| else we have overflow (since a is finite)
 1729               	
 1730               	Lmuldf$a$nf:
 1731               		moveq	IMM (MULTIPLY),d5
 1732               		movel	a0,d7		| get sign bit back into d7
 1733               		tstl	d1		| we know d0 == 0x7ff00000, so check d1
 1734               		bne	Ld$inop		| if d1 <> 0 a is NaN
 1735               		bra	Ld$overflow	| else signal overflow
 1736               	
 1737               	| If either number is zero return zero, unless the other is +/-INFINITY or
 1738               	| NaN, in which case we return NaN.
 1739               	Lmuldf$b$0:
 1740               		moveq	IMM (MULTIPLY),d5
 1741               	#ifndef __mcoldfire__
 1742               		exg	d2,d0		| put b (==0) into d0-d1
 1743               		exg	d3,d1		| and a (with sign bit cleared) into d2-d3
 1744               		movel	a0,d0		| set result sign
 1745               	#else
 1746               		movel	d0,d2		| put a into d2-d3
 1747               		movel	d1,d3
 1748               		movel	a0,d0		| put result zero into d0-d1
 1749               		movq	IMM(0),d1
 1750               	#endif
 1751               		bra	1f
 1752               	Lmuldf$a$0:
 1753               		movel	a0,d0		| set result sign
 1754               		movel	a6@(16),d2	| put b into d2-d3 again
 1755               		movel	a6@(20),d3	|
 1756               		bclr	IMM (31),d2	| clear sign bit
 1757               	1:	cmpl	IMM (0x7ff00000),d2 | check for non-finiteness
 1758               		bge	Ld$inop		| in case NaN or +/-INFINITY return NaN
 1759               		PICLEA	SYM (_fpCCR),a0
 1760               		movew	IMM (0),a0@
 1761               	#ifndef __mcoldfire__
 1762               		moveml	sp@+,d2-d7
 1763               	#else
 1764               		moveml	sp@,d2-d7
 1765               		| XXX if frame pointer is ever removed, stack pointer must
68K GAS   			page 32


 1766               		| be adjusted here.
 1767               	#endif
 1768               		unlk	a6
 1769               		rts
 1770               	
 1771               	| If a number is denormalized we put an exponent of 1 but do not put the 
 1772               	| hidden bit back into the fraction; instead we shift left until bit 21
 1773               	| (the hidden bit) is set, adjusting the exponent accordingly. We do this
 1774               	| to ensure that the product of the fractions is close to 1.
 1775               	Lmuldf$a$den:
 1776               		movel	IMM (1),d4
 1777               		andl	d6,d0
 1778               	1:	addl	d1,d1           | shift a left until bit 20 is set
 1779               		addxl	d0,d0		|
 1780               	#ifndef __mcoldfire__
 1781               		subw	IMM (1),d4	| and adjust exponent
 1782               	#else
 1783               		subl	IMM (1),d4	| and adjust exponent
 1784               	#endif
 1785               		btst	IMM (20),d0	|
 1786               		bne	Lmuldf$1        |
 1787               		bra	1b
 1788               	
 1789               	Lmuldf$b$den:
 1790               		movel	IMM (1),d5
 1791               		andl	d6,d2
 1792               	1:	addl	d3,d3		| shift b left until bit 20 is set
 1793               		addxl	d2,d2		|
 1794               	#ifndef __mcoldfire__
 1795               		subw	IMM (1),d5	| and adjust exponent
 1796               	#else
 1797               		subql	IMM (1),d5	| and adjust exponent
 1798               	#endif
 1799               		btst	IMM (20),d2	|
 1800               		bne	Lmuldf$2	|
 1801               		bra	1b
 1802               	
 1803               	
 1804               	|=============================================================================
 1805               	|                              __divdf3
 1806               	|=============================================================================
 1807               	
 1808               	| double __divdf3(double, double);
 1809               		FUNC(__divdf3)
 1810               	SYM (__divdf3):
 1811               	#ifndef __mcoldfire__
 1812               		link	a6,IMM (0)
 1813               		moveml	d2-d7,sp@-
 1814               	#else
 1815               		link	a6,IMM (-24)
 1816               		moveml	d2-d7,sp@
 1817               	#endif
 1818               		movel	a6@(8),d0	| get a into d0-d1
 1819               		movel	a6@(12),d1	| 
 1820               		movel	a6@(16),d2	| and b into d2-d3
 1821               		movel	a6@(20),d3	|
 1822               		movel	d0,d7		| d7 will hold the sign of the result
68K GAS   			page 33


 1823               		eorl	d2,d7		|
 1824               		andl	IMM (0x80000000),d7
 1825               		movel	d7,a0		| save sign into a0
 1826               		movel	IMM (0x7ff00000),d7 | useful constant (+INFINITY)
 1827               		movel	d7,d6		| another (mask for fraction)
 1828               		notl	d6		|
 1829               		bclr	IMM (31),d0	| get rid of a's sign bit '
 1830               		movel	d0,d4		|
 1831               		orl	d1,d4		|
 1832               		beq	Ldivdf$a$0	| branch if a is zero
 1833               		movel	d0,d4		|
 1834               		bclr	IMM (31),d2	| get rid of b's sign bit '
 1835               		movel	d2,d5		|
 1836               		orl	d3,d5		|
 1837               		beq	Ldivdf$b$0	| branch if b is zero
 1838               		movel	d2,d5
 1839               		cmpl	d7,d0		| is a big?
 1840               		bhi	Ldivdf$inop	| if a is NaN return NaN
 1841               		beq	Ldivdf$a$nf	| if d0 == 0x7ff00000 we check d1
 1842               		cmpl	d7,d2		| now compare b with INFINITY 
 1843               		bhi	Ldivdf$inop	| if b is NaN return NaN
 1844               		beq	Ldivdf$b$nf	| if d2 == 0x7ff00000 we check d3
 1845               	| Here we have both numbers finite and nonzero (and with no sign bit).
 1846               	| Now we get the exponents into d4 and d5 and normalize the numbers to
 1847               	| ensure that the ratio of the fractions is around 1. We do this by
 1848               	| making sure that both numbers have bit #DBL_MANT_DIG-32-1 (hidden bit)
 1849               	| set, even if they were denormalized to start with.
 1850               	| Thus, the result will satisfy: 2 > result > 1/2.
 1851               		andl	d7,d4		| and isolate exponent in d4
 1852               		beq	Ldivdf$a$den	| if exponent is zero we have a denormalized
 1853               		andl	d6,d0		| and isolate fraction
 1854               		orl	IMM (0x00100000),d0 | and put hidden bit back
 1855               		swap	d4		| I like exponents in the first byte
 1856               	#ifndef __mcoldfire__
 1857               		lsrw	IMM (4),d4	| 
 1858               	#else
 1859               		lsrl	IMM (4),d4	| 
 1860               	#endif
 1861               	Ldivdf$1:			| 
 1862               		andl	d7,d5		|
 1863               		beq	Ldivdf$b$den	|
 1864               		andl	d6,d2		|
 1865               		orl	IMM (0x00100000),d2
 1866               		swap	d5		|
 1867               	#ifndef __mcoldfire__
 1868               		lsrw	IMM (4),d5	|
 1869               	#else
 1870               		lsrl	IMM (4),d5	|
 1871               	#endif
 1872               	Ldivdf$2:			|
 1873               	#ifndef __mcoldfire__
 1874               		subw	d5,d4		| subtract exponents
 1875               		addw	IMM (D_BIAS),d4	| and add bias
 1876               	#else
 1877               		subl	d5,d4		| subtract exponents
 1878               		addl	IMM (D_BIAS),d4	| and add bias
 1879               	#endif
68K GAS   			page 34


 1880               	
 1881               	| We are now ready to do the division. We have prepared things in such a way
 1882               	| that the ratio of the fractions will be less than 2 but greater than 1/2.
 1883               	| At this point the registers in use are:
 1884               	| d0-d1	hold a (first operand, bit DBL_MANT_DIG-32=0, bit 
 1885               	| DBL_MANT_DIG-1-32=1)
 1886               	| d2-d3	hold b (second operand, bit DBL_MANT_DIG-32=1)
 1887               	| d4	holds the difference of the exponents, corrected by the bias
 1888               	| a0	holds the sign of the ratio
 1889               	
 1890               	| To do the rounding correctly we need to keep information about the
 1891               	| nonsignificant bits. One way to do this would be to do the division
 1892               	| using four registers; another is to use two registers (as originally
 1893               	| I did), but use a sticky bit to preserve information about the 
 1894               	| fractional part. Note that we can keep that info in a1, which is not
 1895               	| used.
 1896               		movel	IMM (0),d6	| d6-d7 will hold the result
 1897               		movel	d6,d7		| 
 1898               		movel	IMM (0),a1	| and a1 will hold the sticky bit
 1899               	
 1900               		movel	IMM (DBL_MANT_DIG-32+1),d5	
 1901               		
 1902               	1:	cmpl	d0,d2		| is a < b?
 1903               		bhi	3f		| if b > a skip the following
 1904               		beq	4f		| if d0==d2 check d1 and d3
 1905               	2:	subl	d3,d1		| 
 1906               		subxl	d2,d0		| a <-- a - b
 1907               		bset	d5,d6		| set the corresponding bit in d6
 1908               	3:	addl	d1,d1		| shift a by 1
 1909               		addxl	d0,d0		|
 1910               	#ifndef __mcoldfire__
 1911               		dbra	d5,1b		| and branch back
 1912               	#else
 1913               		subql	IMM (1), d5
 1914               		bpl	1b
 1915               	#endif
 1916               		bra	5f			
 1917               	4:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
 1918               		bhi	3b		| if d1 > d2 skip the subtraction
 1919               		bra	2b		| else go do it
 1920               	5:
 1921               	| Here we have to start setting the bits in the second long.
 1922               		movel	IMM (31),d5	| again d5 is counter
 1923               	
 1924               	1:	cmpl	d0,d2		| is a < b?
 1925               		bhi	3f		| if b > a skip the following
 1926               		beq	4f		| if d0==d2 check d1 and d3
 1927               	2:	subl	d3,d1		| 
 1928               		subxl	d2,d0		| a <-- a - b
 1929               		bset	d5,d7		| set the corresponding bit in d7
 1930               	3:	addl	d1,d1		| shift a by 1
 1931               		addxl	d0,d0		|
 1932               	#ifndef __mcoldfire__
 1933               		dbra	d5,1b		| and branch back
 1934               	#else
 1935               		subql	IMM (1), d5
 1936               		bpl	1b
68K GAS   			page 35


 1937               	#endif
 1938               		bra	5f			
 1939               	4:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
 1940               		bhi	3b		| if d1 > d2 skip the subtraction
 1941               		bra	2b		| else go do it
 1942               	5:
 1943               	| Now go ahead checking until we hit a one, which we store in d2.
 1944               		movel	IMM (DBL_MANT_DIG),d5
 1945               	1:	cmpl	d2,d0		| is a < b?
 1946               		bhi	4f		| if b < a, exit
 1947               		beq	3f		| if d0==d2 check d1 and d3
 1948               	2:	addl	d1,d1		| shift a by 1
 1949               		addxl	d0,d0		|
 1950               	#ifndef __mcoldfire__
 1951               		dbra	d5,1b		| and branch back
 1952               	#else
 1953               		subql	IMM (1), d5
 1954               		bpl	1b
 1955               	#endif
 1956               		movel	IMM (0),d2	| here no sticky bit was found
 1957               		movel	d2,d3
 1958               		bra	5f			
 1959               	3:	cmpl	d1,d3		| here d0==d2, so check d1 and d3
 1960               		bhi	2b		| if d1 > d2 go back
 1961               	4:
 1962               	| Here put the sticky bit in d2-d3 (in the position which actually corresponds
 1963               	| to it; if you don't do this the algorithm loses in some cases). '
 1964               		movel	IMM (0),d2
 1965               		movel	d2,d3
 1966               	#ifndef __mcoldfire__
 1967               		subw	IMM (DBL_MANT_DIG),d5
 1968               		addw	IMM (63),d5
 1969               		cmpw	IMM (31),d5
 1970               	#else
 1971               		subl	IMM (DBL_MANT_DIG),d5
 1972               		addl	IMM (63),d5
 1973               		cmpl	IMM (31),d5
 1974               	#endif
 1975               		bhi	2f
 1976               	1:	bset	d5,d3
 1977               		bra	5f
 1978               	#ifndef __mcoldfire__
 1979               		subw	IMM (32),d5
 1980               	#else
 1981               		subl	IMM (32),d5
 1982               	#endif
 1983               	2:	bset	d5,d2
 1984               	5:
 1985               	| Finally we are finished! Move the longs in the address registers to
 1986               	| their final destination:
 1987               		movel	d6,d0
 1988               		movel	d7,d1
 1989               		movel	IMM (0),d3
 1990               	
 1991               	| Here we have finished the division, with the result in d0-d1-d2-d3, with
 1992               	| 2^21 <= d6 < 2^23. Thus bit 23 is not set, but bit 22 could be set.
 1993               	| If it is not, then definitely bit 21 is set. Normalize so bit 22 is
68K GAS   			page 36


 1994               	| not set:
 1995               		btst	IMM (DBL_MANT_DIG-32+1),d0
 1996               		beq	1f
 1997               	#ifndef __mcoldfire__
 1998               		lsrl	IMM (1),d0
 1999               		roxrl	IMM (1),d1
 2000               		roxrl	IMM (1),d2
 2001               		roxrl	IMM (1),d3
 2002               		addw	IMM (1),d4
 2003               	#else
 2004               		lsrl	IMM (1),d3
 2005               		btst	IMM (0),d2
 2006               		beq	10f
 2007               		bset	IMM (31),d3
 2008               	10:	lsrl	IMM (1),d2
 2009               		btst	IMM (0),d1
 2010               		beq	11f
 2011               		bset	IMM (31),d2
 2012               	11:	lsrl	IMM (1),d1
 2013               		btst	IMM (0),d0
 2014               		beq	12f
 2015               		bset	IMM (31),d1
 2016               	12:	lsrl	IMM (1),d0
 2017               		addl	IMM (1),d4
 2018               	#endif
 2019               	1:
 2020               	| Now round, check for over- and underflow, and exit.
 2021               		movel	a0,d7		| restore sign bit to d7
 2022               		moveq	IMM (DIVIDE),d5
 2023               		bra	Lround$exit
 2024               	
 2025               	Ldivdf$inop:
 2026               		moveq	IMM (DIVIDE),d5
 2027               		bra	Ld$inop
 2028               	
 2029               	Ldivdf$a$0:
 2030               	| If a is zero check to see whether b is zero also. In that case return
 2031               	| NaN; then check if b is NaN, and return NaN also in that case. Else
 2032               	| return a properly signed zero.
 2033               		moveq	IMM (DIVIDE),d5
 2034               		bclr	IMM (31),d2	|
 2035               		movel	d2,d4		| 
 2036               		orl	d3,d4		| 
 2037               		beq	Ld$inop		| if b is also zero return NaN
 2038               		cmpl	IMM (0x7ff00000),d2 | check for NaN
 2039               		bhi	Ld$inop		| 
 2040               		blt	1f		|
 2041               		tstl	d3		|
 2042               		bne	Ld$inop		|
 2043               	1:	movel	a0,d0		| else return signed zero
 2044               		moveq	IMM(0),d1	| 
 2045               		PICLEA	SYM (_fpCCR),a0	| clear exception flags
 2046               		movew	IMM (0),a0@	|
 2047               	#ifndef __mcoldfire__
 2048               		moveml	sp@+,d2-d7	| 
 2049               	#else
 2050               		moveml	sp@,d2-d7	| 
68K GAS   			page 37


 2051               		| XXX if frame pointer is ever removed, stack pointer must
 2052               		| be adjusted here.
 2053               	#endif
 2054               		unlk	a6		| 
 2055               		rts			| 	
 2056               	
 2057               	Ldivdf$b$0:
 2058               		moveq	IMM (DIVIDE),d5
 2059               	| If we got here a is not zero. Check if a is NaN; in that case return NaN,
 2060               	| else return +/-INFINITY. Remember that a is in d0 with the sign bit 
 2061               	| cleared already.
 2062               		movel	a0,d7		| put a's sign bit back in d7 '
 2063               		cmpl	IMM (0x7ff00000),d0 | compare d0 with INFINITY
 2064               		bhi	Ld$inop		| if larger it is NaN
 2065               		tstl	d1		| 
 2066               		bne	Ld$inop		| 
 2067               		bra	Ld$div$0	| else signal DIVIDE_BY_ZERO
 2068               	
 2069               	Ldivdf$b$nf:
 2070               		moveq	IMM (DIVIDE),d5
 2071               	| If d2 == 0x7ff00000 we have to check d3.
 2072               		tstl	d3		|
 2073               		bne	Ld$inop		| if d3 <> 0, b is NaN
 2074               		bra	Ld$underflow	| else b is +/-INFINITY, so signal underflow
 2075               	
 2076               	Ldivdf$a$nf:
 2077               		moveq	IMM (DIVIDE),d5
 2078               	| If d0 == 0x7ff00000 we have to check d1.
 2079               		tstl	d1		|
 2080               		bne	Ld$inop		| if d1 <> 0, a is NaN
 2081               	| If a is INFINITY we have to check b
 2082               		cmpl	d7,d2		| compare b with INFINITY 
 2083               		bge	Ld$inop		| if b is NaN or INFINITY return NaN
 2084               		tstl	d3		|
 2085               		bne	Ld$inop		| 
 2086               		bra	Ld$overflow	| else return overflow
 2087               	
 2088               	| If a number is denormalized we put an exponent of 1 but do not put the 
 2089               	| bit back into the fraction.
 2090               	Ldivdf$a$den:
 2091               		movel	IMM (1),d4
 2092               		andl	d6,d0
 2093               	1:	addl	d1,d1		| shift a left until bit 20 is set
 2094               		addxl	d0,d0
 2095               	#ifndef __mcoldfire__
 2096               		subw	IMM (1),d4	| and adjust exponent
 2097               	#else
 2098               		subl	IMM (1),d4	| and adjust exponent
 2099               	#endif
 2100               		btst	IMM (DBL_MANT_DIG-32-1),d0
 2101               		bne	Ldivdf$1
 2102               		bra	1b
 2103               	
 2104               	Ldivdf$b$den:
 2105               		movel	IMM (1),d5
 2106               		andl	d6,d2
 2107               	1:	addl	d3,d3		| shift b left until bit 20 is set
68K GAS   			page 38


 2108               		addxl	d2,d2
 2109               	#ifndef __mcoldfire__
 2110               		subw	IMM (1),d5	| and adjust exponent
 2111               	#else
 2112               		subql	IMM (1),d5	| and adjust exponent
 2113               	#endif
 2114               		btst	IMM (DBL_MANT_DIG-32-1),d2
 2115               		bne	Ldivdf$2
 2116               		bra	1b
 2117               	
 2118               	Lround$exit:
 2119               	| This is a common exit point for __muldf3 and __divdf3. When they enter
 2120               	| this point the sign of the result is in d7, the result in d0-d1, normalized
 2121               	| so that 2^21 <= d0 < 2^22, and the exponent is in the lower byte of d4.
 2122               	
 2123               	| First check for underlow in the exponent:
 2124               	#ifndef __mcoldfire__
 2125               		cmpw	IMM (-DBL_MANT_DIG-1),d4		
 2126               	#else
 2127               		cmpl	IMM (-DBL_MANT_DIG-1),d4		
 2128               	#endif
 2129               		blt	Ld$underflow	
 2130               	| It could happen that the exponent is less than 1, in which case the 
 2131               	| number is denormalized. In this case we shift right and adjust the 
 2132               	| exponent until it becomes 1 or the fraction is zero (in the latter case 
 2133               	| we signal underflow and return zero).
 2134               		movel	d7,a0		|
 2135               		movel	IMM (0),d6	| use d6-d7 to collect bits flushed right
 2136               		movel	d6,d7		| use d6-d7 to collect bits flushed right
 2137               	#ifndef __mcoldfire__
 2138               		cmpw	IMM (1),d4	| if the exponent is less than 1 we 
 2139               	#else
 2140               		cmpl	IMM (1),d4	| if the exponent is less than 1 we 
 2141               	#endif
 2142               		bge	2f		| have to shift right (denormalize)
 2143               	1:
 2144               	#ifndef __mcoldfire__
 2145               		addw	IMM (1),d4	| adjust the exponent
 2146               		lsrl	IMM (1),d0	| shift right once 
 2147               		roxrl	IMM (1),d1	|
 2148               		roxrl	IMM (1),d2	|
 2149               		roxrl	IMM (1),d3	|
 2150               		roxrl	IMM (1),d6	| 
 2151               		roxrl	IMM (1),d7	|
 2152               		cmpw	IMM (1),d4	| is the exponent 1 already?
 2153               	#else
 2154               		addl	IMM (1),d4	| adjust the exponent
 2155               		lsrl	IMM (1),d7
 2156               		btst	IMM (0),d6
 2157               		beq	13f
 2158               		bset	IMM (31),d7
 2159               	13:	lsrl	IMM (1),d6
 2160               		btst	IMM (0),d3
 2161               		beq	14f
 2162               		bset	IMM (31),d6
 2163               	14:	lsrl	IMM (1),d3
 2164               		btst	IMM (0),d2
68K GAS   			page 39


 2165               		beq	10f
 2166               		bset	IMM (31),d3
 2167               	10:	lsrl	IMM (1),d2
 2168               		btst	IMM (0),d1
 2169               		beq	11f
 2170               		bset	IMM (31),d2
 2171               	11:	lsrl	IMM (1),d1
 2172               		btst	IMM (0),d0
 2173               		beq	12f
 2174               		bset	IMM (31),d1
 2175               	12:	lsrl	IMM (1),d0
 2176               		cmpl	IMM (1),d4	| is the exponent 1 already?
 2177               	#endif
 2178               		beq	2f		| if not loop back
 2179               		bra	1b              |
 2180               		bra	Ld$underflow	| safety check, shouldn't execute '
 2181               	2:	orl	d6,d2		| this is a trick so we don't lose  '
 2182               		orl	d7,d3		| the bits which were flushed right
 2183               		movel	a0,d7		| get back sign bit into d7
 2184               	| Now call the rounding routine (which takes care of denormalized numbers):
 2185               		lea	pc@(Lround$0),a0 | to return from rounding routine
 2186               		PICLEA	SYM (_fpCCR),a1	| check the rounding mode
 2187               	#ifdef __mcoldfire__
 2188               		clrl	d6
 2189               	#endif
 2190               		movew	a1@(6),d6	| rounding mode in d6
 2191               		beq	Lround$to$nearest
 2192               	#ifndef __mcoldfire__
 2193               		cmpw	IMM (ROUND_TO_PLUS),d6
 2194               	#else
 2195               		cmpl	IMM (ROUND_TO_PLUS),d6
 2196               	#endif
 2197               		bhi	Lround$to$minus
 2198               		blt	Lround$to$zero
 2199               		bra	Lround$to$plus
 2200               	Lround$0:
 2201               	| Here we have a correctly rounded result (either normalized or denormalized).
 2202               	
 2203               	| Here we should have either a normalized number or a denormalized one, and
 2204               	| the exponent is necessarily larger or equal to 1 (so we don't have to  '
 2205               	| check again for underflow!). We have to check for overflow or for a 
 2206               	| denormalized number (which also signals underflow).
 2207               	| Check for overflow (i.e., exponent >= 0x7ff).
 2208               	#ifndef __mcoldfire__
 2209               		cmpw	IMM (0x07ff),d4
 2210               	#else
 2211               		cmpl	IMM (0x07ff),d4
 2212               	#endif
 2213               		bge	Ld$overflow
 2214               	| Now check for a denormalized number (exponent==0):
 2215               		movew	d4,d4
 2216               		beq	Ld$den
 2217               	1:
 2218               	| Put back the exponents and sign and return.
 2219               	#ifndef __mcoldfire__
 2220               		lslw	IMM (4),d4	| exponent back to fourth byte
 2221               	#else
68K GAS   			page 40


 2222               		lsll	IMM (4),d4	| exponent back to fourth byte
 2223               	#endif
 2224               		bclr	IMM (DBL_MANT_DIG-32-1),d0
 2225               		swap	d0		| and put back exponent
 2226               	#ifndef __mcoldfire__
 2227               		orw	d4,d0		| 
 2228               	#else
 2229               		orl	d4,d0		| 
 2230               	#endif
 2231               		swap	d0		|
 2232               		orl	d7,d0		| and sign also
 2233               	
 2234               		PICLEA	SYM (_fpCCR),a0
 2235               		movew	IMM (0),a0@
 2236               	#ifndef __mcoldfire__
 2237               		moveml	sp@+,d2-d7
 2238               	#else
 2239               		moveml	sp@,d2-d7
 2240               		| XXX if frame pointer is ever removed, stack pointer must
 2241               		| be adjusted here.
 2242               	#endif
 2243               		unlk	a6
 2244               		rts
 2245               	
 2246               	|=============================================================================
 2247               	|                              __negdf2
 2248               	|=============================================================================
 2249               	
 2250               	| double __negdf2(double, double);
 2251               		FUNC(__negdf2)
 2252               	SYM (__negdf2):
 2253               	#ifndef __mcoldfire__
 2254               		link	a6,IMM (0)
 2255               		moveml	d2-d7,sp@-
 2256               	#else
 2257               		link	a6,IMM (-24)
 2258               		moveml	d2-d7,sp@
 2259               	#endif
 2260               		moveq	IMM (NEGATE),d5
 2261               		movel	a6@(8),d0	| get number to negate in d0-d1
 2262               		movel	a6@(12),d1	|
 2263               		bchg	IMM (31),d0	| negate
 2264               		movel	d0,d2		| make a positive copy (for the tests)
 2265               		bclr	IMM (31),d2	|
 2266               		movel	d2,d4		| check for zero
 2267               		orl	d1,d4		|
 2268               		beq	2f		| if zero (either sign) return +zero
 2269               		cmpl	IMM (0x7ff00000),d2 | compare to +INFINITY
 2270               		blt	1f		| if finite, return
 2271               		bhi	Ld$inop		| if larger (fraction not zero) is NaN
 2272               		tstl	d1		| if d2 == 0x7ff00000 check d1
 2273               		bne	Ld$inop		|
 2274               		movel	d0,d7		| else get sign and return INFINITY
 2275               		andl	IMM (0x80000000),d7
 2276               		bra	Ld$infty		
 2277               	1:	PICLEA	SYM (_fpCCR),a0
 2278               		movew	IMM (0),a0@
68K GAS   			page 41


 2279               	#ifndef __mcoldfire__
 2280               		moveml	sp@+,d2-d7
 2281               	#else
 2282               		moveml	sp@,d2-d7
 2283               		| XXX if frame pointer is ever removed, stack pointer must
 2284               		| be adjusted here.
 2285               	#endif
 2286               		unlk	a6
 2287               		rts
 2288               	2:	bclr	IMM (31),d0
 2289               		bra	1b
 2290               	
 2291               	|=============================================================================
 2292               	|                              __cmpdf2
 2293               	|=============================================================================
 2294               	
 2295               	GREATER =  1
 2296               	LESS    = -1
 2297               	EQUAL   =  0
 2298               	
 2299               	| int __cmpdf2_internal(double, double, int);
 2300               	SYM (__cmpdf2_internal):
 2301               	#ifndef __mcoldfire__
 2302               		link	a6,IMM (0)
 2303               		moveml	d2-d7,sp@- 	| save registers
 2304               	#else
 2305               		link	a6,IMM (-24)
 2306               		moveml	d2-d7,sp@
 2307               	#endif
 2308               		moveq	IMM (COMPARE),d5
 2309               		movel	a6@(8),d0	| get first operand
 2310               		movel	a6@(12),d1	|
 2311               		movel	a6@(16),d2	| get second operand
 2312               		movel	a6@(20),d3	|
 2313               	| First check if a and/or b are (+/-) zero and in that case clear
 2314               	| the sign bit.
 2315               		movel	d0,d6		| copy signs into d6 (a) and d7(b)
 2316               		bclr	IMM (31),d0	| and clear signs in d0 and d2
 2317               		movel	d2,d7		|
 2318               		bclr	IMM (31),d2	|
 2319               		cmpl	IMM (0x7ff00000),d0 | check for a == NaN
 2320               		bhi	Lcmpd$inop		| if d0 > 0x7ff00000, a is NaN
 2321               		beq	Lcmpdf$a$nf	| if equal can be INFINITY, so check d1
 2322               		movel	d0,d4		| copy into d4 to test for zero
 2323               		orl	d1,d4		|
 2324               		beq	Lcmpdf$a$0	|
 2325               	Lcmpdf$0:
 2326               		cmpl	IMM (0x7ff00000),d2 | check for b == NaN
 2327               		bhi	Lcmpd$inop		| if d2 > 0x7ff00000, b is NaN
 2328               		beq	Lcmpdf$b$nf	| if equal can be INFINITY, so check d3
 2329               		movel	d2,d4		|
 2330               		orl	d3,d4		|
 2331               		beq	Lcmpdf$b$0	|
 2332               	Lcmpdf$1:
 2333               	| Check the signs
 2334               		eorl	d6,d7
 2335               		bpl	1f
68K GAS   			page 42


 2336               	| If the signs are not equal check if a >= 0
 2337               		tstl	d6
 2338               		bpl	Lcmpdf$a$gt$b	| if (a >= 0 && b < 0) => a > b
 2339               		bmi	Lcmpdf$b$gt$a	| if (a < 0 && b >= 0) => a < b
 2340               	1:
 2341               	| If the signs are equal check for < 0
 2342               		tstl	d6
 2343               		bpl	1f
 2344               	| If both are negative exchange them
 2345               	#ifndef __mcoldfire__
 2346               		exg	d0,d2
 2347               		exg	d1,d3
 2348               	#else
 2349               		movel	d0,d7
 2350               		movel	d2,d0
 2351               		movel	d7,d2
 2352               		movel	d1,d7
 2353               		movel	d3,d1
 2354               		movel	d7,d3
 2355               	#endif
 2356               	1:
 2357               	| Now that they are positive we just compare them as longs (does this also
 2358               	| work for denormalized numbers?).
 2359               		cmpl	d0,d2
 2360               		bhi	Lcmpdf$b$gt$a	| |b| > |a|
 2361               		bne	Lcmpdf$a$gt$b	| |b| < |a|
 2362               	| If we got here d0 == d2, so we compare d1 and d3.
 2363               		cmpl	d1,d3
 2364               		bhi	Lcmpdf$b$gt$a	| |b| > |a|
 2365               		bne	Lcmpdf$a$gt$b	| |b| < |a|
 2366               	| If we got here a == b.
 2367               		movel	IMM (EQUAL),d0
 2368               	#ifndef __mcoldfire__
 2369               		moveml	sp@+,d2-d7 	| put back the registers
 2370               	#else
 2371               		moveml	sp@,d2-d7
 2372               		| XXX if frame pointer is ever removed, stack pointer must
 2373               		| be adjusted here.
 2374               	#endif
 2375               		unlk	a6
 2376               		rts
 2377               	Lcmpdf$a$gt$b:
 2378               		movel	IMM (GREATER),d0
 2379               	#ifndef __mcoldfire__
 2380               		moveml	sp@+,d2-d7 	| put back the registers
 2381               	#else
 2382               		moveml	sp@,d2-d7
 2383               		| XXX if frame pointer is ever removed, stack pointer must
 2384               		| be adjusted here.
 2385               	#endif
 2386               		unlk	a6
 2387               		rts
 2388               	Lcmpdf$b$gt$a:
 2389               		movel	IMM (LESS),d0
 2390               	#ifndef __mcoldfire__
 2391               		moveml	sp@+,d2-d7 	| put back the registers
 2392               	#else
68K GAS   			page 43


 2393               		moveml	sp@,d2-d7
 2394               		| XXX if frame pointer is ever removed, stack pointer must
 2395               		| be adjusted here.
 2396               	#endif
 2397               		unlk	a6
 2398               		rts
 2399               	
 2400               	Lcmpdf$a$0:	
 2401               		bclr	IMM (31),d6
 2402               		bra	Lcmpdf$0
 2403               	Lcmpdf$b$0:
 2404               		bclr	IMM (31),d7
 2405               		bra	Lcmpdf$1
 2406               	
 2407               	Lcmpdf$a$nf:
 2408               		tstl	d1
 2409               		bne	Ld$inop
 2410               		bra	Lcmpdf$0
 2411               	
 2412               	Lcmpdf$b$nf:
 2413               		tstl	d3
 2414               		bne	Ld$inop
 2415               		bra	Lcmpdf$1
 2416               	
 2417               	Lcmpd$inop:
 2418               		movl	a6@(24),d0
 2419               		moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
 2420               		moveq	IMM (DOUBLE_FLOAT),d6
 2421               		PICJUMP	$_exception_handler
 2422               	
 2423               	| int __cmpdf2(double, double);
 2424               		FUNC(__cmpdf2)
 2425               	SYM (__cmpdf2):
 2426               		link	a6,IMM (0)
 2427               		pea	1
 2428               		movl	a6@(20),sp@-
 2429               		movl	a6@(16),sp@-
 2430               		movl	a6@(12),sp@-
 2431               		movl	a6@(8),sp@-
 2432               		PICCALL	SYM (__cmpdf2_internal)
 2433               		unlk	a6
 2434               		rts
 2435               	
 2436               	|=============================================================================
 2437               	|                           rounding routines
 2438               	|=============================================================================
 2439               	
 2440               	| The rounding routines expect the number to be normalized in registers
 2441               	| d0-d1-d2-d3, with the exponent in register d4. They assume that the 
 2442               	| exponent is larger or equal to 1. They return a properly normalized number
 2443               	| if possible, and a denormalized number otherwise. The exponent is returned
 2444               	| in d4.
 2445               	
 2446               	Lround$to$nearest:
 2447               	| We now normalize as suggested by D. Knuth ("Seminumerical Algorithms"):
 2448               	| Here we assume that the exponent is not too small (this should be checked
 2449               	| before entering the rounding routine), but the number could be denormalized.
68K GAS   			page 44


 2450               	
 2451               	| Check for denormalized numbers:
 2452               	1:	btst	IMM (DBL_MANT_DIG-32),d0
 2453               		bne	2f		| if set the number is normalized
 2454               	| Normalize shifting left until bit #DBL_MANT_DIG-32 is set or the exponent 
 2455               	| is one (remember that a denormalized number corresponds to an 
 2456               	| exponent of -D_BIAS+1).
 2457               	#ifndef __mcoldfire__
 2458               		cmpw	IMM (1),d4	| remember that the exponent is at least one
 2459               	#else
 2460               		cmpl	IMM (1),d4	| remember that the exponent is at least one
 2461               	#endif
 2462               	 	beq	2f		| an exponent of one means denormalized
 2463               		addl	d3,d3		| else shift and adjust the exponent
 2464               		addxl	d2,d2		|
 2465               		addxl	d1,d1		|
 2466               		addxl	d0,d0		|
 2467               	#ifndef __mcoldfire__
 2468               		dbra	d4,1b		|
 2469               	#else
 2470               		subql	IMM (1), d4
 2471               		bpl	1b
 2472               	#endif
 2473               	2:
 2474               	| Now round: we do it as follows: after the shifting we can write the
 2475               	| fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.
 2476               	| If delta < 1, do nothing. If delta > 1, add 1 to f. 
 2477               	| If delta == 1, we make sure the rounded number will be even (odd?) 
 2478               	| (after shifting).
 2479               		btst	IMM (0),d1	| is delta < 1?
 2480               		beq	2f		| if so, do not do anything
 2481               		orl	d2,d3		| is delta == 1?
 2482               		bne	1f		| if so round to even
 2483               		movel	d1,d3		| 
 2484               		andl	IMM (2),d3	| bit 1 is the last significant bit
 2485               		movel	IMM (0),d2	|
 2486               		addl	d3,d1		|
 2487               		addxl	d2,d0		|
 2488               		bra	2f		| 
 2489               	1:	movel	IMM (1),d3	| else add 1 
 2490               		movel	IMM (0),d2	|
 2491               		addl	d3,d1		|
 2492               		addxl	d2,d0
 2493               	| Shift right once (because we used bit #DBL_MANT_DIG-32!).
 2494               	2:
 2495               	#ifndef __mcoldfire__
 2496               		lsrl	IMM (1),d0
 2497               		roxrl	IMM (1),d1		
 2498               	#else
 2499               		lsrl	IMM (1),d1
 2500               		btst	IMM (0),d0
 2501               		beq	10f
 2502               		bset	IMM (31),d1
 2503               	10:	lsrl	IMM (1),d0
 2504               	#endif
 2505               	
 2506               	| Now check again bit #DBL_MANT_DIG-32 (rounding could have produced a
68K GAS   			page 45


 2507               	| 'fraction overflow' ...).
 2508               		btst	IMM (DBL_MANT_DIG-32),d0	
 2509               		beq	1f
 2510               	#ifndef __mcoldfire__
 2511               		lsrl	IMM (1),d0
 2512               		roxrl	IMM (1),d1
 2513               		addw	IMM (1),d4
 2514               	#else
 2515               		lsrl	IMM (1),d1
 2516               		btst	IMM (0),d0
 2517               		beq	10f
 2518               		bset	IMM (31),d1
 2519               	10:	lsrl	IMM (1),d0
 2520               		addl	IMM (1),d4
 2521               	#endif
 2522               	1:
 2523               	| If bit #DBL_MANT_DIG-32-1 is clear we have a denormalized number, so we 
 2524               	| have to put the exponent to zero and return a denormalized number.
 2525               		btst	IMM (DBL_MANT_DIG-32-1),d0
 2526               		beq	1f
 2527               		jmp	a0@
 2528               	1:	movel	IMM (0),d4
 2529               		jmp	a0@
 2530               	
 2531               	Lround$to$zero:
 2532               	Lround$to$plus:
 2533               	Lround$to$minus:
 2534               		jmp	a0@
 2535               	#endif /* L_double */
 2536               	
 2537               	#ifdef  L_float
 2538               	
 2539               		.globl	SYM (_fpCCR)
 2540               		.globl  $_exception_handler
 2541               	
 2542               	QUIET_NaN    = 0xffffffff
 2543               	SIGNL_NaN    = 0x7f800001
 2544               	INFINITY     = 0x7f800000
 2545               	
 2546               	F_MAX_EXP      = 0xff
 2547               	F_BIAS         = 126
 2548               	FLT_MAX_EXP    = F_MAX_EXP - F_BIAS
 2549               	FLT_MIN_EXP    = 1 - F_BIAS
 2550               	FLT_MANT_DIG   = 24
 2551               	
 2552               	INEXACT_RESULT 		= 0x0001
 2553               	UNDERFLOW 		= 0x0002
 2554               	OVERFLOW 		= 0x0004
 2555               	DIVIDE_BY_ZERO 		= 0x0008
 2556               	INVALID_OPERATION 	= 0x0010
 2557               	
 2558               	SINGLE_FLOAT = 1
 2559               	
 2560               	NOOP         = 0
 2561               	ADD          = 1
 2562               	MULTIPLY     = 2
 2563               	DIVIDE       = 3
68K GAS   			page 46


 2564               	NEGATE       = 4
 2565               	COMPARE      = 5
 2566               	EXTENDSFDF   = 6
 2567               	TRUNCDFSF    = 7
 2568               	
 2569               	UNKNOWN           = -1
 2570               	ROUND_TO_NEAREST  = 0 | round result to nearest representable value
 2571               	ROUND_TO_ZERO     = 1 | round result towards zero
 2572               	ROUND_TO_PLUS     = 2 | round result towards plus infinity
 2573               	ROUND_TO_MINUS    = 3 | round result towards minus infinity
 2574               	
 2575               	| Entry points:
 2576               	
 2577               		.globl SYM (__addsf3)
 2578               		.globl SYM (__subsf3)
 2579               		.globl SYM (__mulsf3)
 2580               		.globl SYM (__divsf3)
 2581               		.globl SYM (__negsf2)
 2582               		.globl SYM (__cmpsf2)
 2583               		.globl SYM (__cmpsf2_internal)
 2584               		.hidden SYM (__cmpsf2_internal)
 2585               	
 2586               	| These are common routines to return and signal exceptions.	
 2587               	
 2588               		.text
 2589               		.even
 2590               	
 2591               	Lf$den:
 2592               	| Return and signal a denormalized number
 2593 0000 8087      		orl	d7,d0
 2594 0002 7E03      		moveq	IMM (INEXACT_RESULT+UNDERFLOW),d7
 2595 0004 7C01      		moveq	IMM (SINGLE_FLOAT),d6
 2596 0006 4EF9 0000 		PICJUMP	$_exception_handler
 2596      0000 
 2597               	
 2598               	Lf$infty:
 2599               	Lf$overflow:
 2600               	| Return a properly signed INFINITY and set the exception flags 
 2601 000c 203C 7F80 		movel	IMM (INFINITY),d0
 2601      0000 
 2602 0012 8087      		orl	d7,d0
 2603 0014 7E05      		moveq	IMM (INEXACT_RESULT+OVERFLOW),d7
 2604 0016 7C01      		moveq	IMM (SINGLE_FLOAT),d6
 2605 0018 4EF9 0000 		PICJUMP	$_exception_handler
 2605      0000 
 2606               	
 2607               	Lf$underflow:
 2608               	| Return 0 and set the exception flags 
 2609 001e 7000      		moveq	IMM (0),d0
 2610 0020 7E03      		moveq	IMM (INEXACT_RESULT+UNDERFLOW),d7
 2611 0022 7C01      		moveq	IMM (SINGLE_FLOAT),d6
 2612 0024 4EF9 0000 		PICJUMP	$_exception_handler
 2612      0000 
 2613               	
 2614               	Lf$inop:
 2615               	| Return a quiet NaN and set the exception flags
 2616 002a 70FF      		movel	IMM (QUIET_NaN),d0
68K GAS   			page 47


 2617 002c 7E11      		moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
 2618 002e 7C01      		moveq	IMM (SINGLE_FLOAT),d6
 2619 0030 4EF9 0000 		PICJUMP	$_exception_handler
 2619      0000 
 2620               	
 2621               	Lf$div$0:
 2622               	| Return a properly signed INFINITY and set the exception flags
 2623 0036 203C 7F80 		movel	IMM (INFINITY),d0
 2623      0000 
 2624 003c 8087      		orl	d7,d0
 2625 003e 7E09      		moveq	IMM (INEXACT_RESULT+DIVIDE_BY_ZERO),d7
 2626 0040 7C01      		moveq	IMM (SINGLE_FLOAT),d6
 2627 0042 4EF9 0000 		PICJUMP	$_exception_handler
 2627      0000 
 2628               	
 2629               	|=============================================================================
 2630               	|=============================================================================
 2631               	|                         single precision routines
 2632               	|=============================================================================
 2633               	|=============================================================================
 2634               	
 2635               	| A single precision floating point number (float) has the format:
 2636               	|
 2637               	| struct _float {
 2638               	|  unsigned int sign      : 1;  /* sign bit */ 
 2639               	|  unsigned int exponent  : 8;  /* exponent, shifted by 126 */
 2640               	|  unsigned int fraction  : 23; /* fraction */
 2641               	| } float;
 2642               	| 
 2643               	| Thus sizeof(float) = 4 (32 bits). 
 2644               	|
 2645               	| All the routines are callable from C programs, and return the result 
 2646               	| in the single register d0. They also preserve all registers except 
 2647               	| d0-d1 and a0-a1.
 2648               	
 2649               	|=============================================================================
 2650               	|                              __subsf3
 2651               	|=============================================================================
 2652               	
 2653               	| float __subsf3(float, float);
 2654               		FUNC(__subsf3)
 2655               	SYM (__subsf3):
 2656 0048 086F 001F 		bchg	IMM (31),sp@(8)	| change sign of second operand
 2656      0008 
 2657               					| and fall through
 2658               	|=============================================================================
 2659               	|                              __addsf3
 2660               	|=============================================================================
 2661               	
 2662               	| float __addsf3(float, float);
 2663               		FUNC(__addsf3)
 2664               	SYM (__addsf3):
 2665               	#ifndef __mcoldfire__
 2666 004e 4E56 0000 		link	a6,IMM (0)	| everything will be done in registers
 2667 0052 48E7 3F00 		moveml	d2-d7,sp@-	| save all data registers but d0-d1
 2668               	#else
 2669               		link	a6,IMM (-24)
68K GAS   			page 48


 2670               		moveml	d2-d7,sp@
 2671               	#endif
 2672 0056 202E 0008 		movel	a6@(8),d0	| get first operand
 2673 005a 222E 000C 		movel	a6@(12),d1	| get second operand
 2674 005e 2040      		movel	d0,a0		| get d0's sign bit '
 2675 0060 D080      		addl	d0,d0		| check and clear sign bit of a
 2676 0062 6700 01B6 		beq	Laddsf$b	| if zero return second operand
 2677 0066 2241      		movel	d1,a1		| save b's sign bit '
 2678 0068 D281      		addl	d1,d1		| get rid of sign bit
 2679 006a 6700 01CA 		beq	Laddsf$a	| if zero return first operand
 2680               	
 2681               	| Get the exponents and check for denormalized and/or infinity.
 2682               	
 2683 006e 283C 00FF 		movel	IMM (0x00ffffff),d4	| mask to get fraction
 2683      FFFF 
 2684 0074 2A3C 0100 		movel	IMM (0x01000000),d5	| mask to put hidden bit back
 2684      0000 
 2685               	
 2686 007a 2C00      		movel	d0,d6		| save a to get exponent
 2687 007c C084      		andl	d4,d0		| get fraction in d0
 2688 007e 4684      		notl 	d4		| make d4 into a mask for the exponent
 2689 0080 CC84      		andl	d4,d6		| get exponent in d6
 2690 0082 6700 0184 		beq	Laddsf$a$den	| branch if a is denormalized
 2691 0086 BC84      		cmpl	d4,d6		| check for INFINITY or NaN
 2692 0088 6700 01FE 		beq	Laddsf$nf
 2693 008c 4846      		swap	d6		| put exponent into first word
 2694 008e 8085      		orl	d5,d0		| and put hidden bit back
 2695               	Laddsf$1:
 2696               	| Now we have a's exponent in d6 (second byte) and the mantissa in d0. '
 2697 0090 2E01      		movel	d1,d7		| get exponent in d7
 2698 0092 CE84      		andl	d4,d7		| 
 2699 0094 6700 017A 		beq	Laddsf$b$den	| branch if b is denormalized
 2700 0098 BE84      		cmpl	d4,d7		| check for INFINITY or NaN
 2701 009a 6700 01EC 		beq	Laddsf$nf
 2702 009e 4847      		swap	d7		| put exponent into first word
 2703 00a0 4684      		notl 	d4		| make d4 into a mask for the fraction
 2704 00a2 C284      		andl	d4,d1		| get fraction in d1
 2705 00a4 8285      		orl	d5,d1		| and put hidden bit back
 2706               	Laddsf$2:
 2707               	| Now we have b's exponent in d7 (second byte) and the mantissa in d1. '
 2708               	
 2709               	| Note that the hidden bit corresponds to bit #FLT_MANT_DIG-1, and we 
 2710               	| shifted right once, so bit #FLT_MANT_DIG is set (so we have one extra
 2711               	| bit).
 2712               	
 2713 00a6 2401      		movel	d1,d2		| move b to d2, since we want to use
 2714               					| two registers to do the sum
 2715 00a8 7200      		movel	IMM (0),d1	| and clear the new ones
 2716 00aa 2601      		movel	d1,d3		|
 2717               	
 2718               	| Here we shift the numbers in registers d0 and d1 so the exponents are the
 2719               	| same, and put the largest exponent in d6. Note that we are using two
 2720               	| registers for each number (see the discussion by D. Knuth in "Seminumerical 
 2721               	| Algorithms").
 2722               	#ifndef __mcoldfire__
 2723 00ac BE46      		cmpw	d6,d7		| compare exponents
 2724               	#else
68K GAS   			page 49


 2725               		cmpl	d6,d7		| compare exponents
 2726               	#endif
 2727 00ae 6700 0074 		beq	Laddsf$3	| if equal don't shift '
 2728 00b2 6200 003A 		bhi	5f		| branch if second exponent largest
 2729               	1:
 2730 00b6 9E86      		subl	d6,d7		| keep the largest exponent
 2731 00b8 4487      		negl	d7
 2732               	#ifndef __mcoldfire__
 2733 00ba E04F      		lsrw	IMM (8),d7	| put difference in lower byte
 2734               	#else
 2735               		lsrl	IMM (8),d7	| put difference in lower byte
 2736               	#endif
 2737               	| if difference is too large we don't shift (actually, we can just exit) '
 2738               	#ifndef __mcoldfire__
 2739 00bc 0C47 001A 		cmpw	IMM (FLT_MANT_DIG+2),d7		
 2740               	#else
 2741               		cmpl	IMM (FLT_MANT_DIG+2),d7		
 2742               	#endif
 2743 00c0 6C00 0130 		bge	Laddsf$b$small
 2744               	#ifndef __mcoldfire__
 2745 00c4 0C47 0010 		cmpw	IMM (16),d7	| if difference >= 16 swap
 2746               	#else
 2747               		cmpl	IMM (16),d7	| if difference >= 16 swap
 2748               	#endif
 2749 00c8 6C00 0010 		bge	4f
 2750               	2:
 2751               	#ifndef __mcoldfire__
 2752 00cc 5347      		subw	IMM (1),d7
 2753               	#else
 2754               		subql	IMM (1), d7
 2755               	#endif
 2756               	3:
 2757               	#ifndef __mcoldfire__
 2758 00ce E28A      		lsrl	IMM (1),d2	| shift right second operand
 2759 00d0 E293      		roxrl	IMM (1),d3
 2760 00d2 51CF FFFA 		dbra	d7,3b
 2761               	#else
 2762               		lsrl	IMM (1),d3
 2763               		btst	IMM (0),d2
 2764               		beq	10f
 2765               		bset	IMM (31),d3
 2766               	10:	lsrl	IMM (1),d2
 2767               		subql	IMM (1), d7
 2768               		bpl	3b
 2769               	#endif
 2770 00d6 6000 004C 		bra	Laddsf$3
 2771               	4:
 2772 00da 3602      		movew	d2,d3
 2773 00dc 4843      		swap	d3
 2774 00de 3403      		movew	d3,d2
 2775 00e0 4842      		swap	d2
 2776               	#ifndef __mcoldfire__
 2777 00e2 0447 0010 		subw	IMM (16),d7
 2778               	#else
 2779               		subl	IMM (16),d7
 2780               	#endif
 2781 00e6 6600 FFE4 		bne	2b		| if still more bits, go back to normal case
68K GAS   			page 50


 2782 00ea 6000 0038 		bra	Laddsf$3
 2783               	5:
 2784               	#ifndef __mcoldfire__
 2785 00ee CD47      		exg	d6,d7		| exchange the exponents
 2786               	#else
 2787               		eorl	d6,d7
 2788               		eorl	d7,d6
 2789               		eorl	d6,d7
 2790               	#endif
 2791 00f0 9E86      		subl	d6,d7		| keep the largest exponent
 2792 00f2 4487      		negl	d7		|
 2793               	#ifndef __mcoldfire__
 2794 00f4 E04F      		lsrw	IMM (8),d7	| put difference in lower byte
 2795               	#else
 2796               		lsrl	IMM (8),d7	| put difference in lower byte
 2797               	#endif
 2798               	| if difference is too large we don't shift (and exit!) '
 2799               	#ifndef __mcoldfire__
 2800 00f6 0C47 001A 		cmpw	IMM (FLT_MANT_DIG+2),d7		
 2801               	#else
 2802               		cmpl	IMM (FLT_MANT_DIG+2),d7		
 2803               	#endif
 2804 00fa 6C00 00E0 		bge	Laddsf$a$small
 2805               	#ifndef __mcoldfire__
 2806 00fe 0C47 0010 		cmpw	IMM (16),d7	| if difference >= 16 swap
 2807               	#else
 2808               		cmpl	IMM (16),d7	| if difference >= 16 swap
 2809               	#endif
 2810 0102 6C00 0010 		bge	8f
 2811               	6:
 2812               	#ifndef __mcoldfire__
 2813 0106 5347      		subw	IMM (1),d7
 2814               	#else
 2815               		subl	IMM (1),d7
 2816               	#endif
 2817               	7:
 2818               	#ifndef __mcoldfire__
 2819 0108 E288      		lsrl	IMM (1),d0	| shift right first operand
 2820 010a E291      		roxrl	IMM (1),d1
 2821 010c 51CF FFFA 		dbra	d7,7b
 2822               	#else
 2823               		lsrl	IMM (1),d1
 2824               		btst	IMM (0),d0
 2825               		beq	10f
 2826               		bset	IMM (31),d1
 2827               	10:	lsrl	IMM (1),d0
 2828               		subql	IMM (1),d7
 2829               		bpl	7b
 2830               	#endif
 2831 0110 6000 0012 		bra	Laddsf$3
 2832               	8:
 2833 0114 3200      		movew	d0,d1
 2834 0116 4841      		swap	d1
 2835 0118 3001      		movew	d1,d0
 2836 011a 4840      		swap	d0
 2837               	#ifndef __mcoldfire__
 2838 011c 0447 0010 		subw	IMM (16),d7
68K GAS   			page 51


 2839               	#else
 2840               		subl	IMM (16),d7
 2841               	#endif
 2842 0120 6600 FFE4 		bne	6b		| if still more bits, go back to normal case
 2843               					| otherwise we fall through
 2844               	
 2845               	| Now we have a in d0-d1, b in d2-d3, and the largest exponent in d6 (the
 2846               	| signs are stored in a0 and a1).
 2847               	
 2848               	Laddsf$3:
 2849               	| Here we have to decide whether to add or subtract the numbers
 2850               	#ifndef __mcoldfire__
 2851 0124 CD88      		exg	d6,a0		| get signs back
 2852 0126 CF89      		exg	d7,a1		| and save the exponents
 2853               	#else
 2854               		movel	d6,d4
 2855               		movel	a0,d6
 2856               		movel	d4,a0
 2857               		movel	d7,d4
 2858               		movel	a1,d7
 2859               		movel	d4,a1
 2860               	#endif
 2861 0128 BD87      		eorl	d6,d7		| combine sign bits
 2862 012a 6B00 0060 		bmi	Lsubsf$0	| if negative a and b have opposite 
 2863               					| sign so we actually subtract the
 2864               					| numbers
 2865               	
 2866               	| Here we have both positive or both negative
 2867               	#ifndef __mcoldfire__
 2868 012e CD88      		exg	d6,a0		| now we have the exponent in d6
 2869               	#else
 2870               		movel	d6,d4
 2871               		movel	a0,d6
 2872               		movel	d4,a0
 2873               	#endif
 2874 0130 2E08      		movel	a0,d7		| and sign in d7
 2875 0132 0287 8000 		andl	IMM (0x80000000),d7
 2875      0000 
 2876               	| Here we do the addition.
 2877 0138 D283      		addl	d3,d1
 2878 013a D182      		addxl	d2,d0
 2879               	| Note: now we have d2, d3, d4 and d5 to play with! 
 2880               	
 2881               	| Put the exponent, in the first byte, in d2, to use the "standard" rounding
 2882               	| routines:
 2883 013c 2406      		movel	d6,d2
 2884               	#ifndef __mcoldfire__
 2885 013e E04A      		lsrw	IMM (8),d2
 2886               	#else
 2887               		lsrl	IMM (8),d2
 2888               	#endif
 2889               	
 2890               	| Before rounding normalize so bit #FLT_MANT_DIG is set (we will consider
 2891               	| the case of denormalized numbers in the rounding routine itself).
 2892               	| As in the addition (not in the subtraction!) we could have set 
 2893               	| one more bit we check this:
 2894 0140 0800 0019 		btst	IMM (FLT_MANT_DIG+1),d0	
68K GAS   			page 52


 2895 0144 6700 0008 		beq	1f
 2896               	#ifndef __mcoldfire__
 2897 0148 E288      		lsrl	IMM (1),d0
 2898 014a E291      		roxrl	IMM (1),d1
 2899               	#else
 2900               		lsrl	IMM (1),d1
 2901               		btst	IMM (0),d0
 2902               		beq	10f
 2903               		bset	IMM (31),d1
 2904               	10:	lsrl	IMM (1),d0
 2905               	#endif
 2906 014c 5282      		addl	IMM (1),d2
 2907               	1:
 2908 014e 41FA 0020 		lea	pc@(Laddsf$4),a0 | to return from rounding routine
 2909 0152 43F9 0000 		PICLEA	SYM (_fpCCR),a1	| check the rounding mode
 2909      0000 
 2910               	#ifdef __mcoldfire__
 2911               		clrl	d6
 2912               	#endif
 2913 0158 3C29 0006 		movew	a1@(6),d6	| rounding mode in d6
 2914 015c 6700 0578 		beq	Lround$to$nearest
 2915               	#ifndef __mcoldfire__
 2916 0160 0C46 0002 		cmpw	IMM (ROUND_TO_PLUS),d6
 2917               	#else
 2918               		cmpl	IMM (ROUND_TO_PLUS),d6
 2919               	#endif
 2920 0164 6200 05C4 		bhi	Lround$to$minus
 2921 0168 6D00 05C0 		blt	Lround$to$zero
 2922 016c 6000 05BC 		bra	Lround$to$plus
 2923               	Laddsf$4:
 2924               	| Put back the exponent, but check for overflow.
 2925               	#ifndef __mcoldfire__
 2926 0170 0C42 00FF 		cmpw	IMM (0xff),d2
 2927               	#else
 2928               		cmpl	IMM (0xff),d2
 2929               	#endif
 2930 0174 6200 0010 		bhi	1f
 2931 0178 0880 0017 		bclr	IMM (FLT_MANT_DIG-1),d0
 2932               	#ifndef __mcoldfire__
 2933 017c EF4A      		lslw	IMM (7),d2
 2934               	#else
 2935               		lsll	IMM (7),d2
 2936               	#endif
 2937 017e 4842      		swap	d2
 2938 0180 8082      		orl	d2,d0
 2939 0182 6000 00EA 		bra	Laddsf$ret
 2940               	1:
 2941 0186 7A01      		moveq	IMM (ADD),d5
 2942 0188 6000 FE82 		bra	Lf$overflow
 2943               	
 2944               	Lsubsf$0:
 2945               	| We are here if a > 0 and b < 0 (sign bits cleared).
 2946               	| Here we do the subtraction.
 2947 018c 2E06      		movel	d6,d7		| put sign in d7
 2948 018e 0287 8000 		andl	IMM (0x80000000),d7
 2948      0000 
 2949               	
68K GAS   			page 53


 2950 0194 9283      		subl	d3,d1		| result in d0-d1
 2951 0196 9182      		subxl	d2,d0		|
 2952 0198 6700 00D4 		beq	Laddsf$ret	| if zero just exit
 2953 019c 6A00 000A 		bpl	1f		| if positive skip the following
 2954 01a0 0847 001F 		bchg	IMM (31),d7	| change sign bit in d7
 2955 01a4 4481      		negl	d1
 2956 01a6 4080      		negxl	d0
 2957               	1:
 2958               	#ifndef __mcoldfire__
 2959 01a8 C588      		exg	d2,a0		| now we have the exponent in d2
 2960 01aa E04A      		lsrw	IMM (8),d2	| put it in the first byte
 2961               	#else
 2962               		movel	d2,d4
 2963               		movel	a0,d2
 2964               		movel	d4,a0
 2965               		lsrl	IMM (8),d2	| put it in the first byte
 2966               	#endif
 2967               	
 2968               	| Now d0-d1 is positive and the sign bit is in d7.
 2969               	
 2970               	| Note that we do not have to normalize, since in the subtraction bit
 2971               	| #FLT_MANT_DIG+1 is never set, and denormalized numbers are handled by
 2972               	| the rounding routines themselves.
 2973 01ac 41FA 0020 		lea	pc@(Lsubsf$1),a0 | to return from rounding routine
 2974 01b0 43F9 0000 		PICLEA	SYM (_fpCCR),a1	| check the rounding mode
 2974      0000 
 2975               	#ifdef __mcoldfire__
 2976               		clrl	d6
 2977               	#endif
 2978 01b6 3C29 0006 		movew	a1@(6),d6	| rounding mode in d6
 2979 01ba 6700 051A 		beq	Lround$to$nearest
 2980               	#ifndef __mcoldfire__
 2981 01be 0C46 0002 		cmpw	IMM (ROUND_TO_PLUS),d6
 2982               	#else
 2983               		cmpl	IMM (ROUND_TO_PLUS),d6
 2984               	#endif
 2985 01c2 6200 0566 		bhi	Lround$to$minus
 2986 01c6 6D00 0562 		blt	Lround$to$zero
 2987 01ca 6000 055E 		bra	Lround$to$plus
 2988               	Lsubsf$1:
 2989               	| Put back the exponent (we can't have overflow!). '
 2990 01ce 0880 0017 		bclr	IMM (FLT_MANT_DIG-1),d0
 2991               	#ifndef __mcoldfire__
 2992 01d2 EF4A      		lslw	IMM (7),d2
 2993               	#else
 2994               		lsll	IMM (7),d2
 2995               	#endif
 2996 01d4 4842      		swap	d2
 2997 01d6 8082      		orl	d2,d0
 2998 01d8 6000 0094 		bra	Laddsf$ret
 2999               	
 3000               	| If one of the numbers was too small (difference of exponents >= 
 3001               	| FLT_MANT_DIG+2) we return the other (and now we don't have to '
 3002               	| check for finiteness or zero).
 3003               	Laddsf$a$small:
 3004 01dc 202E 000C 		movel	a6@(12),d0
 3005 01e0 41F9 0000 		PICLEA	SYM (_fpCCR),a0
68K GAS   			page 54


 3005      0000 
 3006 01e6 30BC 0000 		movew	IMM (0),a0@
 3007               	#ifndef __mcoldfire__
 3008 01ea 4CDF 00FC 		moveml	sp@+,d2-d7	| restore data registers
 3009               	#else
 3010               		moveml	sp@,d2-d7
 3011               		| XXX if frame pointer is ever removed, stack pointer must
 3012               		| be adjusted here.
 3013               	#endif
 3014 01ee 4E5E      		unlk	a6		| and return
 3015 01f0 4E75      		rts
 3016               	
 3017               	Laddsf$b$small:
 3018 01f2 202E 0008 		movel	a6@(8),d0
 3019 01f6 41F9 0000 		PICLEA	SYM (_fpCCR),a0
 3019      0000 
 3020 01fc 30BC 0000 		movew	IMM (0),a0@
 3021               	#ifndef __mcoldfire__
 3022 0200 4CDF 00FC 		moveml	sp@+,d2-d7	| restore data registers
 3023               	#else
 3024               		moveml	sp@,d2-d7
 3025               		| XXX if frame pointer is ever removed, stack pointer must
 3026               		| be adjusted here.
 3027               	#endif
 3028 0204 4E5E      		unlk	a6		| and return
 3029 0206 4E75      		rts
 3030               	
 3031               	| If the numbers are denormalized remember to put exponent equal to 1.
 3032               	
 3033               	Laddsf$a$den:
 3034 0208 2C05      		movel	d5,d6		| d5 contains 0x01000000
 3035 020a 4846      		swap	d6
 3036 020c 6000 FE82 		bra	Laddsf$1
 3037               	
 3038               	Laddsf$b$den:
 3039 0210 2E05      		movel	d5,d7
 3040 0212 4847      		swap	d7
 3041 0214 4684      		notl 	d4		| make d4 into a mask for the fraction
 3042               					| (this was not executed after the jump)
 3043 0216 6000 FE8E 		bra	Laddsf$2
 3044               	
 3045               	| The rest is mainly code for the different results which can be 
 3046               	| returned (checking always for +/-INFINITY and NaN).
 3047               	
 3048               	Laddsf$b:
 3049               	| Return b (if a is zero).
 3050 021a 202E 000C 		movel	a6@(12),d0
 3051 021e 0C80 8000 		cmpl	IMM (0x80000000),d0	| Check if b is -0
 3051      0000 
 3052 0224 6600 0014 		bne	1f
 3053 0228 2E08      		movel	a0,d7
 3054 022a 0287 8000 		andl	IMM (0x80000000),d7	| Use the sign of a
 3054      0000 
 3055 0230 4280      		clrl	d0
 3056 0232 6000 003A 		bra	Laddsf$ret
 3057               	Laddsf$a:
 3058               	| Return a (if b is zero).
68K GAS   			page 55


 3059 0236 202E 0008 		movel	a6@(8),d0
 3060               	1:
 3061 023a 7A01      		moveq	IMM (ADD),d5
 3062               	| We have to check for NaN and +/-infty.
 3063 023c 2E00      		movel	d0,d7
 3064 023e 0287 8000 		andl	IMM (0x80000000),d7	| put sign in d7
 3064      0000 
 3065 0244 0880 001F 		bclr	IMM (31),d0		| clear sign
 3066 0248 0C80 7F80 		cmpl	IMM (INFINITY),d0	| check for infty or NaN
 3066      0000 
 3067 024e 6C00 0010 		bge	2f
 3068 0252 2000      		movel	d0,d0		| check for zero (we do this because we don't '
 3069 0254 6600 0018 		bne	Laddsf$ret	| want to return -0 by mistake
 3070 0258 0887 001F 		bclr	IMM (31),d7	| if zero be sure to clear sign
 3071 025c 6000 0010 		bra	Laddsf$ret	| if everything OK just return
 3072               	2:
 3073               	| The value to be returned is either +/-infty or NaN
 3074 0260 0280 007F 		andl	IMM (0x007fffff),d0	| check for NaN
 3074      FFFF 
 3075 0266 6600 FDC2 		bne	Lf$inop			| if mantissa not zero is NaN
 3076 026a 6000 FDA0 		bra	Lf$infty
 3077               	
 3078               	Laddsf$ret:
 3079               	| Normal exit (a and b nonzero, result is not NaN nor +/-infty).
 3080               	| We have to clear the exception flags (just the exception type).
 3081 026e 41F9 0000 		PICLEA	SYM (_fpCCR),a0
 3081      0000 
 3082 0274 30BC 0000 		movew	IMM (0),a0@
 3083 0278 8087      		orl	d7,d0		| put sign bit
 3084               	#ifndef __mcoldfire__
 3085 027a 4CDF 00FC 		moveml	sp@+,d2-d7	| restore data registers
 3086               	#else
 3087               		moveml	sp@,d2-d7
 3088               		| XXX if frame pointer is ever removed, stack pointer must
 3089               		| be adjusted here.
 3090               	#endif
 3091 027e 4E5E      		unlk	a6		| and return
 3092 0280 4E75      		rts
 3093               	
 3094               	Laddsf$ret$den:
 3095               	| Return a denormalized number (for addition we don't signal underflow) '
 3096 0282 E288      		lsrl	IMM (1),d0	| remember to shift right back once
 3097 0284 6000 FFE8 		bra	Laddsf$ret	| and return
 3098               	
 3099               	| Note: when adding two floats of the same sign if either one is 
 3100               	| NaN we return NaN without regard to whether the other is finite or 
 3101               	| not. When subtracting them (i.e., when adding two numbers of 
 3102               	| opposite signs) things are more complicated: if both are INFINITY 
 3103               	| we return NaN, if only one is INFINITY and the other is NaN we return
 3104               	| NaN, but if it is finite we return INFINITY with the corresponding sign.
 3105               	
 3106               	Laddsf$nf:
 3107 0288 7A01      		moveq	IMM (ADD),d5
 3108               	| This could be faster but it is not worth the effort, since it is not
 3109               	| executed very often. We sacrifice speed for clarity here.
 3110 028a 202E 0008 		movel	a6@(8),d0	| get the numbers back (remember that we
 3111 028e 222E 000C 		movel	a6@(12),d1	| did some processing already)
68K GAS   			page 56


 3112 0292 283C 7F80 		movel	IMM (INFINITY),d4 | useful constant (INFINITY)
 3112      0000 
 3113 0298 2400      		movel	d0,d2		| save sign bits
 3114 029a 2601      		movel	d1,d3
 3115 029c 0880 001F 		bclr	IMM (31),d0	| clear sign bits
 3116 02a0 0881 001F 		bclr	IMM (31),d1
 3117               	| We know that one of them is either NaN of +/-INFINITY
 3118               	| Check for NaN (if either one is NaN return NaN)
 3119 02a4 B084      		cmpl	d4,d0		| check first a (d0)
 3120 02a6 6200 FD82 		bhi	Lf$inop		
 3121 02aa B284      		cmpl	d4,d1		| check now b (d1)
 3122 02ac 6200 FD7C 		bhi	Lf$inop		
 3123               	| Now comes the check for +/-INFINITY. We know that both are (maybe not
 3124               	| finite) numbers, but we have to check if both are infinite whether we
 3125               	| are adding or subtracting them.
 3126 02b0 B782      		eorl	d3,d2		| to check sign bits
 3127 02b2 6B00 000E 		bmi	1f
 3128 02b6 2E00      		movel	d0,d7
 3129 02b8 0287 8000 		andl	IMM (0x80000000),d7	| get (common) sign bit
 3129      0000 
 3130 02be 6000 FD4C 		bra	Lf$infty
 3131               	1:
 3132               	| We know one (or both) are infinite, so we test for equality between the
 3133               	| two numbers (if they are equal they have to be infinite both, so we
 3134               	| return NaN).
 3135 02c2 B081      		cmpl	d1,d0		| are both infinite?
 3136 02c4 6700 FD64 		beq	Lf$inop		| if so return NaN
 3137               	
 3138 02c8 2E00      		movel	d0,d7
 3139 02ca 0287 8000 		andl	IMM (0x80000000),d7 | get a's sign bit '
 3139      0000 
 3140 02d0 B084      		cmpl	d4,d0		| test now for infinity
 3141 02d2 6700 FD38 		beq	Lf$infty	| if a is INFINITY return with this sign
 3142 02d6 0847 001F 		bchg	IMM (31),d7	| else we know b is INFINITY and has
 3143 02da 6000 FD30 		bra	Lf$infty	| the opposite sign
 3144               	
 3145               	|=============================================================================
 3146               	|                             __mulsf3
 3147               	|=============================================================================
 3148               	
 3149               	| float __mulsf3(float, float);
 3150               		FUNC(__mulsf3)
 3151               	SYM (__mulsf3):
 3152               	#ifndef __mcoldfire__
 3153 02de 4E56 0000 		link	a6,IMM (0)
 3154 02e2 48E7 3F00 		moveml	d2-d7,sp@-
 3155               	#else
 3156               		link	a6,IMM (-24)
 3157               		moveml	d2-d7,sp@
 3158               	#endif
 3159 02e6 202E 0008 		movel	a6@(8),d0	| get a into d0
 3160 02ea 222E 000C 		movel	a6@(12),d1	| and b into d1
 3161 02ee 2E00      		movel	d0,d7		| d7 will hold the sign of the product
 3162 02f0 B387      		eorl	d1,d7		|
 3163 02f2 0287 8000 		andl	IMM (0x80000000),d7
 3163      0000 
 3164 02f8 2C3C 7F80 		movel	IMM (INFINITY),d6	| useful constant (+INFINITY)
68K GAS   			page 57


 3164      0000 
 3165 02fe 2A06      		movel	d6,d5			| another (mask for fraction)
 3166 0300 4685      		notl	d5			|
 3167 0302 283C 0080 		movel	IMM (0x00800000),d4	| this is to put hidden bit back
 3167      0000 
 3168 0308 0880 001F 		bclr	IMM (31),d0		| get rid of a's sign bit '
 3169 030c 2400      		movel	d0,d2			|
 3170 030e 6700 00AC 		beq	Lmulsf$a$0		| branch if a is zero
 3171 0312 0881 001F 		bclr	IMM (31),d1		| get rid of b's sign bit '
 3172 0316 2601      		movel	d1,d3		|
 3173 0318 6700 009A 		beq	Lmulsf$b$0	| branch if b is zero
 3174 031c B086      		cmpl	d6,d0		| is a big?
 3175 031e 6200 007C 		bhi	Lmulsf$inop	| if a is NaN return NaN
 3176 0322 6700 0084 		beq	Lmulsf$inf	| if a is INFINITY we have to check b
 3177 0326 B286      		cmpl	d6,d1		| now compare b with INFINITY
 3178 0328 6200 0072 		bhi	Lmulsf$inop	| is b NaN?
 3179 032c 6700 0074 		beq	Lmulsf$overflow | is b INFINITY?
 3180               	| Here we have both numbers finite and nonzero (and with no sign bit).
 3181               	| Now we get the exponents into d2 and d3.
 3182 0330 C486      		andl	d6,d2		| and isolate exponent in d2
 3183 0332 6700 00AE 		beq	Lmulsf$a$den	| if exponent is zero we have a denormalized
 3184 0336 C085      		andl	d5,d0		| and isolate fraction
 3185 0338 8084      		orl	d4,d0		| and put hidden bit back
 3186 033a 4842      		swap	d2		| I like exponents in the first byte
 3187               	#ifndef __mcoldfire__
 3188 033c EE4A      		lsrw	IMM (7),d2	| 
 3189               	#else
 3190               		lsrl	IMM (7),d2	| 
 3191               	#endif
 3192               	Lmulsf$1:			| number
 3193 033e C686      		andl	d6,d3		|
 3194 0340 6700 00B4 		beq	Lmulsf$b$den	|
 3195 0344 C285      		andl	d5,d1		|
 3196 0346 8284      		orl	d4,d1		|
 3197 0348 4843      		swap	d3		|
 3198               	#ifndef __mcoldfire__
 3199 034a EE4B      		lsrw	IMM (7),d3	|
 3200               	#else
 3201               		lsrl	IMM (7),d3	|
 3202               	#endif
 3203               	Lmulsf$2:			|
 3204               	#ifndef __mcoldfire__
 3205 034c D443      		addw	d3,d2		| add exponents
 3206 034e 0442 007F 		subw	IMM (F_BIAS+1),d2 | and subtract bias (plus one)
 3207               	#else
 3208               		addl	d3,d2		| add exponents
 3209               		subl	IMM (F_BIAS+1),d2 | and subtract bias (plus one)
 3210               	#endif
 3211               	
 3212               	| We are now ready to do the multiplication. The situation is as follows:
 3213               	| both a and b have bit FLT_MANT_DIG-1 set (even if they were 
 3214               	| denormalized to start with!), which means that in the product 
 3215               	| bit 2*(FLT_MANT_DIG-1) (that is, bit 2*FLT_MANT_DIG-2-32 of the 
 3216               	| high long) is set. 
 3217               	
 3218               	| To do the multiplication let us move the number a little bit around ...
 3219 0352 2C01      		movel	d1,d6		| second operand in d6
68K GAS   			page 58


 3220 0354 2A00      		movel	d0,d5		| first operand in d4-d5
 3221 0356 7800      		movel	IMM (0),d4
 3222 0358 2204      		movel	d4,d1		| the sums will go in d0-d1
 3223 035a 2004      		movel	d4,d0
 3224               	
 3225               	| now bit FLT_MANT_DIG-1 becomes bit 31:
 3226 035c E18E      		lsll	IMM (31-FLT_MANT_DIG+1),d6		
 3227               	
 3228               	| Start the loop (we loop #FLT_MANT_DIG times):
 3229 035e 7617      		moveq	IMM (FLT_MANT_DIG-1),d3	
 3230 0360 D281      	1:	addl	d1,d1		| shift sum 
 3231 0362 D180      		addxl	d0,d0
 3232 0364 E38E      		lsll	IMM (1),d6	| get bit bn
 3233 0366 6400 0006 		bcc	2f		| if not set skip sum
 3234 036a D285      		addl	d5,d1		| add a
 3235 036c D184      		addxl	d4,d0
 3236               	2:
 3237               	#ifndef __mcoldfire__
 3238 036e 51CB FFF0 		dbf	d3,1b		| loop back
 3239               	#else
 3240               		subql	IMM (1),d3
 3241               		bpl	1b
 3242               	#endif
 3243               	
 3244               	| Now we have the product in d0-d1, with bit (FLT_MANT_DIG - 1) + FLT_MANT_DIG
 3245               	| (mod 32) of d0 set. The first thing to do now is to normalize it so bit 
 3246               	| FLT_MANT_DIG is set (to do the rounding).
 3247               	#ifndef __mcoldfire__
 3248 0372 EC99      		rorl	IMM (6),d1
 3249 0374 4841      		swap	d1
 3250 0376 3601      		movew	d1,d3
 3251 0378 0243 03FF 		andw	IMM (0x03ff),d3
 3252 037c 0241 FD00 		andw	IMM (0xfd00),d1
 3253               	#else
 3254               		movel	d1,d3
 3255               		lsll	IMM (8),d1
 3256               		addl	d1,d1
 3257               		addl	d1,d1
 3258               		moveq	IMM (22),d5
 3259               		lsrl	d5,d3
 3260               		orl	d3,d1
 3261               		andl	IMM (0xfffffd00),d1
 3262               	#endif
 3263 0380 E188      		lsll	IMM (8),d0
 3264 0382 D080      		addl	d0,d0
 3265 0384 D080      		addl	d0,d0
 3266               	#ifndef __mcoldfire__
 3267 0386 8043      		orw	d3,d0
 3268               	#else
 3269               		orl	d3,d0
 3270               	#endif
 3271               	
 3272 0388 7A02      		moveq	IMM (MULTIPLY),d5
 3273               		
 3274 038a 0800 0019 		btst	IMM (FLT_MANT_DIG+1),d0
 3275 038e 6700 01C4 		beq	Lround$exit
 3276               	#ifndef __mcoldfire__
68K GAS   			page 59


 3277 0392 E288      		lsrl	IMM (1),d0
 3278 0394 E291      		roxrl	IMM (1),d1
 3279 0396 5242      		addw	IMM (1),d2
 3280               	#else
 3281               		lsrl	IMM (1),d1
 3282               		btst	IMM (0),d0
 3283               		beq	10f
 3284               		bset	IMM (31),d1
 3285               	10:	lsrl	IMM (1),d0
 3286               		addql	IMM (1),d2
 3287               	#endif
 3288 0398 6000 01BA 		bra	Lround$exit
 3289               	
 3290               	Lmulsf$inop:
 3291 039c 7A02      		moveq	IMM (MULTIPLY),d5
 3292 039e 6000 FC8A 		bra	Lf$inop
 3293               	
 3294               	Lmulsf$overflow:
 3295 03a2 7A02      		moveq	IMM (MULTIPLY),d5
 3296 03a4 6000 FC66 		bra	Lf$overflow
 3297               	
 3298               	Lmulsf$inf:
 3299 03a8 7A02      		moveq	IMM (MULTIPLY),d5
 3300               	| If either is NaN return NaN; else both are (maybe infinite) numbers, so
 3301               	| return INFINITY with the correct sign (which is in d7).
 3302 03aa B286      		cmpl	d6,d1		| is b NaN?
 3303 03ac 6200 FC7C 		bhi	Lf$inop		| if so return NaN
 3304 03b0 6000 FC5A 		bra	Lf$overflow	| else return +/-INFINITY
 3305               	
 3306               	| If either number is zero return zero, unless the other is +/-INFINITY, 
 3307               	| or NaN, in which case we return NaN.
 3308               	Lmulsf$b$0:
 3309               	| Here d1 (==b) is zero.
 3310 03b4 222E 0008 		movel	a6@(8),d1	| get a again to check for non-finiteness
 3311 03b8 6000 0006 		bra	1f
 3312               	Lmulsf$a$0:
 3313 03bc 222E 000C 		movel	a6@(12),d1	| get b again to check for non-finiteness
 3314 03c0 0881 001F 	1:	bclr	IMM (31),d1	| clear sign bit 
 3315 03c4 0C81 7F80 		cmpl	IMM (INFINITY),d1 | and check for a large exponent
 3315      0000 
 3316 03ca 6C00 FC5E 		bge	Lf$inop		| if b is +/-INFINITY or NaN return NaN
 3317 03ce 2007      		movel	d7,d0		| else return signed zero
 3318 03d0 41F9 0000 		PICLEA	SYM (_fpCCR),a0	|
 3318      0000 
 3319 03d6 30BC 0000 		movew	IMM (0),a0@	| 
 3320               	#ifndef __mcoldfire__
 3321 03da 4CDF 00FC 		moveml	sp@+,d2-d7	| 
 3322               	#else
 3323               		moveml	sp@,d2-d7
 3324               		| XXX if frame pointer is ever removed, stack pointer must
 3325               		| be adjusted here.
 3326               	#endif
 3327 03de 4E5E      		unlk	a6		| 
 3328 03e0 4E75      		rts			| 
 3329               	
 3330               	| If a number is denormalized we put an exponent of 1 but do not put the 
 3331               	| hidden bit back into the fraction; instead we shift left until bit 23
68K GAS   			page 60


 3332               	| (the hidden bit) is set, adjusting the exponent accordingly. We do this
 3333               	| to ensure that the product of the fractions is close to 1.
 3334               	Lmulsf$a$den:
 3335 03e2 7401      		movel	IMM (1),d2
 3336 03e4 C085      		andl	d5,d0
 3337 03e6 D080      	1:	addl	d0,d0		| shift a left (until bit 23 is set)
 3338               	#ifndef __mcoldfire__
 3339 03e8 5342      		subw	IMM (1),d2	| and adjust exponent
 3340               	#else
 3341               		subql	IMM (1),d2	| and adjust exponent
 3342               	#endif
 3343 03ea 0800 0017 		btst	IMM (FLT_MANT_DIG-1),d0
 3344 03ee 6600 FF4E 		bne	Lmulsf$1	|
 3345 03f2 6000 FFF2 		bra	1b		| else loop back
 3346               	
 3347               	Lmulsf$b$den:
 3348 03f6 7601      		movel	IMM (1),d3
 3349 03f8 C285      		andl	d5,d1
 3350 03fa D281      	1:	addl	d1,d1		| shift b left until bit 23 is set
 3351               	#ifndef __mcoldfire__
 3352 03fc 5343      		subw	IMM (1),d3	| and adjust exponent
 3353               	#else
 3354               		subql	IMM (1),d3	| and adjust exponent
 3355               	#endif
 3356 03fe 0801 0017 		btst	IMM (FLT_MANT_DIG-1),d1
 3357 0402 6600 FF48 		bne	Lmulsf$2	|
 3358 0406 6000 FFF2 		bra	1b		| else loop back
 3359               	
 3360               	|=============================================================================
 3361               	|                             __divsf3
 3362               	|=============================================================================
 3363               	
 3364               	| float __divsf3(float, float);
 3365               		FUNC(__divsf3)
 3366               	SYM (__divsf3):
 3367               	#ifndef __mcoldfire__
 3368 040a 4E56 0000 		link	a6,IMM (0)
 3369 040e 48E7 3F00 		moveml	d2-d7,sp@-
 3370               	#else
 3371               		link	a6,IMM (-24)
 3372               		moveml	d2-d7,sp@
 3373               	#endif
 3374 0412 202E 0008 		movel	a6@(8),d0		| get a into d0
 3375 0416 222E 000C 		movel	a6@(12),d1		| and b into d1
 3376 041a 2E00      		movel	d0,d7			| d7 will hold the sign of the result
 3377 041c B387      		eorl	d1,d7			|
 3378 041e 0287 8000 		andl	IMM (0x80000000),d7	| 
 3378      0000 
 3379 0424 2C3C 7F80 		movel	IMM (INFINITY),d6	| useful constant (+INFINITY)
 3379      0000 
 3380 042a 2A06      		movel	d6,d5			| another (mask for fraction)
 3381 042c 4685      		notl	d5			|
 3382 042e 283C 0080 		movel	IMM (0x00800000),d4	| this is to put hidden bit back
 3382      0000 
 3383 0434 0880 001F 		bclr	IMM (31),d0		| get rid of a's sign bit '
 3384 0438 2400      		movel	d0,d2			|
 3385 043a 6700 00A6 		beq	Ldivsf$a$0		| branch if a is zero
68K GAS   			page 61


 3386 043e 0881 001F 		bclr	IMM (31),d1		| get rid of b's sign bit '
 3387 0442 2601      		movel	d1,d3			|
 3388 0444 6700 00C6 		beq	Ldivsf$b$0		| branch if b is zero
 3389 0448 B086      		cmpl	d6,d0			| is a big?
 3390 044a 6200 0084 		bhi	Ldivsf$inop		| if a is NaN return NaN
 3391 044e 6700 00CC 		beq	Ldivsf$inf		| if a is INFINITY we have to check b
 3392 0452 B286      		cmpl	d6,d1			| now compare b with INFINITY 
 3393 0454 6200 007A 		bhi	Ldivsf$inop		| if b is NaN return NaN
 3394 0458 6700 0082 		beq	Ldivsf$underflow
 3395               	| Here we have both numbers finite and nonzero (and with no sign bit).
 3396               	| Now we get the exponents into d2 and d3 and normalize the numbers to
 3397               	| ensure that the ratio of the fractions is close to 1. We do this by
 3398               	| making sure that bit #FLT_MANT_DIG-1 (hidden bit) is set.
 3399 045c C486      		andl	d6,d2		| and isolate exponent in d2
 3400 045e 6700 00CC 		beq	Ldivsf$a$den	| if exponent is zero we have a denormalized
 3401 0462 C085      		andl	d5,d0		| and isolate fraction
 3402 0464 8084      		orl	d4,d0		| and put hidden bit back
 3403 0466 4842      		swap	d2		| I like exponents in the first byte
 3404               	#ifndef __mcoldfire__
 3405 0468 EE4A      		lsrw	IMM (7),d2	| 
 3406               	#else
 3407               		lsrl	IMM (7),d2	| 
 3408               	#endif
 3409               	Ldivsf$1:			| 
 3410 046a C686      		andl	d6,d3		|
 3411 046c 6700 00D2 		beq	Ldivsf$b$den	|
 3412 0470 C285      		andl	d5,d1		|
 3413 0472 8284      		orl	d4,d1		|
 3414 0474 4843      		swap	d3		|
 3415               	#ifndef __mcoldfire__
 3416 0476 EE4B      		lsrw	IMM (7),d3	|
 3417               	#else
 3418               		lsrl	IMM (7),d3	|
 3419               	#endif
 3420               	Ldivsf$2:			|
 3421               	#ifndef __mcoldfire__
 3422 0478 9443      		subw	d3,d2		| subtract exponents
 3423 047a 0642 007E 	 	addw	IMM (F_BIAS),d2	| and add bias
 3424               	#else
 3425               		subl	d3,d2		| subtract exponents
 3426               	 	addl	IMM (F_BIAS),d2	| and add bias
 3427               	#endif
 3428               	 
 3429               	| We are now ready to do the division. We have prepared things in such a way
 3430               	| that the ratio of the fractions will be less than 2 but greater than 1/2.
 3431               	| At this point the registers in use are:
 3432               	| d0	holds a (first operand, bit FLT_MANT_DIG=0, bit FLT_MANT_DIG-1=1)
 3433               	| d1	holds b (second operand, bit FLT_MANT_DIG=1)
 3434               	| d2	holds the difference of the exponents, corrected by the bias
 3435               	| d7	holds the sign of the ratio
 3436               	| d4, d5, d6 hold some constants
 3437 047e 2047      		movel	d7,a0		| d6-d7 will hold the ratio of the fractions
 3438 0480 7C00      		movel	IMM (0),d6	| 
 3439 0482 2E06      		movel	d6,d7
 3440               	
 3441 0484 7619      		moveq	IMM (FLT_MANT_DIG+1),d3
 3442 0486 B280      	1:	cmpl	d0,d1		| is a < b?
68K GAS   			page 62


 3443 0488 6200 000A 		bhi	2f		|
 3444 048c 07C6      		bset	d3,d6		| set a bit in d6
 3445 048e 9081      		subl	d1,d0		| if a >= b  a <-- a-b
 3446 0490 6700 0028 		beq	3f		| if a is zero, exit
 3447 0494 D080      	2:	addl	d0,d0		| multiply a by 2
 3448               	#ifndef __mcoldfire__
 3449 0496 51CB FFEE 		dbra	d3,1b
 3450               	#else
 3451               		subql	IMM (1),d3
 3452               		bpl	1b
 3453               	#endif
 3454               	
 3455               	| Now we keep going to set the sticky bit ...
 3456 049a 7618      		moveq	IMM (FLT_MANT_DIG),d3
 3457 049c B280      	1:	cmpl	d0,d1
 3458 049e 6F00 000E 		ble	2f
 3459 04a2 D080      		addl	d0,d0
 3460               	#ifndef __mcoldfire__
 3461 04a4 51CB FFF6 		dbra	d3,1b
 3462               	#else
 3463               		subql	IMM(1),d3
 3464               		bpl	1b
 3465               	#endif
 3466 04a8 7200      		movel	IMM (0),d1
 3467 04aa 6000 000E 		bra	3f
 3468 04ae 7200      	2:	movel	IMM (0),d1
 3469               	#ifndef __mcoldfire__
 3470 04b0 0443 0018 		subw	IMM (FLT_MANT_DIG),d3
 3471 04b4 0643 001F 		addw	IMM (31),d3
 3472               	#else
 3473               		subl	IMM (FLT_MANT_DIG),d3
 3474               		addl	IMM (31),d3
 3475               	#endif
 3476 04b8 07C1      		bset	d3,d1
 3477               	3:
 3478 04ba 2006      		movel	d6,d0		| put the ratio in d0-d1
 3479 04bc 2E08      		movel	a0,d7		| get sign back
 3480               	
 3481               	| Because of the normalization we did before we are guaranteed that 
 3482               	| d0 is smaller than 2^26 but larger than 2^24. Thus bit 26 is not set,
 3483               	| bit 25 could be set, and if it is not set then bit 24 is necessarily set.
 3484 04be 0800 0019 		btst	IMM (FLT_MANT_DIG+1),d0		
 3485 04c2 6700 0006 		beq	1f              | if it is not set, then bit 24 is set
 3486 04c6 E288      		lsrl	IMM (1),d0	|
 3487               	#ifndef __mcoldfire__
 3488 04c8 5242      		addw	IMM (1),d2	|
 3489               	#else
 3490               		addl	IMM (1),d2	|
 3491               	#endif
 3492               	1:
 3493               	| Now round, check for over- and underflow, and exit.
 3494 04ca 7A03      		moveq	IMM (DIVIDE),d5
 3495 04cc 6000 0086 		bra	Lround$exit
 3496               	
 3497               	Ldivsf$inop:
 3498 04d0 7A03      		moveq	IMM (DIVIDE),d5
 3499 04d2 6000 FB56 		bra	Lf$inop
68K GAS   			page 63


 3500               	
 3501               	Ldivsf$overflow:
 3502 04d6 7A03      		moveq	IMM (DIVIDE),d5
 3503 04d8 6000 FB32 		bra	Lf$overflow
 3504               	
 3505               	Ldivsf$underflow:
 3506 04dc 7A03      		moveq	IMM (DIVIDE),d5
 3507 04de 6000 FB3E 		bra	Lf$underflow
 3508               	
 3509               	Ldivsf$a$0:
 3510 04e2 7A03      		moveq	IMM (DIVIDE),d5
 3511               	| If a is zero check to see whether b is zero also. In that case return
 3512               	| NaN; then check if b is NaN, and return NaN also in that case. Else
 3513               	| return a properly signed zero.
 3514 04e4 0281 7FFF 		andl	IMM (0x7fffffff),d1	| clear sign bit and test b
 3514      FFFF 
 3515 04ea 6700 FB3E 		beq	Lf$inop			| if b is also zero return NaN
 3516 04ee 0C81 7F80 		cmpl	IMM (INFINITY),d1	| check for NaN
 3516      0000 
 3517 04f4 6200 FB34 		bhi	Lf$inop			| 
 3518 04f8 2007      		movel	d7,d0			| else return signed zero
 3519 04fa 41F9 0000 		PICLEA	SYM (_fpCCR),a0		|
 3519      0000 
 3520 0500 30BC 0000 		movew	IMM (0),a0@		|
 3521               	#ifndef __mcoldfire__
 3522 0504 4CDF 00FC 		moveml	sp@+,d2-d7		| 
 3523               	#else
 3524               		moveml	sp@,d2-d7		| 
 3525               		| XXX if frame pointer is ever removed, stack pointer must
 3526               		| be adjusted here.
 3527               	#endif
 3528 0508 4E5E      		unlk	a6			| 
 3529 050a 4E75      		rts				| 
 3530               		
 3531               	Ldivsf$b$0:
 3532 050c 7A03      		moveq	IMM (DIVIDE),d5
 3533               	| If we got here a is not zero. Check if a is NaN; in that case return NaN,
 3534               	| else return +/-INFINITY. Remember that a is in d0 with the sign bit 
 3535               	| cleared already.
 3536 050e 0C80 7F80 		cmpl	IMM (INFINITY),d0	| compare d0 with INFINITY
 3536      0000 
 3537 0514 6200 FB14 		bhi	Lf$inop			| if larger it is NaN
 3538 0518 6000 FB1C 		bra	Lf$div$0		| else signal DIVIDE_BY_ZERO
 3539               	
 3540               	Ldivsf$inf:
 3541 051c 7A03      		moveq	IMM (DIVIDE),d5
 3542               	| If a is INFINITY we have to check b
 3543 051e 0C81 7F80 		cmpl	IMM (INFINITY),d1	| compare b with INFINITY 
 3543      0000 
 3544 0524 6C00 FB04 		bge	Lf$inop			| if b is NaN or INFINITY return NaN
 3545 0528 6000 FAE2 		bra	Lf$overflow		| else return overflow
 3546               	
 3547               	| If a number is denormalized we put an exponent of 1 but do not put the 
 3548               	| bit back into the fraction.
 3549               	Ldivsf$a$den:
 3550 052c 7401      		movel	IMM (1),d2
 3551 052e C085      		andl	d5,d0
68K GAS   			page 64


 3552 0530 D080      	1:	addl	d0,d0		| shift a left until bit FLT_MANT_DIG-1 is set
 3553               	#ifndef __mcoldfire__
 3554 0532 5342      		subw	IMM (1),d2	| and adjust exponent
 3555               	#else
 3556               		subl	IMM (1),d2	| and adjust exponent
 3557               	#endif
 3558 0534 0800 0017 		btst	IMM (FLT_MANT_DIG-1),d0
 3559 0538 6600 FF30 		bne	Ldivsf$1
 3560 053c 6000 FFF2 		bra	1b
 3561               	
 3562               	Ldivsf$b$den:
 3563 0540 7601      		movel	IMM (1),d3
 3564 0542 C285      		andl	d5,d1
 3565 0544 D281      	1:	addl	d1,d1		| shift b left until bit FLT_MANT_DIG is set
 3566               	#ifndef __mcoldfire__
 3567 0546 5343      		subw	IMM (1),d3	| and adjust exponent
 3568               	#else
 3569               		subl	IMM (1),d3	| and adjust exponent
 3570               	#endif
 3571 0548 0801 0017 		btst	IMM (FLT_MANT_DIG-1),d1
 3572 054c 6600 FF2A 		bne	Ldivsf$2
 3573 0550 6000 FFF2 		bra	1b
 3574               	
 3575               	Lround$exit:
 3576               	| This is a common exit point for __mulsf3 and __divsf3. 
 3577               	
 3578               	| First check for underlow in the exponent:
 3579               	#ifndef __mcoldfire__
 3580 0554 0C42 FFE7 		cmpw	IMM (-FLT_MANT_DIG-1),d2		
 3581               	#else
 3582               		cmpl	IMM (-FLT_MANT_DIG-1),d2		
 3583               	#endif
 3584 0558 6D00 FAC4 		blt	Lf$underflow	
 3585               	| It could happen that the exponent is less than 1, in which case the 
 3586               	| number is denormalized. In this case we shift right and adjust the 
 3587               	| exponent until it becomes 1 or the fraction is zero (in the latter case 
 3588               	| we signal underflow and return zero).
 3589 055c 7C00      		movel	IMM (0),d6	| d6 is used temporarily
 3590               	#ifndef __mcoldfire__
 3591 055e 0C42 0001 		cmpw	IMM (1),d2	| if the exponent is less than 1 we 
 3592               	#else
 3593               		cmpl	IMM (1),d2	| if the exponent is less than 1 we 
 3594               	#endif
 3595 0562 6C00 001A 		bge	2f		| have to shift right (denormalize)
 3596               	1:
 3597               	#ifndef __mcoldfire__
 3598 0566 5242      		addw	IMM (1),d2	| adjust the exponent
 3599 0568 E288      		lsrl	IMM (1),d0	| shift right once 
 3600 056a E291      		roxrl	IMM (1),d1	|
 3601 056c E296      		roxrl	IMM (1),d6	| d6 collect bits we would lose otherwise
 3602 056e 0C42 0001 		cmpw	IMM (1),d2	| is the exponent 1 already?
 3603               	#else
 3604               		addql	IMM (1),d2	| adjust the exponent
 3605               		lsrl	IMM (1),d6
 3606               		btst	IMM (0),d1
 3607               		beq	11f
 3608               		bset	IMM (31),d6
68K GAS   			page 65


 3609               	11:	lsrl	IMM (1),d1
 3610               		btst	IMM (0),d0
 3611               		beq	10f
 3612               		bset	IMM (31),d1
 3613               	10:	lsrl	IMM (1),d0
 3614               		cmpl	IMM (1),d2	| is the exponent 1 already?
 3615               	#endif
 3616 0572 6700 000A 		beq	2f		| if not loop back
 3617 0576 6000 FFEE 		bra	1b              |
 3618 057a 6000 FAA2 		bra	Lf$underflow	| safety check, shouldn't execute '
 3619 057e 8286      	2:	orl	d6,d1		| this is a trick so we don't lose  '
 3620               					| the extra bits which were flushed right
 3621               	| Now call the rounding routine (which takes care of denormalized numbers):
 3622 0580 41FA 0020 		lea	pc@(Lround$0),a0 | to return from rounding routine
 3623 0584 43F9 0000 		PICLEA	SYM (_fpCCR),a1	| check the rounding mode
 3623      0000 
 3624               	#ifdef __mcoldfire__
 3625               		clrl	d6
 3626               	#endif
 3627 058a 3C29 0006 		movew	a1@(6),d6	| rounding mode in d6
 3628 058e 6700 0146 		beq	Lround$to$nearest
 3629               	#ifndef __mcoldfire__
 3630 0592 0C46 0002 		cmpw	IMM (ROUND_TO_PLUS),d6
 3631               	#else
 3632               		cmpl	IMM (ROUND_TO_PLUS),d6
 3633               	#endif
 3634 0596 6200 0192 		bhi	Lround$to$minus
 3635 059a 6D00 018E 		blt	Lround$to$zero
 3636 059e 6000 018A 		bra	Lround$to$plus
 3637               	Lround$0:
 3638               	| Here we have a correctly rounded result (either normalized or denormalized).
 3639               	
 3640               	| Here we should have either a normalized number or a denormalized one, and
 3641               	| the exponent is necessarily larger or equal to 1 (so we don't have to  '
 3642               	| check again for underflow!). We have to check for overflow or for a 
 3643               	| denormalized number (which also signals underflow).
 3644               	| Check for overflow (i.e., exponent >= 255).
 3645               	#ifndef __mcoldfire__
 3646 05a2 0C42 00FF 		cmpw	IMM (0x00ff),d2
 3647               	#else
 3648               		cmpl	IMM (0x00ff),d2
 3649               	#endif
 3650 05a6 6C00 FA64 		bge	Lf$overflow
 3651               	| Now check for a denormalized number (exponent==0).
 3652 05aa 3402      		movew	d2,d2
 3653 05ac 6700 FA52 		beq	Lf$den
 3654               	1:
 3655               	| Put back the exponents and sign and return.
 3656               	#ifndef __mcoldfire__
 3657 05b0 EF4A      		lslw	IMM (7),d2	| exponent back to fourth byte
 3658               	#else
 3659               		lsll	IMM (7),d2	| exponent back to fourth byte
 3660               	#endif
 3661 05b2 0880 0017 		bclr	IMM (FLT_MANT_DIG-1),d0
 3662 05b6 4840      		swap	d0		| and put back exponent
 3663               	#ifndef __mcoldfire__
 3664 05b8 8042      		orw	d2,d0		| 
68K GAS   			page 66


 3665               	#else
 3666               		orl	d2,d0
 3667               	#endif
 3668 05ba 4840      		swap	d0		|
 3669 05bc 8087      		orl	d7,d0		| and sign also
 3670               	
 3671 05be 41F9 0000 		PICLEA	SYM (_fpCCR),a0
 3671      0000 
 3672 05c4 30BC 0000 		movew	IMM (0),a0@
 3673               	#ifndef __mcoldfire__
 3674 05c8 4CDF 00FC 		moveml	sp@+,d2-d7
 3675               	#else
 3676               		moveml	sp@,d2-d7
 3677               		| XXX if frame pointer is ever removed, stack pointer must
 3678               		| be adjusted here.
 3679               	#endif
 3680 05cc 4E5E      		unlk	a6
 3681 05ce 4E75      		rts
 3682               	
 3683               	|=============================================================================
 3684               	|                             __negsf2
 3685               	|=============================================================================
 3686               	
 3687               	| This is trivial and could be shorter if we didn't bother checking for NaN '
 3688               	| and +/-INFINITY.
 3689               	
 3690               	| float __negsf2(float);
 3691               		FUNC(__negsf2)
 3692               	SYM (__negsf2):
 3693               	#ifndef __mcoldfire__
 3694 05d0 4E56 0000 		link	a6,IMM (0)
 3695 05d4 48E7 3F00 		moveml	d2-d7,sp@-
 3696               	#else
 3697               		link	a6,IMM (-24)
 3698               		moveml	d2-d7,sp@
 3699               	#endif
 3700 05d8 7A04      		moveq	IMM (NEGATE),d5
 3701 05da 202E 0008 		movel	a6@(8),d0	| get number to negate in d0
 3702 05de 0840 001F 		bchg	IMM (31),d0	| negate
 3703 05e2 2200      		movel	d0,d1		| make a positive copy
 3704 05e4 0881 001F 		bclr	IMM (31),d1	|
 3705 05e8 4A81      		tstl	d1		| check for zero
 3706 05ea 6700 002E 		beq	2f		| if zero (either sign) return +zero
 3707 05ee 0C81 7F80 		cmpl	IMM (INFINITY),d1 | compare to +INFINITY
 3707      0000 
 3708 05f4 6D00 0012 		blt	1f		|
 3709 05f8 6200 FA30 		bhi	Lf$inop		| if larger (fraction not zero) is NaN
 3710 05fc 2E00      		movel	d0,d7		| else get sign and return INFINITY
 3711 05fe 0287 8000 		andl	IMM (0x80000000),d7
 3711      0000 
 3712 0604 6000 FA06 		bra	Lf$infty		
 3713 0608 41F9 0000 	1:	PICLEA	SYM (_fpCCR),a0
 3713      0000 
 3714 060e 30BC 0000 		movew	IMM (0),a0@
 3715               	#ifndef __mcoldfire__
 3716 0612 4CDF 00FC 		moveml	sp@+,d2-d7
 3717               	#else
68K GAS   			page 67


 3718               		moveml	sp@,d2-d7
 3719               		| XXX if frame pointer is ever removed, stack pointer must
 3720               		| be adjusted here.
 3721               	#endif
 3722 0616 4E5E      		unlk	a6
 3723 0618 4E75      		rts
 3724 061a 0880 001F 	2:	bclr	IMM (31),d0
 3725 061e 6000 FFE8 		bra	1b
 3726               	
 3727               	|=============================================================================
 3728               	|                             __cmpsf2
 3729               	|=============================================================================
 3730               	
 3731               	GREATER =  1
 3732               	LESS    = -1
 3733               	EQUAL   =  0
 3734               	
 3735               	| int __cmpsf2_internal(float, float, int);
 3736               	SYM (__cmpsf2_internal):
 3737               	#ifndef __mcoldfire__
 3738 0622 4E56 0000 		link	a6,IMM (0)
 3739 0626 48E7 3F00 		moveml	d2-d7,sp@- 	| save registers
 3740               	#else
 3741               		link	a6,IMM (-24)
 3742               		moveml	d2-d7,sp@
 3743               	#endif
 3744 062a 7A05      		moveq	IMM (COMPARE),d5
 3745 062c 202E 0008 		movel	a6@(8),d0	| get first operand
 3746 0630 222E 000C 		movel	a6@(12),d1	| get second operand
 3747               	| Check if either is NaN, and in that case return garbage and signal
 3748               	| INVALID_OPERATION. Check also if either is zero, and clear the signs
 3749               	| if necessary.
 3750 0634 2C00      		movel	d0,d6
 3751 0636 0280 7FFF 		andl	IMM (0x7fffffff),d0
 3751      FFFF 
 3752 063c 6700 0062 		beq	Lcmpsf$a$0
 3753 0640 0C80 7F80 		cmpl	IMM (0x7f800000),d0
 3753      0000 
 3754 0646 6200 0068 		bhi	Lcmpf$inop
 3755               	Lcmpsf$1:
 3756 064a 2E01      		movel	d1,d7
 3757 064c 0281 7FFF 		andl	IMM (0x7fffffff),d1
 3757      FFFF 
 3758 0652 6700 0054 		beq	Lcmpsf$b$0
 3759 0656 0C81 7F80 		cmpl	IMM (0x7f800000),d1
 3759      0000 
 3760 065c 6200 0052 		bhi	Lcmpf$inop
 3761               	Lcmpsf$2:
 3762               	| Check the signs
 3763 0660 BD87      		eorl	d6,d7
 3764 0662 6A00 000C 		bpl	1f
 3765               	| If the signs are not equal check if a >= 0
 3766 0666 4A86      		tstl	d6
 3767 0668 6A00 0022 		bpl	Lcmpsf$a$gt$b	| if (a >= 0 && b < 0) => a > b
 3768 066c 6B00 0028 		bmi	Lcmpsf$b$gt$a	| if (a < 0 && b >= 0) => a < b
 3769               	1:
 3770               	| If the signs are equal check for < 0
68K GAS   			page 68


 3771 0670 4A86      		tstl	d6
 3772 0672 6A00 0004 		bpl	1f
 3773               	| If both are negative exchange them
 3774               	#ifndef __mcoldfire__
 3775 0676 C141      		exg	d0,d1
 3776               	#else
 3777               		movel	d0,d7
 3778               		movel	d1,d0
 3779               		movel	d7,d1
 3780               	#endif
 3781               	1:
 3782               	| Now that they are positive we just compare them as longs (does this also
 3783               	| work for denormalized numbers?).
 3784 0678 B280      		cmpl	d0,d1
 3785 067a 6200 001A 		bhi	Lcmpsf$b$gt$a	| |b| > |a|
 3786 067e 6600 000C 		bne	Lcmpsf$a$gt$b	| |b| < |a|
 3787               	| If we got here a == b.
 3788 0682 7000      		movel	IMM (EQUAL),d0
 3789               	#ifndef __mcoldfire__
 3790 0684 4CDF 00FC 		moveml	sp@+,d2-d7 	| put back the registers
 3791               	#else
 3792               		moveml	sp@,d2-d7
 3793               	#endif
 3794 0688 4E5E      		unlk	a6
 3795 068a 4E75      		rts
 3796               	Lcmpsf$a$gt$b:
 3797 068c 7001      		movel	IMM (GREATER),d0
 3798               	#ifndef __mcoldfire__
 3799 068e 4CDF 00FC 		moveml	sp@+,d2-d7 	| put back the registers
 3800               	#else
 3801               		moveml	sp@,d2-d7
 3802               		| XXX if frame pointer is ever removed, stack pointer must
 3803               		| be adjusted here.
 3804               	#endif
 3805 0692 4E5E      		unlk	a6
 3806 0694 4E75      		rts
 3807               	Lcmpsf$b$gt$a:
 3808 0696 70FF      		movel	IMM (LESS),d0
 3809               	#ifndef __mcoldfire__
 3810 0698 4CDF 00FC 		moveml	sp@+,d2-d7 	| put back the registers
 3811               	#else
 3812               		moveml	sp@,d2-d7
 3813               		| XXX if frame pointer is ever removed, stack pointer must
 3814               		| be adjusted here.
 3815               	#endif
 3816 069c 4E5E      		unlk	a6
 3817 069e 4E75      		rts
 3818               	
 3819               	Lcmpsf$a$0:	
 3820 06a0 0886 001F 		bclr	IMM (31),d6
 3821 06a4 6000 FFA4 		bra	Lcmpsf$1
 3822               	Lcmpsf$b$0:
 3823 06a8 0887 001F 		bclr	IMM (31),d7
 3824 06ac 6000 FFB2 		bra	Lcmpsf$2
 3825               	
 3826               	Lcmpf$inop:
 3827 06b0 202E 0010 		movl	a6@(16),d0
68K GAS   			page 69


 3828 06b4 7E11      		moveq	IMM (INEXACT_RESULT+INVALID_OPERATION),d7
 3829 06b6 7C01      		moveq	IMM (SINGLE_FLOAT),d6
 3830 06b8 4EF9 0000 		PICJUMP	$_exception_handler
 3830      0000 
 3831               	
 3832               	| int __cmpsf2(float, float);
 3833               		FUNC(__cmpsf2)
 3834               	SYM (__cmpsf2):
 3835 06be 4E56 0000 		link	a6,IMM (0)
 3836 06c2 4878 0001 		pea	1
 3837 06c6 2F2E 000C 		movl	a6@(12),sp@-
 3838 06ca 2F2E 0008 		movl	a6@(8),sp@-
 3839 06ce 6100 FF52 		PICCALL SYM (__cmpsf2_internal)
 3840 06d2 4E5E      		unlk	a6
 3841 06d4 4E75      		rts
 3842               	
 3843               	|=============================================================================
 3844               	|                           rounding routines
 3845               	|=============================================================================
 3846               	
 3847               	| The rounding routines expect the number to be normalized in registers
 3848               	| d0-d1, with the exponent in register d2. They assume that the 
 3849               	| exponent is larger or equal to 1. They return a properly normalized number
 3850               	| if possible, and a denormalized number otherwise. The exponent is returned
 3851               	| in d2.
 3852               	
 3853               	Lround$to$nearest:
 3854               	| We now normalize as suggested by D. Knuth ("Seminumerical Algorithms"):
 3855               	| Here we assume that the exponent is not too small (this should be checked
 3856               	| before entering the rounding routine), but the number could be denormalized.
 3857               	
 3858               	| Check for denormalized numbers:
 3859 06d6 0800 0018 	1:	btst	IMM (FLT_MANT_DIG),d0
 3860 06da 6600 0012 		bne	2f		| if set the number is normalized
 3861               	| Normalize shifting left until bit #FLT_MANT_DIG is set or the exponent 
 3862               	| is one (remember that a denormalized number corresponds to an 
 3863               	| exponent of -F_BIAS+1).
 3864               	#ifndef __mcoldfire__
 3865 06de 0C42 0001 		cmpw	IMM (1),d2	| remember that the exponent is at least one
 3866               	#else
 3867               		cmpl	IMM (1),d2	| remember that the exponent is at least one
 3868               	#endif
 3869 06e2 6700 000A 	 	beq	2f		| an exponent of one means denormalized
 3870 06e6 D281      		addl	d1,d1		| else shift and adjust the exponent
 3871 06e8 D180      		addxl	d0,d0		|
 3872               	#ifndef __mcoldfire__
 3873 06ea 51CA FFEA 		dbra	d2,1b		|
 3874               	#else
 3875               		subql	IMM (1),d2
 3876               		bpl	1b
 3877               	#endif
 3878               	2:
 3879               	| Now round: we do it as follows: after the shifting we can write the
 3880               	| fraction part as f + delta, where 1 < f < 2^25, and 0 <= delta <= 2.
 3881               	| If delta < 1, do nothing. If delta > 1, add 1 to f. 
 3882               	| If delta == 1, we make sure the rounded number will be even (odd?) 
 3883               	| (after shifting).
68K GAS   			page 70


 3884 06ee 0800 0000 		btst	IMM (0),d0	| is delta < 1?
 3885 06f2 6700 001A 		beq	2f		| if so, do not do anything
 3886 06f6 4A81      		tstl	d1		| is delta == 1?
 3887 06f8 6600 0010 		bne	1f		| if so round to even
 3888 06fc 2200      		movel	d0,d1		| 
 3889 06fe 0281 0000 		andl	IMM (2),d1	| bit 1 is the last significant bit
 3889      0002 
 3890 0704 D081      		addl	d1,d0		| 
 3891 0706 6000 0006 		bra	2f		| 
 3892 070a 7201      	1:	movel	IMM (1),d1	| else add 1 
 3893 070c D081      		addl	d1,d0		|
 3894               	| Shift right once (because we used bit #FLT_MANT_DIG!).
 3895 070e E288      	2:	lsrl	IMM (1),d0		
 3896               	| Now check again bit #FLT_MANT_DIG (rounding could have produced a
 3897               	| 'fraction overflow' ...).
 3898 0710 0800 0018 		btst	IMM (FLT_MANT_DIG),d0	
 3899 0714 6700 0006 		beq	1f
 3900 0718 E288      		lsrl	IMM (1),d0
 3901               	#ifndef __mcoldfire__
 3902 071a 5242      		addw	IMM (1),d2
 3903               	#else
 3904               		addql	IMM (1),d2
 3905               	#endif
 3906               	1:
 3907               	| If bit #FLT_MANT_DIG-1 is clear we have a denormalized number, so we 
 3908               	| have to put the exponent to zero and return a denormalized number.
 3909 071c 0800 0017 		btst	IMM (FLT_MANT_DIG-1),d0
 3910 0720 6700 0004 		beq	1f
 3911 0724 4ED0      		jmp	a0@
 3912 0726 7400      	1:	movel	IMM (0),d2
 3913 0728 4ED0      		jmp	a0@
 3914               	
 3915               	Lround$to$zero:
 3916               	Lround$to$plus:
 3917               	Lround$to$minus:
 3918 072a 4ED0      		jmp	a0@
 3919               	#endif /* L_float */
 3920               	
 3921               	| gcc expects the routines __eqdf2, __nedf2, __gtdf2, __gedf2,
 3922               	| __ledf2, __ltdf2 to all return the same value as a direct call to
 3923               	| __cmpdf2 would.  In this implementation, each of these routines
 3924               	| simply calls __cmpdf2.  It would be more efficient to give the
 3925               	| __cmpdf2 routine several names, but separating them out will make it
 3926               	| easier to write efficient versions of these routines someday.
 3927               	| If the operands recompare unordered unordered __gtdf2 and __gedf2 return -1.
 3928               	| The other routines return 1.
 3929               	
 3930               	#ifdef  L_eqdf2
 3931               		.text
 3932               		FUNC(__eqdf2)
 3933               		.globl	SYM (__eqdf2)
 3934               	SYM (__eqdf2):
 3935               		link	a6,IMM (0)
 3936               		pea	1
 3937               		movl	a6@(20),sp@-
 3938               		movl	a6@(16),sp@-
 3939               		movl	a6@(12),sp@-
68K GAS   			page 71


 3940               		movl	a6@(8),sp@-
 3941               		PICCALL	SYM (__cmpdf2_internal)
 3942               		unlk	a6
 3943               		rts
 3944               	#endif /* L_eqdf2 */
 3945               	
 3946               	#ifdef  L_nedf2
 3947               		.text
 3948               		FUNC(__nedf2)
 3949               		.globl	SYM (__nedf2)
 3950               	SYM (__nedf2):
 3951               		link	a6,IMM (0)
 3952               		pea	1
 3953               		movl	a6@(20),sp@-
 3954               		movl	a6@(16),sp@-
 3955               		movl	a6@(12),sp@-
 3956               		movl	a6@(8),sp@-
 3957               		PICCALL	SYM (__cmpdf2_internal)
 3958               		unlk	a6
 3959               		rts
 3960               	#endif /* L_nedf2 */
 3961               	
 3962               	#ifdef  L_gtdf2
 3963               		.text
 3964               		FUNC(__gtdf2)
 3965               		.globl	SYM (__gtdf2)
 3966               	SYM (__gtdf2):
 3967               		link	a6,IMM (0)
 3968               		pea	-1
 3969               		movl	a6@(20),sp@-
 3970               		movl	a6@(16),sp@-
 3971               		movl	a6@(12),sp@-
 3972               		movl	a6@(8),sp@-
 3973               		PICCALL	SYM (__cmpdf2_internal)
 3974               		unlk	a6
 3975               		rts
 3976               	#endif /* L_gtdf2 */
 3977               	
 3978               	#ifdef  L_gedf2
 3979               		.text
 3980               		FUNC(__gedf2)
 3981               		.globl	SYM (__gedf2)
 3982               	SYM (__gedf2):
 3983               		link	a6,IMM (0)
 3984               		pea	-1
 3985               		movl	a6@(20),sp@-
 3986               		movl	a6@(16),sp@-
 3987               		movl	a6@(12),sp@-
 3988               		movl	a6@(8),sp@-
 3989               		PICCALL	SYM (__cmpdf2_internal)
 3990               		unlk	a6
 3991               		rts
 3992               	#endif /* L_gedf2 */
 3993               	
 3994               	#ifdef  L_ltdf2
 3995               		.text
 3996               		FUNC(__ltdf2)
68K GAS   			page 72


 3997               		.globl	SYM (__ltdf2)
 3998               	SYM (__ltdf2):
 3999               		link	a6,IMM (0)
 4000               		pea	1
 4001               		movl	a6@(20),sp@-
 4002               		movl	a6@(16),sp@-
 4003               		movl	a6@(12),sp@-
 4004               		movl	a6@(8),sp@-
 4005               		PICCALL	SYM (__cmpdf2_internal)
 4006               		unlk	a6
 4007               		rts
 4008               	#endif /* L_ltdf2 */
 4009               	
 4010               	#ifdef  L_ledf2
 4011               		.text
 4012               		FUNC(__ledf2)
 4013               		.globl	SYM (__ledf2)
 4014               	SYM (__ledf2):
 4015               		link	a6,IMM (0)
 4016               		pea	1
 4017               		movl	a6@(20),sp@-
 4018               		movl	a6@(16),sp@-
 4019               		movl	a6@(12),sp@-
 4020               		movl	a6@(8),sp@-
 4021               		PICCALL	SYM (__cmpdf2_internal)
 4022               		unlk	a6
 4023               		rts
 4024               	#endif /* L_ledf2 */
 4025               	
 4026               	| The comments above about __eqdf2, et. al., also apply to __eqsf2,
 4027               	| et. al., except that the latter call __cmpsf2 rather than __cmpdf2.
 4028               	
 4029               	#ifdef  L_eqsf2
 4030               		.text
 4031               		FUNC(__eqsf2)
 4032               		.globl	SYM (__eqsf2)
 4033               	SYM (__eqsf2):
 4034               		link	a6,IMM (0)
 4035               		pea	1
 4036               		movl	a6@(12),sp@-
 4037               		movl	a6@(8),sp@-
 4038               		PICCALL	SYM (__cmpsf2_internal)
 4039               		unlk	a6
 4040               		rts
 4041               	#endif /* L_eqsf2 */
 4042               	
 4043               	#ifdef  L_nesf2
 4044               		.text
 4045               		FUNC(__nesf2)
 4046               		.globl	SYM (__nesf2)
 4047               	SYM (__nesf2):
 4048               		link	a6,IMM (0)
 4049               		pea	1
 4050               		movl	a6@(12),sp@-
 4051               		movl	a6@(8),sp@-
 4052               		PICCALL	SYM (__cmpsf2_internal)
 4053               		unlk	a6
68K GAS   			page 73


 4054               		rts
 4055               	#endif /* L_nesf2 */
 4056               	
 4057               	#ifdef  L_gtsf2
 4058               		.text
 4059               		FUNC(__gtsf2)
 4060               		.globl	SYM (__gtsf2)
 4061               	SYM (__gtsf2):
 4062               		link	a6,IMM (0)
 4063               		pea	-1
 4064               		movl	a6@(12),sp@-
 4065               		movl	a6@(8),sp@-
 4066               		PICCALL	SYM (__cmpsf2_internal)
 4067               		unlk	a6
 4068               		rts
 4069               	#endif /* L_gtsf2 */
 4070               	
 4071               	#ifdef  L_gesf2
 4072               		.text
 4073               		FUNC(__gesf2)
 4074               		.globl	SYM (__gesf2)
 4075               	SYM (__gesf2):
 4076               		link	a6,IMM (0)
 4077               		pea	-1
 4078               		movl	a6@(12),sp@-
 4079               		movl	a6@(8),sp@-
 4080               		PICCALL	SYM (__cmpsf2_internal)
 4081               		unlk	a6
 4082               		rts
 4083               	#endif /* L_gesf2 */
 4084               	
 4085               	#ifdef  L_ltsf2
 4086               		.text
 4087               		FUNC(__ltsf2)
 4088               		.globl	SYM (__ltsf2)
 4089               	SYM (__ltsf2):
 4090               		link	a6,IMM (0)
 4091               		pea	1
 4092               		movl	a6@(12),sp@-
 4093               		movl	a6@(8),sp@-
 4094               		PICCALL	SYM (__cmpsf2_internal)
 4095               		unlk	a6
 4096               		rts
 4097               	#endif /* L_ltsf2 */
 4098               	
 4099               	#ifdef  L_lesf2
 4100               		.text
 4101               		FUNC(__lesf2)
 4102               		.globl	SYM (__lesf2)
 4103               	SYM (__lesf2):
 4104               		link	a6,IMM (0)
 4105               		pea	1
 4106               		movl	a6@(12),sp@-
 4107               		movl	a6@(8),sp@-
 4108               		PICCALL	SYM (__cmpsf2_internal)
 4109               		unlk	a6
 4110               		rts
68K GAS   			page 74


 4111               	#endif /* L_lesf2 */
 4112               	
 4113               	#if defined (__ELF__) && defined (__linux__)
 4114               		/* Make stack non-executable for ELF linux targets.  */
 4115               		.section	.note.GNU-stack,"",@progbits
68K GAS   			page 75


DEFINED SYMBOLS
           lb1sf68.S:2542   *ABS*:ffffffff QUIET_NaN
           lb1sf68.S:2543   *ABS*:7f800001 SIGNL_NaN
           lb1sf68.S:2544   *ABS*:7f800000 INFINITY
           lb1sf68.S:2546   *ABS*:000000ff F_MAX_EXP
           lb1sf68.S:2547   *ABS*:0000007e F_BIAS
           lb1sf68.S:2548   *ABS*:00000081 FLT_MAX_EXP
           lb1sf68.S:2549   *ABS*:ffffff83 FLT_MIN_EXP
           lb1sf68.S:2550   *ABS*:00000018 FLT_MANT_DIG
           lb1sf68.S:2552   *ABS*:00000001 INEXACT_RESULT
           lb1sf68.S:2553   *ABS*:00000002 UNDERFLOW
           lb1sf68.S:2554   *ABS*:00000004 OVERFLOW
           lb1sf68.S:2555   *ABS*:00000008 DIVIDE_BY_ZERO
           lb1sf68.S:2556   *ABS*:00000010 INVALID_OPERATION
           lb1sf68.S:2558   *ABS*:00000001 SINGLE_FLOAT
           lb1sf68.S:2560   *ABS*:00000000 NOOP
           lb1sf68.S:2561   *ABS*:00000001 ADD
           lb1sf68.S:2562   *ABS*:00000002 MULTIPLY
           lb1sf68.S:2563   *ABS*:00000003 DIVIDE
           lb1sf68.S:2564   *ABS*:00000004 NEGATE
           lb1sf68.S:2565   *ABS*:00000005 COMPARE
           lb1sf68.S:2566   *ABS*:00000006 EXTENDSFDF
           lb1sf68.S:2567   *ABS*:00000007 TRUNCDFSF
           lb1sf68.S:2569   *ABS*:ffffffff UNKNOWN
           lb1sf68.S:2570   *ABS*:00000000 ROUND_TO_NEAREST
           lb1sf68.S:2571   *ABS*:00000001 ROUND_TO_ZERO
           lb1sf68.S:2572   *ABS*:00000002 ROUND_TO_PLUS
           lb1sf68.S:2573   *ABS*:00000003 ROUND_TO_MINUS
           lb1sf68.S:2664   .text:0000004e __addsf3
           lb1sf68.S:2655   .text:00000048 __subsf3
           lb1sf68.S:3151   .text:000002de __mulsf3
           lb1sf68.S:3366   .text:0000040a __divsf3
           lb1sf68.S:3692   .text:000005d0 __negsf2
           lb1sf68.S:3834   .text:000006be __cmpsf2
           lb1sf68.S:3736   .text:00000622 __cmpsf2_internal
           lb1sf68.S:2591   .text:00000000 Lf$den
           lb1sf68.S:2598   .text:0000000c Lf$infty
           lb1sf68.S:2599   .text:0000000c Lf$overflow
           lb1sf68.S:2607   .text:0000001e Lf$underflow
           lb1sf68.S:2614   .text:0000002a Lf$inop
           lb1sf68.S:2621   .text:00000036 Lf$div$0
           lb1sf68.S:3048   .text:0000021a Laddsf$b
           lb1sf68.S:3057   .text:00000236 Laddsf$a
           lb1sf68.S:3033   .text:00000208 Laddsf$a$den
           lb1sf68.S:3106   .text:00000288 Laddsf$nf
           lb1sf68.S:2695   .text:00000090 Laddsf$1
           lb1sf68.S:3038   .text:00000210 Laddsf$b$den
           lb1sf68.S:2706   .text:000000a6 Laddsf$2
           lb1sf68.S:2848   .text:00000124 Laddsf$3
           lb1sf68.S:3017   .text:000001f2 Laddsf$b$small
           lb1sf68.S:3003   .text:000001dc Laddsf$a$small
           lb1sf68.S:2944   .text:0000018c Lsubsf$0
           lb1sf68.S:2923   .text:00000170 Laddsf$4
           lb1sf68.S:3853   .text:000006d6 Lround$to$nearest
           lb1sf68.S:3917   .text:0000072a Lround$to$minus
           lb1sf68.S:3915   .text:0000072a Lround$to$zero
           lb1sf68.S:3916   .text:0000072a Lround$to$plus
68K GAS   			page 76


           lb1sf68.S:3078   .text:0000026e Laddsf$ret
           lb1sf68.S:2988   .text:000001ce Lsubsf$1
           lb1sf68.S:3094   .text:00000282 Laddsf$ret$den
           lb1sf68.S:3312   .text:000003bc Lmulsf$a$0
           lb1sf68.S:3308   .text:000003b4 Lmulsf$b$0
           lb1sf68.S:3290   .text:0000039c Lmulsf$inop
           lb1sf68.S:3298   .text:000003a8 Lmulsf$inf
           lb1sf68.S:3294   .text:000003a2 Lmulsf$overflow
           lb1sf68.S:3334   .text:000003e2 Lmulsf$a$den
           lb1sf68.S:3192   .text:0000033e Lmulsf$1
           lb1sf68.S:3347   .text:000003f6 Lmulsf$b$den
           lb1sf68.S:3203   .text:0000034c Lmulsf$2
           lb1sf68.S:3575   .text:00000554 Lround$exit
           lb1sf68.S:3509   .text:000004e2 Ldivsf$a$0
           lb1sf68.S:3531   .text:0000050c Ldivsf$b$0
           lb1sf68.S:3497   .text:000004d0 Ldivsf$inop
           lb1sf68.S:3540   .text:0000051c Ldivsf$inf
           lb1sf68.S:3505   .text:000004dc Ldivsf$underflow
           lb1sf68.S:3549   .text:0000052c Ldivsf$a$den
           lb1sf68.S:3409   .text:0000046a Ldivsf$1
           lb1sf68.S:3562   .text:00000540 Ldivsf$b$den
           lb1sf68.S:3420   .text:00000478 Ldivsf$2
           lb1sf68.S:3501   .text:000004d6 Ldivsf$overflow
           lb1sf68.S:3637   .text:000005a2 Lround$0
           lb1sf68.S:3731   *ABS*:00000001 GREATER
           lb1sf68.S:3732   *ABS*:ffffffff LESS
           lb1sf68.S:3733   *ABS*:00000000 EQUAL
           lb1sf68.S:3819   .text:000006a0 Lcmpsf$a$0
           lb1sf68.S:3826   .text:000006b0 Lcmpf$inop
           lb1sf68.S:3755   .text:0000064a Lcmpsf$1
           lb1sf68.S:3822   .text:000006a8 Lcmpsf$b$0
           lb1sf68.S:3761   .text:00000660 Lcmpsf$2
           lb1sf68.S:3796   .text:0000068c Lcmpsf$a$gt$b
           lb1sf68.S:3807   .text:00000696 Lcmpsf$b$gt$a

UNDEFINED SYMBOLS
_fpCCR
$_exception_handler
