#include "../nkc/nkc.h"
#include "../nkc/macros.h"

#ifdef M68000
.macro LEA32A0 var
	move.l #\var,-(%sp)
	move.l #1f,-(%sp)
	bsr _LEA32A0
1:	addq.l #8,%sp
.endm
#endif


	.text
	.global _start,__rexit,__main,__getErrno
/*	
;
; Main program
;
*/
_start:

	// save old stackvalue

#ifdef M68000
	LEA32A0 _OLDSTACK
#else	
	lea _OLDSTACK(%pc),%a0
#endif
	move.l %sp,(%a0)	



#ifdef M68000
       writeln msg00
       
       writeln msg08
       LEA32A0 _start

#else
       writeln msg00(%pc)
       
       writeln msg08(%pc)
       lea _start(%pc),%a0
#endif


       prthex8 %a0


#ifdef M68000
       writeln buffer
       crlf
       writeln msg09
       LEA32A0 _sbss
#else
       writeln buffer(%pc)
       crlf
       writeln msg09(%pc)
	lea _sbss(%pc),%a0	// 
#endif

       prthex8 %a0

#ifdef M68000
       writeln buffer	
       crlf
       writeln msg24
	LEA32A0 _ebss
#else
       writeln buffer(%pc)	
       crlf
       writeln msg24(%pc)
	lea _ebss(%pc),%a0	// 
#endif

       prthex8 %a0

#ifdef M68000
       writeln buffer
#else
       writeln buffer(%pc)
#endif
       crlf	
       waitcr

/* Clear errno system variable */
#ifdef M68000
	LEA32A0 errno
#else
	lea errno(%pc),%a0
#endif
	movel	#0, (%a0)

       	/*
       bsr.l relocate		// do program relocation 1st
       cmp #0,%d2		// continue if successful
       bne __end		// exit otherwise
       				// from now on all addresses are relocated !
     				
       writeln msg15(%pc)
       
       waitcr
       */
/*	
;
; Clear BSS
;
*/

#ifdef M68000		
	lea _sbss,%a0	        
        lea _ebss,%a1	
#else
	lea _sbss(%pc),%a0	        
        lea _ebss(%pc),%a1	
#endif
       
       /* 
        writeln msg09(%pc)
        prthex8 %a0
        writeln buffer(%pc)
        crlf
        prthex8 %a1
        writeln buffer(%pc)
        crlf
        waitcr
        */
LD2:
	movel	#0, (%a0)+
	cmpal	%a0, %a1
	bhi	LD2
	
#ifdef M68000
	writeln msg01
#else
	writeln msg01(%pc)
#endif

/*
;
;  Initialize HEAP
;
*/
#ifdef M68000
	lea _ebss,%a0		/* save _HEAP variable (HEAP base) */
	move.l #0,(%a0)	
	lea _HEAP,%a1
	move.l %a0,(%a1)	/* _HEAP is already relocated, but... */
	
	moveq #62,%d7            /* get _RAM_TOP from JADOS */
        trap #6
        move.l %a0,%d0
        lea _RAM_TOP,%a0
        move.l %d0,(%a0)
       
       writeln msg25       
       prthex8 %d0
       writeln buffer
       crlf	
       waitcr		  /* RAM_TOP at: ... */
       /*
       	prthex8 _HEAP

       	writeln buffer
       	writeln TAB
       	prthex8 _RAM_TOP
       	writeln buffer
       	crlf

       	*/
       	        
       	writeln msg02	/* HEAP calculated ... */
	bsr mm_init        	/* init memory management */
#else
	lea _ebss(%pc),%a0		/* save _HEAP variable (HEAP base) */
	move.l #0,(%a0)	
	lea _HEAP(%pc),%a1
	move.l %a0,(%a1)	/* _HEAP is already relocated, but... */
	
	moveq #62,%d7            /* get _RAM_TOP from JADOS */
        trap #6
        move.l %a0,%d0
        lea _RAM_TOP(%pc),%a0
        move.l %d0,(%a0)
       
       writeln msg25(%pc)       
       prthex8 %d0
       writeln buffer(%pc)
       crlf	
       waitcr
       /*
       	prthex8 _HEAP(%pc)
       	writeln buffer(%pc)
       	writeln TAB(%pc)
       	prthex8 _RAM_TOP(%pc)
       	writeln buffer(%pc)
       	crlf
       	*/
       	
       
       	writeln msg02(%pc)
	bsr mm_init        	/* init memory management */
#endif	
/*	
;x
; Get command line  
; --> von JADOS mit getparm holen (bis zu 4 Parameter können übergeben werden)
*/
	writeln DOT		/* . */
	waitcr
	moveq #25,%d7
	trap #6
	/* %a0 zeigt auf Null-Terminierten Parameter String  */	
#ifdef M68000
	lea _CMDLINE,%a1				
#else
	lea _CMDLINE(%pc),%a1				
#endif
LD1:	move.b (%a0)+,(%a1)+	/* copy command line */
        bne LD1
        move.l #0,(%a1)		/* terminating NULL */
        
#ifdef M68000
        lea _CMDLINE,%a1
        lea _cmdline,%a0	/* set command line in argset.c */
#else
        lea _CMDLINE(%pc),%a1
        lea _cmdline(%pc),%a0	/* set command line in argset.c */
#endif
	move.l %a1,(%a0)
	  
/*	
;
; Execute startup routines
;
*/
/*
startup/envset.c:#pragma startup envset 19
startup/argset.c:#pragma startup argset 19
string/mbtowc.c:#pragma startup mbinit 120
string/wctomb.c:#pragma startup wcinit 120
io/fclose.c:#pragma startup fileinit 120
procont/signal.c:#pragma startup siginit 128
*/

/*
	bsr.l envset	; Umgebungsvariable setzen 	(Speicher allokieren 4 Bytes in _env_arr)	
	bsr.l argset	; argc, argv holen 		(Speicher allokieren 4 Bytes in _argv_arr)
	bsr.l mbinit	; -> string/mbtowc.c
	bsr.l wcinit	; -> string/wctomb.c
	bsr.l fileinit	; -> io/fclose.c (ruft _ll_init in nkc/llopen.S)
	bsr.l siginit	; -> procont/signal.c
*/

#ifdef M68000
	writeln DOT		
	waitcr

	jsr envset			
	writeln DOT
	waitcr

	jsr argset	
	writeln DOT
	waitcr

	jsr mbinit
	writeln DOT
	waitcr

	jsr wcinit	
	writeln DOT
	waitcr

	jsr fileinit
	writeln DOT
	waitcr

	jsr timerinit
	writeln DOT
	waitcr

	jsr siginit
	writeln DOT
	waitcr
#else
	bsr envset
	bsr argset
	bsr mbinit	
	bsr wcinit
	bsr fileinit
	bsr timerinit
	bsr siginit
#endif
/*	
;
; Call main
;
*/	
#ifdef M68000	
	writeln msg05
	move.l (_env_arr),-(%sp)
	move.l (_argv_arr),-(%sp)
	move.l (_argc),-(%sp)		
#else
	writeln msg05(%pc)
	move.l (_env_arr,%pc),-(%sp)
	move.l (_argv_arr,%pc),-(%sp)
	move.l (_argc,%pc),-(%sp)		
#endif
	crlf
	waitcr
#ifdef M68000
	jsr main
#else	
	bsr.l	main		/* Hauptprogramm aufrufen */
#endif

	add.l #12,%sp		/* Stack aufräumen */
	bra __end	

/* int * __getErrno(void); */

__getErrno:
	move.l errno,%d0
	rts
/*
;
; exit/abort comes here 
;	(buggy, abort should not execute rundown routines in standard C)
*/
__rexit:

#ifdef M68000
	writeln msg23
	crlf      	
       	//waitcr	
       	
       	
       	// restore stack
   	LEA32A0 _OLDSTACK
	move.l (%a0),%sp
	//bra __end // do not execute rundown routines

#else
	writeln msg23(%pc) 
	crlf      	
       	//waitcr	
       	
       	
       	// restore stack
   	lea _OLDSTACK(%pc),%a0
	move.l (%a0),%sp
	//bra __end // do not execute rundown routines
#endif

/*
;
; Execute rundown routines
;
*/
/*
procont/atexit.c:#pragma rundown procexit 128
io/fclose.c:#pragma rundown closeall 10
alloc/malloc.c:#pragma rundown memdelete 0
*/
	/*
	bsr.l procexit (call registered functions -> see atexit.c)
	bsr.l closeall (close all fileandles)
	bsr.l memdelete
	*/
	
//	bra __end
	

/*	
;
; handle code/data fixups for PIC mode
;
*/
__end:
	bsr closeall
	//bsr.l memdelete
	bsr mm_free
	bsr timerclose
	
#ifdef M68000
	writeln msg17
#else
	writeln msg17(%pc)
#endif
	rts
	
/*	
;
; Handle startup/rundown routines
;
*/

/*
; This is called as the first thing from the C main routine
*/

__main:
	
 	rts
 	
relocate:

	lea _start,%a0
	lea _sbss,%a1	
#ifdef M68000
	LEA32A0 _RAM_TOP
#else
	lea _RAM_TOP(%pc),%a2
#endif
	
rel00:  cmpa.l (%a2),%a1
	ble rel02      
	cmp.l #0xDEADBEAF,(%a1)+				
	bne rel00			
       	cmp.l #0x5AA58001,(%a1)+	// check MAGIC
       	bne rel00       	
       	cmp.l #0xDEADBEAF,(%a1)+	// check MAGIC
       	bne rel00
       
/*       
        move.l (%a1)+,%d0
        //-----				// print compile address
        writeln msg19(%pc)
	prthex8 %d0				
       	writeln buffer(%pc)       	
       	crlf	
       	//-----		
       	move.l (%a1)+,%d0
        //-----				// print number of relocations
        writeln msg13(%pc)
	prthex8 %d0				
       	writeln buffer(%pc)       	
       	crlf	
       	//-----
       	crlf
       	writeln msg10(%pc)
       	sub.l #1,%d0
rel00:					// cycle through relocations and print them out
	move.l (%a1)+,%d1		// offset
	prthex8	%d1
	writeln buffer(%pc)
	writeln TAB(%pc)
	move.l (%a1)+,%d1		// type
	prthex8	%d1
	writeln buffer(%pc)
	writeln TAB(%pc)        	
	move.l (%a1)+,%d1		// value
	prthex8	%d1
	writeln buffer(%pc)
	writeln TAB(%pc) 
	
	cmp.l #1,-8(%a1)		// type = R_68K_32 ?
	beq rel000
	waitcr
rel000:	
	crlf
       	dbra %d0,rel00
       	
        rts
*/

        			// %a1->LoadAddress ( die ist erst mal uninteressant, weil alle Werte relativ 0 im BSS Segment stehen !)	
	suba.l (%a1)+,%a0	// sub linker load address from _start (%a0 = %a0 - (%a1))	
	cmpa.l #0,%a0
	bne rel01
	writeln msg18(%pc)	// "No relocation nessecary"
	crlf
	waitcr			// wait for ENTER
	
	lea _start,%a0

rel01:	
  	move.l (%a1)+,%d0	// do relocations %d0 = number of relocations
	sub.l #1,%d0		// adjust for dbra

rel04:				// %a1->Entry; %a1+0=Offset, %a1+4=Type, %a1+8=Value, %a1+12=next Entry

	cmp.l #1,4(%a1)		// type = R_68K_32 ?
	bne rel05
	
	move.l 8(%a1),%d1	// load address value into %d1	
	add.l %a0,%d1		// add program start differenece	%d1 = %d1 + %a0
	movea.l 0(%a1),%a2	// load offset value into %a2
	adda.l %a0,%a2		// and add program start address diff   %a2 = %a2 + %a0
			
/*			
	//---------------
	// Offset %a2 = (%a2) ---> %d1
	writeln msg20(%pc)    	// ADDR 0x
	prthex8 %a2	      	// ...
       	writeln buffer(%pc)
       	writeln msg21(%pc)    	// = 0x
       	prthex8 (%a2)         	// ...
       	writeln buffer(%pc)
       	writeln msg22(%pc)    	// ----> 0x
       	prthex8 %d1           	// ...
       	writeln buffer(%pc)	
       	crlf			// crlf
       	waitcr			// wait
	//---------------		
*/	
	move.l %d1,(%a2)	// do the relocation
	bra rel06
		
rel05:	writeln msg14(%pc)	// unsupported relocation
	prthex8 %a1
       	writeln buffer(%pc)
       	crlf      	
       	waitcr
       	move.l #1,%d2		// set error flag
       	bra rel03		// and exit
       	
rel06: 	add.l #12,%a1		// go to next relocation
  	dbra %d0,rel04  	  		
  	move.l #0,%d2		// clear error flag
  	bra rel03     		// and exit (success)
  	  	
rel02:	writeln msg12(%pc) 
	crlf      	
       	waitcr
       	move.l #1,%d2		// set error flag
       	
rel03:       		
	rts 	
	
	
#ifdef M68000
/*
*  void* _LEA(void* RücksprungAdresse,void* Variablenadresse)
*  liefert die effektive (pc relative) Adresse der Variable
*  => lea Variable(pc),a0 für 68000 mit 32-Bit displacement
*/
_LEA32A0:
           movea.l (%sp),%a0
           suba.l  (4,%sp),%a0
           adda.l  (8,%sp),%a0
           rts

buffer:	ds.b 255		

#endif


		
#ifdef M68000
	.data
#else 	
	.data
#endif
	.global _HEAP,_RAM_TOP,_CMDLINE, errno
	
	
errno:		ds.l 1
_HEAP:		ds.l 1
_RAM_TOP:	ds.l 1

_OLDSTACK:	ds.l 1

_CMDLINE:	ds.b 255


TAB:	.asciz "    "

DOT:	.ascii "."
	.byte 0x0d,0x0a,0x00

msg00:	.ascii " NKC-CLIB (C) 2012 Torsten Hemmecke" 	
	.byte 0x0d,0x0a,0x00
	
msg01:	.ascii " BSS segment initailized" 	
	.byte 0x0d,0x0a,0x00	
	
msg02:	.ascii " HEAP calculated ...." 	
	.byte 0x0d,0x0a,0x00
	
msg03:	.ascii " ...and initialized" 	
	.byte 0x0d,0x0a,0x00	
	
msg04:	.ascii " args and env copied to program area" 	
	.byte 0x0d,0x0a,0x00			

msg05:	.ascii " startup routines executed, now calling main" 	
	.byte 0x0d,0x0a,0x0d,0x0a,0x00	
	
msg06:	.ascii " fake routine called from main, returning immediately" 	
	.byte 0x0d,0x0a,0x00	
	
msg07:	.ascii " executing rundown routines...bye bye..." 	
	.byte 0x0d,0x0a,0x00		
	
msg08:	.ascii " load address : 0x" 	
	.byte 0x00	
	
msg09:	.ascii " bss starts at: 0x" 	
	.byte 0x00	
	
msg10:	.ascii " Relocation Table:" 	
	.byte 0x0d,0x0a,0x0d,0x0a
	.ascii " offset    type       value"
	.byte 0x0d,0x0a,0x00
	
msg11: 	.ascii " Magic found"
	.byte 0x0d,0x0a,0x00

msg12: 	.ascii " Magic not found"
	.byte 0x0d,0x0a,0x00
		
msg13: 	.ascii " relocs: 0x"
	.byte 0x00
	
msg14: 	.ascii " unsupported relocation ! "
	.byte 0x0d,0x0a,0x00	
	
msg15: 	.ascii " Relocations done ! "
	.byte 0x0d,0x0a,0x00	
	
msg16:	.ascii " loading...."
	.byte 0x0d,0x0a,0x00	
	
msg17:	.byte 0x0d,0x0a,0x0d,0x0a
	.ascii " exit..."
	.byte 0x0d,0x0a,0x00	

msg18:	.ascii " no relocation necessary"
	.byte 0x0d,0x0a,0x00

msg19:	.ascii " compiled for address: 0x"
	.byte 0x00

msg20:	.ascii " ADDR 0x"
	.byte 0x00
msg21:	.ascii " = 0x"
	.byte 0x00
msg22:	.ascii " ---> 0x"
	.byte 0x00	
msg23:	.ascii " __rexit ...." 	
	.byte 0x0d,0x0a,0x00	
msg24:	.ascii " bss ends (HEAP starts) at: 0x" 	
	.byte 0x00
msg25:	.ascii " RAM_TOP at: 0x" 	
	.byte 0x00									
#ifdef M68000
#else
buffer:	ds.b 255		
#endif
