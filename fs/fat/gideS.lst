68K GAS   			page 1


   1               	
   0               	
   0               	
   2               	#include "../../nkc/nkc.h"
   1               	#ifndef __EQU_H
   3               	#include "../../nkc/macros.h"
   1               	#ifndef __MACROS_H
   2               	#define __MACROS_H
   3               	
   4               	
   5               	/* DEBUG MACROS */
   6               	#ifdef CONFIG_DEBUG_GIDE_S
   7               	
   8               	.macro dbg msg
   9               	        writeln \msg
  10               	.endm   
  11               	
  12               	.macro dbgwait
  13               	        waitcr
  14               	.endm
  15               	
  16               	
  17               	#else
  18               	.macro dbg msg
  19               	.endm
  20               	
  21               	.macro dbgwait
  22               	.endm
  23               	#endif     
  24               	
  25               	/*
  26               	   Ermittelt die PC-realtive effekive Addresse von var und legt sie in a0 ab.
  27               	   Wird für 68000 gebraucht, da dieser nur 64KB Addressierung kennt:
  28               		lea var(pc),a0 ; funktioniert i.A. nur ab 68020
  29               		LEA32A0 var    ; erledigt das für den 68000
  30               	
  31               		Die Subroutine _LEA32A0 liegt in start00.S
  32               	*/
  33               	
  34               	#ifdef M68000
  35               	.macro LEA32A0 var
  36               		move.l #\var,-(%sp)
  37               		move.l #1f,-(%sp)
  38               		jsr _LEA32A0
  39               	1:	addq.l #8,%sp
  40               	.endm
  41               	
  42               	.macro LEA32 var,reg
  43               		move.l #\var,-(%sp)
  44               		move.l #1f,-(%sp)
  45               		jsr _LEA32A0
  46               	1:	addq.l #8,%sp
  47               		movea.l %a0,\reg
  48               	.endm
  49               	
  50               	/* pea kann auch nur mit 16Bit Displacements ! i.e. "pea d16(pc)" */
  51               	.macro _LEA var,reg
68K GAS   			page 2


  52               		pea #\var
  53               		move.l (%sp)+,\reg
  54               	.endm
  55               	#endif
  56               	
  57               	
  58               	/* Gibt Text an momentaner Cursor Position aus */
  59               	.macro writeln  text             
  60               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
  61               	#ifdef M68000
  62               		LEA32A0 \text
  63               	#else
  64               	        lea \text,%a0
  65               	#endif
  66               	1:
  67               	        move.b (%a0)+,%d0
  68               	        beq 2f
  69               	        moveq #_CO2,%d7
  70               	        trap #1
  71               	        bra 1b
  72               	2:
  73               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
  74               	.endm
  75               	
  76               	.macro prntdot             
  77               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
  78               	        move.b #'.',%d0
  79               	        moveq #_CO2,%d7
  80               	        trap #1
  81               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
  82               	.endm
  83               	
  84               	
  85               	.macro crlf                      
  86               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
  87               	        moveq #_CRLF,%d7
  88               	        trap #1
  89               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
  90               	.endm
  91               	
  92               	
  93               	/* jumps to x,y position */
  94               	
  95               	.macro gotoxy x y           
  96               	 	movem.l %a0-%a6/%d0-%d7,-(%a7)
  97               	 	move.b #\x,%d1           /* d1=X (0..79)*/
  98               	 	move.b #\y,%d2           /* d2=Y (0..23)*/
  99               	 	moveq #_SETCURXY,%d7
 100               	 	trap #1
 101               	 	movem.l (%a7)+,%a0-%a6/%d0-%d7
 102               	.endm
 103               	
 104               	
 105               	.macro getxy x y           
 106               	 	movem.l %a0-%a6/%d0-%d7,-(%a7)
 107               	 	moveq #_GETCURXY,%d7
 108               	 	trap #1
68K GAS   			page 3


 109               	 	move.b %d1,#\x           /* d1=X (0..79)*/
 110               	 	move.b %d2,#\y           /* d2=Y (0..23)*/
 111               	 	movem.l (%a7)+,%a0-%a6/%d0-%d7
 112               	.endm
 113               	
 114               	.macro writexy size x y text            /* gibt einen text an x/y position aus*/
 115               	                            	   	/* TextGrüsse,X,Y,TextAddr (Nullterminiert)*/
 116               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 117               	        move.b #\size,%d0
 118               	        move.w #\x,%d1
 119               	        move.w #\y,%d2
 120               	        lea \text,%a0
 121               	        moveq #_WRITE,%d7
 122               	        trap #1
 123               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 124               	.endm
 125               	
 126               	
 127               	
 128               	.macro clrscr                    /* loescht den Bildschirm */
 129               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 130               	        moveq #_CLRSCREEN,%d7
 131               	        trap #1
 132               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 133               	.endm
 134               	
 135               	
 136               	
 137               	
 138               	.macro prthex2  value                 	/* gibt 2stellige HEX Zahl aus*/
 139               	                                	/* IN: WERT*/
 140               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 141               	        move.l \value,%d0
 142               	        lea buffer(%pc),%a0
 143               	        moveq #_PRINT2X,%d7
 144               	        trap #1
 145               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 146               	.endm
 147               	
 148               	
 149               	.macro prthex8  value            /* gibt 8stellige Hex Zahl aus */
 150               	                                 /* In: WERT */
 151               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 152               	        move.l \value,%d0
 153               	#ifdef M68000
 154               		LEA32A0 buffer
 155               	#else
 156               	        lea buffer(%pc),%a0
 157               	#endif
 158               	        moveq #_PRINT8X,%d7
 159               	        trap #1
 160               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 161               	.endm
 162               	
 163               	.macro waitcr                    /* Wartet auf CR (Enter) */
 164               	        movem.l %a0-%a6/%d0-%d7,-(%a7)
 165               	1:
68K GAS   			page 4


 166               	        moveq #_CI,%d7
 167               	        trap #1
 168               	        cmp.b #0xd,%d0
 169               	        bne.s 1b
 170               	        movem.l (%a7)+,%a0-%a6/%d0-%d7
 171               	.endm
 172               	
 173               	
 174               	.macro CMOS_READ index
 175               		movem.l %a0-%a1,-(%a7)
 176               		clr.l %d0
 177               		move.b \index,RTC_DS12887_INDEX.w
 178               		move.b RTC_DS12887_DATA.w,%d0
 179               		movem.l (%a7)+,%a0-%a1
 180               	.endm
 181               	
 182               	.macro BCD_TO_BIN
 183               		movem.l %d1,-(%a7)
 184               		move.l %d0,%d1
 185               		andi #0x0f,%d0
 186               		lsr #4,%d1
 187               		mulu #10,%d1
 188               		add %d1,%d0
 189               		movem.l (%a7)+,%d1
 190               	.endm
 191               	
 192               	.macro BIN_TO_BCD		/*ist zwar 2 Befehle länger, aber schneller und für alle 68xxx*/
 193               		movem.l %d1,-(%a7)
 194               		and.l #0xff,%d0		/*nur Byte gültig*/
 195               		divu #10,%d0
 196               		move %d0,%d1
 197               		lsl #4, %d1
 198               		swap %d0
 199               		add %d0, %d1
 200               		exg %d0, %d1
 201               		movem.l (%a7)+,%d1
 202               	.endm
 203               	
   4               	
   5               	
   6               	/* commands coming from the host */
   7               	.equ CMD_READ,		1
   8               	.equ CMD_WRITE, 	2
   9               	
  10               	/* ATA command codes */
  11               	.equ CMD_SET_MULTIPLE_MODE	,		0xC6
  12               			
  13               	.equ CMD_READ_MULTIPLE		, 		0xC4
  14               	.equ CMD_READ_SECTORS		,		0x20
  15               	.equ CMD_READ_SECTORS_R		,		0x21
  16               	.equ CMD_READ_SECTORS_V		,		0x40
  17               	.equ CMD_READ_SECTORS_VR	,		0x41
  18               	
  19               	.equ CMD_WRITE_SECTORS		,		0x30
  20               	.equ CMD_WRITE_SECTORS_R	,		0x31
  21               	.equ CMD_WRITE_SECTORS_V	,		0x3C
  22               	
68K GAS   			page 5


  23               	.equ CMD_CACHE_FLUSH		, 		0xE7
  24               	
  25               	.equ DELAY_VAL				, 		0XFFFF
  26               	
  27               	
  28               	
  29               		.data
  30               		
  31               	#ifdef CONFIG_DEBUG_GIDE_S	
  32               	msgKEY:	.ascii "KEY.."
  33               		.byte 0x0d,0x0a,0x00
  34               		
  35               	msgREAD:	.ascii "IDEREAD.."
  36               		.byte 0x0d,0x0a,0x00	
  37               	
  38               	msgWRITE:	.ascii "IDEWRITE.."
  39               		.byte 0x0d,0x0a,0x00
  40               		
  41               	msgRETRYrd:	.ascii "retry read.."
  42               		.byte 0x0d,0x0a,0x00
  43               		
  44               	msgRECOVERrd:	.ascii "recover read.."
  45               		.byte 0x0d,0x0a,0x00		
  46               	
  47               	msgERRORrd:	.ascii "error read.."
  48               		.byte 0x0d,0x0a,0x00
  49               		
  50               	msgRETRYwr:	.ascii "retry write.."
  51               		.byte 0x0d,0x0a,0x00
  52               		
  53               	msgRECOVERwr:	.ascii "recover write.."
  54               		.byte 0x0d,0x0a,0x00		
  55               		
  56               	msgERRORwr:	.ascii "error write.."
  57               		.byte 0x0d,0x0a,0x00
  58               			
  59               	msgSUCC:	.ascii "success.."
  60               		.byte 0x0d,0x0a,0x00	
  61               		
  62               	msgWAWA:	.ascii "wawa..."
  63               		.byte 0x0d,0x0a,0x00
  64               		
  65               	msg01:	.ascii "send command write..."
  66               		.byte 0x0d,0x0a,0x00
  67               	
  68               	msg02:	.ascii "next sector..."
  69               		.byte 0x0d,0x0a,0x00	
  70               		
  71               	msg03:	.ascii "send command read..."
  72               		.byte 0x0d,0x0a,0x00	
  73               			
  74               	#endif	
  75               			
  76               		.text
  77               		.global idetifyIDE, idedisk, idetest, _ide
  78               		
  79               	/*
68K GAS   			page 6


  80               		https://www.pjrc.com/tech/8051/ide/wesley.html#readwritereg
  81               	*/	
  82               	
  83               	
  84               	
  85               	/* -------------------------------------------------------------------------
  86               	
  87               		routines using GP
  88               		
  89               	   -------------------------------------------------------------------------*/		
  90               	   
  91               	   
  92               	/*	
  93               		DRESULT idedisk(USHORT cmd,ULONG arg1,ULONG arg2,BYTE disk,void* pdata)	
  94               		d0      idedisk(
  95               						USHORT sp+6 -> d1,
  96               						ULONG  sp+8 -> d2,
  97               						ULONG  sp+12 -> d3,
  98               						BYTE   sp+19 -> d4,
  99               						void*  sp+20 -> a0)	
 100               	
 101               		Eingaberegister: d1.w = Auswahl des Befehls (0-31)
 102               		d2.l = Je nach Befehl verschieden
 103               		d3.l = Je nach Befehl verschieden
 104               		d4.b = Auswahl der Harddisk
 105               		a0.l = Adresse der Daten, wenn welche verlangt werden
 106               		Ausgaberegister: d0.l = Fehlercode
 107               		CARRY = 1, wenn d0.l <> 0	
 108               	*/
 109               	idedisk:
 110 0000 224F      		movea.l %a7,%a1
 111               		
 112 0002 48E7 7800 		movem.l %d1-%d4,-(%sp)
 113 0006 4280      		clr.l %d0
 114 0008 4281      		clr.l %d1
 115 000a 4284      		clr.l %d4
 116               		/*-----*/	
 117 000c 3229 0006 		move.w  (6 ,%A1),%d1		/* cmd -> d1 */
 118 0010 2429 0008 		move.l  (8 ,%A1),%d2		/* arg1 -> d2 */
 119 0014 2629 000C 		move.l  (12,%A1),%d3		/* arg2 -> d3 */
 120 0018 1829 0013 		move.b  (19,%A1),%d4		/* disk -> d4 */
 121 001c 2069 0014 		move.l  (20,%A1),%a0		/* pdata -> a0 */
 122               		/*-----*/
 123 0020 2E3C 0000 		move.l	#155,%d7
 123      009B 
 124 0026 4E41      		trap #1
 125 0028 4CDF 001E 		movem.l (%sp)+,%d1-%d4
 126 002c 0280 0000 		and.l #0x0000FFFF,%d0
 126      FFFF 
 127 0032 4E75      		rts				
 128               	    		
 129               	/*
 130               	struct _driveinfo *idetest(BYTE disk)
 131               	
 132               	Kurzbeschreibung: Testet, ob ein IDE-Laufwerk vorhanden ist.
 133               	Eingaberegister: d4.b = Auswahl des Laufwerks
 134               	Ausgaberegister: d0.l = Fehlercode
68K GAS   			page 7


 135               	CARRY = 1, wenn kein Laufwerk vorhanden ist
 136               	a0.l = Adresse der Laufwerksinformationen
 137               	*/
 138               	idetest:
 139 0034 204F      		move.l %a7,%a0
 140 0036 48E7 FF00 		movem.l %d0-%d7,-(%sp)
 141 003a 2828 0004 		move.l (4,%A0),%d4		/* disk -> d4 */
 142 003e 2E3C 0000 		move.l	#154,%d7
 142      009A 
 143 0044 4E41      		trap #1
 144 0046 3C00      		move %d0,%d6
 145               								/* a0 points to a struct _driveinfo, d0 has error code */
 146 0048 4A80      		tst.l %d0									
 147 004a 6600 0008 		bne idetest_e
 148 004e 207C 0000 		movea.l #0,%a0			/* in case of an error return NULL */
 148      0000 
 149               	idetest_e:		
 150 0054 4CDF 00FF 		movem.l (%sp)+,%d0-%d7
 151 0058 4E75      		rts							
 152               	
 153               	
 154               	
 155               	/* -------------------------------------------------------------------------
 156               	
 157               		routines talking directly with IDE device
 158               		
 159               	   -------------------------------------------------------------------------*/		
 160               	   
 161               	
 162               	/*
 163               	DRESULT idetifyIDE(BYTE disk, struct _deviceinfo *p)
 164               	*/
 165               	
 166               	idetifyIDE:
 167 005a 224F      		movea.l %a7,%a1
 168 005c 48E7 78C0 		movem.l %d1-%d4/%a0-%a1,-(%sp)
 169               		
 170 0060 6100 020E 		bsr waitRDY             	/* wait for IDE to be ready */
 171 0064 6100 0282 		bsr waitNBSY				/* wait for IDE to be not busy */
 172 0068 11E9 0007 		move.b  (7,%a1),idesdh.w	/* drivenumber */
 172      FC78 
 173 006e 6100 02F8 		bsr wawa
 174 0072 6100 0274 		bsr waitNBSY
 175 0076 11FC 00EC 		move.b  #0xEC,idecmd.w    	/* send command 			*/	
 175      FC7C 
 176 007c 6100 022E 		bsr waitDRQ             	/* wait for IDE data		*/
 177               		
 178 0080 1038 FC7C 		move.b idecmd.w,%d0		/* Status */
 179 0084 1238 FC64 		move.b ideerr.w,%d1		/* Error */
 180               		
 181 0088 2069 0008 		move.l  (8,%A1),%a0
 182 008c 203C 0000 		move.l #(512/2)-1,%d0       /* read data to buffer		*/
 182      00FF 
 183 0092 43F8 FC60 		lea idedat.w,%a1
 184               	L1:
 185               	
 186 0096 1151 0001 		move.b (%a1),1(%a0)		/* store with byte swap */
68K GAS   			page 8


 187 009a 1091      		move.b (%a1),0(%a0)
 188 009c 5448      		addq #2,%a0
 189 009e 51C8 FFF6 		dbra %d0,L1
 190               		
 191 00a2 6100 02A6 		bsr flushIDE			/* empty data buffer */
 192               		
 193 00a6 4280      		clr.l %d0
 194 00a8 1001      		move.b %d1,%d0			/* return error code */
 195 00aa 4CDF 031E 		movem.l (%sp)+,%d1-%d4/%a0-%a1
 196 00ae 4E75      		rts
 197               	
 198               	
 199               	/*	
 200               		DRESULT _ide(USHORT cmd,ULONG arg1,ULONG arg2,BYTE disk,void* pdata)	
 201               		d0      idedisk(
 202               						USHORT sp+6 -> d1,
 203               						ULONG  sp+8 -> d2,
 204               						ULONG  sp+12 -> d3,
 205               						BYTE   sp+19 -> d4,
 206               						void*  sp+20 -> a0)	
 207               	
 208               		Eingaberegister: d1.w = Auswahl des Befehls (0-31)
 209               		d2.l = Je nach Befehl verschieden
 210               		d3.l = Je nach Befehl verschieden
 211               		d4.b = Auswahl der Harddisk
 212               		a0.l = Adresse der Daten, wenn welche verlangt werden
 213               		Ausgaberegister: d0.l = Fehlercode
 214               		CARRY = 1, wenn d0.l <> 0	
 215               	*/
 216               	_ide:
 217 00b0 224F      		movea.l %a7,%a1	
 218 00b2 48E7 7F7E 		movem.l %d1-%d7/%a1-%a6,-(%sp)
 219               	
 220               		
 221 00b6 4280      		clr.l %d0					/* clear registers */
 222 00b8 4281      		clr.l %d1
 223 00ba 4282      		clr.l %d2
 224 00bc 4283      		clr.l %d3
 225 00be 4284      		clr.l %d4
 226               		
 227 00c0 3229 0006 		move.w  (6 ,%A1),%d1		/* cmd -> d1 */
 228 00c4 2429 0008 		move.l  (8 ,%A1),%d2		/* arg1 -> d2 */
 229 00c8 2629 000C 		move.l  (12,%A1),%d3		/* arg2 -> d3 */
 230 00cc 1829 0013 		move.b  (19,%A1),%d4		/* disk -> d4 */
 231 00d0 2069 0014 		move.l  (20,%A1),%a0		/* pdata -> a0 */
 232               	
 233 00d4 0C41 0001 		cmp.w	#CMD_READ,%d1
 234 00d8 6700 0010 		beq		_iderd
 235 00dc 0C41 0002 		cmp.w	#CMD_WRITE,%d1
 236 00e0 6700 00C6 		beq		_idewr
 237               		
 238 00e4 709C      		moveq	#-100,%d0
 239 00e6 6000 0182 		bra		_ideend
 240               		
 241               		/*************************************************************************************************
 242               			<PIO Mode Reading>
 243               			READ-ARGS:
68K GAS   			page 9


 244               				d1.w = CMD_READ
 245               				d2.l = sector address (LBA)
 246               				d3.l = number of sectors
 247               				d4.b = disk (1....n)
 248               				a0.l = pointer to buffer
 249               				
 250               				d3.l <= 256 => CMD_READ_SECTORS 
 251               				d3.l > 256  => CMD_SET_MULTIPLE,CMD_READ_MULTIPLE
 252               				
 253               				---
 254               				d0.l = tmp
 255               				d1.l = tmp
 256               				*d2.l = sector address (LBA)
 257               				*d3.l = number of sectors
 258               				*d4.b = disk (1....n)
 259               				d5.l = try counter
 260               				d6.l = byte counter
 261               				d7.l = sector counter
 262               			    *a0.l = pointer to buffer
 263               				a1.l = data register address
 264               				a2.l = saved buffer address to work on
 265               		*/
 266               	_iderd:		
 267               		/*dbg msgREAD*/
 268 00ea 3A3C 0009 		move #10-1, %d5         /* try reading 10 times */			
 269               			
 270               	_iderd_01:
 271               		
 272 00ee 2202      		move.l %d2,%d1			/* load sector number */
 273 00f0 E089      		lsr.l  #8,%d1
 274 00f2 E089      		lsr.l  #8,%d1
 275 00f4 E089      		lsr.l  #8,%d1
 276 00f6 0001 00E0 		or.b   #0xE0,%d1
 277 00fa 11C1 FC78 		move.b  %d1,idesdh.w	/* 1110b(LBA MASTER) + sectornumber LBA[24..27] => idesdh */	
 278               		
 279 00fe 11FC 0000 		move.b #0,ideerr.w		/* this write will be ignored by the drive, it just produces some delay .... *
 279      FC64 
 280               		/*bsr wawa*/
 281               		
 282 0104 11C3 FC68 		move.b	%d3,idescnt.w	/* number of sectors => idescnt */
 283               		
 284 0108 2202      		move.l %d2,%d1			/* load sector number */
 285 010a 11C1 FC6C 		move.b  %d1,idesnum.w	/* LBA[0..7] 		*/
 286 010e E089      		lsr.l	#8,%d1
 287 0110 11C1 FC70 		move.b  %d1,ideclo.w	/* LBA[8..15]		*/
 288 0114 E089      		lsr.l	#8,%d1
 289 0116 11C1 FC74 		move.b  %d1,idechi.w	/* LBA[16..23] 		*/	
 290               			
 291               			
 292               	_iderd_01a:	
 293               	
 294 011a 2448      	    move.l	%a0,%a2			/* load buffer address */
 295 011c 2E03      	    move.l  %d3,%d7			/* load sector count */	
 296 011e 4A47      	    tst		%d7				/* number of sectors = 0 ? */
 297 0120 6600 0006 		bne		_iderd_01b
 298 0124 3E3C 0100 		move	#256,%d7
 299               	_iderd_01b:
68K GAS   			page 10


 300 0128 5347      		subq #1,%d7
 301               		
 302 012a 43F8 FC60 		lea idedat.w, %a1       /* dataport address in a1 */
 303               		
 304 012e 6100 0140 		bsr waitRDY             /* wait for IDE to be ready */
 305 0132 6100 01B4 		bsr waitNBSY			/* wait for IDE to be not busy */	
 306 0136 4A40      	 	tst %d0					/* drive busy? (%d0 != 0)*/
 307 0138 6600 0054 	 	bne _iderd_retry        /* yes %d0 != 0, some error occured */
 308               		
 309 013c 40E7      		move %sr, -(%a7)         /* save status reg */
 310 013e 007C 0700 	 	ori #0x0700, %sr         /* switch off interrupts */
 311               	 	
 312               	 	/*dbg msg03*/
 313               	 	
 314 0142 11FC 0020 		move.b  #CMD_READ_SECTORS,idecmd.w    	/* send command 			*/	
 314      FC7C 
 315               		
 316               	_iderd_02:
 317 0148 3C3C 01FF 		move #512-1, %d6                    /* read nth sector */	
 318 014c 6100 019A 		bsr waitNBSY						/* wait for IDE to be not busy */	
 319 0150 4A40      	 	tst %d0								/* still busy ? */
 320 0152 6700 0006 	 	beq _iderd_02a           			/* no (%d0=0), so go ahead */
 321 0156 46DF      	 	move (%a7)+, %sr               		/* error (%d0!=0) while waiting, restore status */
 322 0158 6034      	 	bra.s _iderd_retry                  /* error reading sector */
 323               	_iderd_02a:
 324 015a 6100 0150 	 	bsr waitDRQ                         /* data ready?   */
 325 015e 4A40      		tst %d0
 326 0160 6704      		beq.s _iderd_03                     /* yes (%d0=0), no error */
 327 0162 46DF      	 	move (%a7)+, %sr               		/* error while waiting, restore status */
 328 0164 6028      	 	bra.s _iderd_retry                  /* error reading sector */
 329               		
 330               	_iderd_03:
 331 0166 14D1      		move.b (%a1), (%a2)+                /* read */
 332 0168 51CE FFFC 	 	dbra 	%d6, _iderd_03              /* next byte */
 333 016c 51CF FFDA 	 	dbra 	%d7, _iderd_02              /* next sector */
 334               	 	 	
 335 0170 46DF      		move (%a7)+, %sr                 	/* restore status */
 336 0172 6100 0174 	 	bsr waitNBSY                        /* drive busy? */
 337 0176 4A40      	 	tst %d0
 338 0178 6600 0014 	 	bne _iderd_retry               		/* yes, some error occured */
 339 017c 1038 FC7C 	 	move.b idecmd.w, %d0
 340 0180 1200      	 	move.b %d0,%d1
 341 0182 0201 0021 	 	and.b #0b00100001, %d1
 342               	 	
 343               	 	/*and.b #0b10001001, %d1*/          /* any other errors? 
 344               	 											*Bit 0 = ERR ("some error") 
 345               	 											Bit 3 = DRQ ??? FEHLER ?
 346               	 											*Bit 5 = DF (disk failed)
 347               	 											Bit 7 = BSY
 348               	 										*/
 349               	 										
 350 0186 6700 001A 	 	beq  _iderd_success                 /* no, we are ready */
 351 018a 6000 000A 	 	bra  _iderd_tryrecover
 352               	 	
 353               	_iderd_retry:
 354               		dbg msgRETRYrd
 355 018e 51CD FF8A 		dbra %d5, _iderd_01a	                 /* one more try */ 	
68K GAS   			page 11


 356 0192 6000 000A 		bra _iderd_error
 357               		
 358               	_iderd_tryrecover:
 359               		dbg msgRECOVERrd
 360 0196 6100 018C 		bsr resetIDE						/* try recovering */
 361 019a 51CD FF52 		dbra %d5, _iderd_01                 /* one more try */ 	
 362               		
 363               	_iderd_error:
 364               		dbg msgERRORrd
 365               	/*	moveq #-1, %d0*/					/* error code is set by subroutines... */
 366 019e 6000 0004 		bra _iderd_end
 367               	_iderd_success:
 368               	/*	dbg msgSUCCrd*/
 369 01a2 4280      		clr.l %d0
 370               	_iderd_end:	
 371               		
 372 01a4 6000 00C4 		bra 	_ideend
 373               		
 374               		/*************************************************************************************************
 375               			<PIO Mode Writing>
 376               			WRITE-ARGS:
 377               				d1 = CMD_WRITE
 378               				d2 = sector address (LBA)
 379               				d3 = number of sectors
 380               				d4 = disk (1....n)
 381               				a0 = pointer to buffer
 382               				
 383               				---
 384               				d0.l = tmp
 385               				d1.l = tmp
 386               				*d2.l = sector address (LBA)
 387               				*d3.l = number of sectors
 388               				*d4.b = disk (1....n)
 389               				d5.l = try counter
 390               				d6.l = byte counter
 391               				d7.l = sector counter
 392               			    *a0.l = pointer to buffer
 393               				a1.l = data register address
 394               				a2.l = saved buffer address to work on
 395               		*/
 396               	_idewr:		
 397               	    /*dbg msgWRITE    */
 398 01a8 3A3C 0009 		move #10-1, %d5         /* try reading 10 times */			
 399               		
 400               	_idewr_01:
 401               			
 402 01ac 2202      		move.l %d2,%d1			/* load sector number */
 403 01ae E089      		lsr.l  #8,%d1
 404 01b0 E089      		lsr.l  #8,%d1
 405 01b2 E089      		lsr.l  #8,%d1
 406 01b4 0001 00E0 		or.b	#0xE0,%d1
 407 01b8 11C1 FC78 		move.b  %d1,idesdh.w	/* 1110b(LBA MASTER) + sectornumber LBA[24..27] => idesdh */
 408               			
 409 01bc 11FC 0000 		move.b #0,ideerr.w		/* this write will be ignored by the drive, it just produces some delay .... *
 409      FC64 
 410               		/*bsr wawa*/
 411               		
68K GAS   			page 12


 412 01c2 11C3 FC68 		move.b	%d3,idescnt.w	/* number of sectors => idescnt */
 413               		
 414 01c6 2202      		move.l %d2,%d1			/* load sector number */
 415 01c8 11C1 FC6C 		move.b  %d1,idesnum.w	/* LBA[0..7] 		*/
 416 01cc E089      		lsr.l	#8,%d1
 417 01ce 11C1 FC70 		move.b  %d1,ideclo.w	/* LBA[8..15]		*/
 418 01d2 E089      		lsr.l	#8,%d1
 419 01d4 11C1 FC74 		move.b  %d1,idechi.w		/* LBA[16..23] 		*/	
 420               			
 421               		
 422               	_idewr_01a:	
 423 01d8 2448      	    move.l	%a0,%a2			/* load buffer address */
 424 01da 2E03      	    move.l  %d3,%d7			/* load sector count */	
 425 01dc 4A47      	    tst		%d7				/* number of sectors = 0 ? */
 426 01de 6600 0006 		bne		_idewr_01b
 427 01e2 3E3C 0100 		move	#256,%d7
 428               	_idewr_01b:
 429 01e6 5347      		subq #1,%d7
 430               		
 431 01e8 43F8 FC60 		lea idedat.w, %a1       /* dataport address in a1 */		
 432               		
 433 01ec 6100 0082 		bsr waitRDY             /* wait for IDE to be ready */
 434 01f0 6100 00F6 		bsr waitNBSY			/* wait for IDE to be not busy */	
 435 01f4 4A40      	 	tst %d0					/* drive busy? (%d0 != 0)*/
 436 01f6 6600 0058 	 	bne _idewr_retry   /* yes, some error occured */
 437               		
 438 01fa 40E7      		move %sr, -(%a7)         /* save status reg */
 439 01fc 007C 0700 	 	ori #0x0700, %sr         /* switch off interrupts */
 440               	 	
 441               	 	/*dbg msg01*/
 442               	 	
 443 0200 11FC 0030 		move.b  #CMD_WRITE_SECTORS,idecmd.w    	/* send command 			*/	
 443      FC7C 
 444               	
 445               	
 446               	_idewr_02:
 447 0206 3C3C 01FF 		move #512-1, %d6                    /* read 1 sector */	
 448 020a 6100 00DC 		bsr waitNBSY						/* wait for IDE to be not busy */	
 449 020e 4A40      	 	tst %d0								/* still busy ? */
 450 0210 6700 0006 	 	beq _idewr_02a           			/* no, so go ahead */
 451 0214 46DF      	 	move (%a7)+, %sr               		/* error while waiting, restore status */
 452 0216 6038      	 	bra.s _idewr_retry                  /* error reading sector */
 453               	_idewr_02a:
 454 0218 6100 0092 	 	bsr waitDRQ                         /* data ready?   */
 455 021c 4A40      		tst %d0
 456 021e 6704      		beq.s _idewr_03                     /* yes (%d0=0), no error */
 457 0220 46DF      	 	move (%a7)+, %sr               		/* error while waiting, restore status */
 458 0222 602C      	 	bra.s _idewr_retry                  /* error reading sector */
 459               		
 460               	_idewr_03:
 461 0224 6000 0002 	    bra	.+4								/* delay ...*/
 462               	/*    
 463               	    bra	_idewr_04
 464               	_idewr_04:
 465               	*/    
 466 0228 129A      		move.b (%a2)+, (%a1)                /* write */
 467 022a 51CE FFF8 	 	dbra 	%d6, _idewr_03              /* next byte */
68K GAS   			page 13


 468               	 	/*dbg msg02*/
 469 022e 51CF FFD6 	 	dbra 	%d7, _idewr_02              /* next sector */
 470               	 	
 471 0232 46DF      		move (%a7)+, %sr                 	/* restore status */
 472 0234 6100 00B2 	 	bsr waitNBSY                        /* drive busy? */
 473 0238 4A40      	 	tst %d0
 474 023a 6600 0014 	 	bne _idewr_retry               /* yes, some error occured */
 475 023e 1038 FC7C 	 	move.b idecmd.w, %d0
 476 0242 1200      	 	move.b %d0,%d1
 477 0244 0201 0021 	 	and.b #0b00100001, %d1
 478               	 	
 479               	 	/*and.b #0b10001001, %d1*/          /* any other errors? 
 480               	 											*Bit 0 = ERR ("some error") 
 481               	 											Bit 3 = DRQ ??? FEHLER ?
 482               	 											*Bit 5 = DF (disk failed)
 483               	 											Bit 7 = BSY
 484               	 										*/
 485               	 										
 486 0248 6700 001A 	 	beq  _idewr_success                 /* no, we are ready */
 487 024c 6000 000A 	 	bra  _idewr_tryrecover
 488               	 	
 489               	_idewr_retry: 	
 490               		dbg msgRETRYwr
 491               		/*dbgwait*/
 492 0250 51CD FF86 		dbra %d5, _idewr_01a                 /* one more try */
 493 0254 6000 000A 		bra _idewr_error
 494               		
 495               	_idewr_tryrecover:
 496               		dbg msgRECOVERwr
 497               		dbgwait
 498 0258 6100 00CA 		bsr resetIDE						/* try recovering */
 499 025c 51CD FF4E 		dbra %d5, _idewr_01                 /* one more try */ 	
 500               		
 501               	_idewr_error:
 502               		dbg msgERRORwr
 503               		dbgwait
 504               	/*	moveq #-1, %d0*/					/* error code is set by subroutines... */
 505 0260 6000 0004 		bra _idewr_end
 506               	_idewr_success:	
 507 0264 4280      		clr.l %d0
 508               	_idewr_end:	
 509 0266 6100 00D6 		bsr ideCacheFlush
 510               	_ideend:
 511               		
 512 026a 4CDF 7EFE 		movem.l (%sp)+,%d1-%d7/%a1-%a6	
 513 026e 4E75      		rts
 514               	
 515               	
 516               	
 517               	
 518               	/* -------------------------------------------------------------------------
 519               	
 520               		helper routines
 521               		
 522               		http://wiki.osdev.org/ATA_PIO_Mode
 523               	   -------------------------------------------------------------------------*/		
 524               	
68K GAS   			page 14


 525               		
 526               	waitRDY:                 /* wait for ide to be ready	*/
 527 0270 203C 0000 	 move.l #DELAY_VAL,%d0          /*   tries					*/
 527      FFFF 
 528               	waitRDY1:
 529               	 /*bsr wawa*/
 530 0276 5380      	 subq.l #1,%d0
 531 0278 6700 0028 	 beq waitRDYerr            	/* break			*/
 532 027c 0838 0006 	 btst.b #6,idecmd.w		  	/* RDY bit == 1 ?		*/
 532      FC7C 
 533 0282 0838 0006 	 btst.b #6,idecmd.w		  	
 533      FC7C 
 534 0288 0838 0006 	 btst.b #6,idecmd.w		  	
 534      FC7C 
 535 028e 0838 0006 	 btst.b #6,idecmd.w		  	
 535      FC7C 
 536 0294 0838 0006 	 btst.b #6,idecmd.w		  	
 536      FC7C 
 537               	 
 538 029a 6600 000C 	 bne waitRDYsucc		  	/* RDY = 1, success */	
 539 029e 6000 FFD6 	 bra waitRDY1		 		/* RDY = 0, keep trying */
 540               	waitRDYerr:
 541 02a2 70FF      	 moveq #-1,%d0
 542 02a4 6000 0004 	 bra waitRDYend
 543               	waitRDYsucc:
 544 02a8 4280      	 clr.l %d0
 545               	waitRDYend:
 546 02aa 4E75      	 rts	
 547               	 
 548               	
 549               	waitDRQ:                 /* wait for data available	*/
 550 02ac 203C 0000 	 move.l #DELAY_VAL,%d0           /* Versuche					*/
 550      FFFF 
 551               	waitDRQ1:
 552               	 /*bsr wawa*/		/* im GP wird hier nicht gewartet....laut Spec muss aber min 400ns gewartet werden, 
 553               	 					- wird das DRQ evtl. automatisch zurückgesetzt ? */
 554 02b2 5380      	 subq.l #1,%d0
 555 02b4 6700 0028 	 beq waitDRQerr            /* Schleifen-Abbruch			*/
 556 02b8 0838 0003 	 btst.b #3,idecmd.w		  /* DRQ bit == 1  ?     */    
 556      FC7C 
 557               	 
 558 02be 0838 0003 	 btst.b #3,idecmd.w		  
 558      FC7C 
 559 02c4 0838 0003 	 btst.b #3,idecmd.w		  
 559      FC7C 
 560 02ca 0838 0003 	 btst.b #3,idecmd.w		  
 560      FC7C 
 561 02d0 0838 0003 	 btst.b #3,idecmd.w		  
 561      FC7C 
 562               	 
 563 02d6 6600 000C 	 bne waitDRQsucc		  /* DRQ = 1, data available ... */
 564 02da 6000 FFD6 	 bra waitDRQ1			  /* DRQ = 0, keep tryig */
 565               	waitDRQerr:
 566 02de 70FE      	 moveq #-2,%d0
 567 02e0 6000 0004 	 bra waitDRQend
 568               	waitDRQsucc:
 569 02e4 4280      	 clr.l %d0
68K GAS   			page 15


 570               	waitDRQend:
 571 02e6 4E75      	 rts 
 572               		
 573               		
 574               	waitNBSY:                 /* wait for ide to be not BUSY	*/
 575 02e8 203C 0000 	 move.l #DELAY_VAL,%d0          /*   Versuche					*/
 575      FFFF 
 576               	waitNBSY1:
 577               	 /*bsr wawa*/
 578 02ee 5380      	 subq.l #1,%d0
 579 02f0 6700 0028 	 beq waitNBSYerr            /* Schleifen-Abbruch			*/
 580 02f4 0838 0007 	 btst.b #7,idecmd.w		    /* check if BUSY bit == 0		*/
 580      FC7C 
 581               	
 582 02fa 0838 0007 	 btst.b #7,idecmd.w		    
 582      FC7C 
 583 0300 0838 0007 	 btst.b #7,idecmd.w		    
 583      FC7C 
 584 0306 0838 0007 	 btst.b #7,idecmd.w		    
 584      FC7C 
 585 030c 0838 0007 	 btst.b #7,idecmd.w		    
 585      FC7C 
 586               	
 587 0312 6700 000C 	 beq waitNBSYsucc			/* BSY = 0 */
 588 0316 6000 FFD6 	 bra waitNBSY1			    /* BSY = 1 */
 589               	waitNBSYerr:
 590               	 /*.writeln err1(%pc)*/
 591 031a 70FD      	 moveq #-3,%d0
 592 031c 6000 0004 	 bra waitNBSYend
 593               	waitNBSYsucc:
 594 0320 4280      	 clr.l %d0	
 595               	waitNBSYend:
 596 0322 4E75      	 rts	
 597               	 
 598               	 
 599               	 
 600               	 	
 601               	resetIDE:					/* soft reset IDE (master and slave) */
 602 0324 08F8 0001 		bset #1,idesir.w
 602      FC58 
 603 032a 6100 003C 		bsr wawa
 604 032e 08B8 0001 		bclr #1,idesir.w
 604      FC58 
 605 0334 6100 FFB2 		bsr waitNBSY
 606 0338 6100 FF36 		bsr waitRDY
 607 033c 4E75      		rts
 608               		
 609               	ideCacheFlush:
 610 033e 11FC 00E7 		move.b #CMD_CACHE_FLUSH, idecmd.w    	/* send command 			*/	
 610      FC7C 
 611 0344 6100 FFA2 		bsr waitNBSY
 612 0348 4E75      		rts
 613               		
 614               		
 615               		
 616               	flushIDE:					/* read any data available and flush data buffer */
 617 034a 48E7 8080 		movem.l %a0/%d0,-(%sp)
68K GAS   			page 16


 618 034e 41FA FC60 		lea idedat(%pc),%a0
 619               	flushIDE1:	
 620 0352 0838 0003 		btst.b #3,idecmd.w
 620      FC7C 
 621 0358 6700 0008 		beq flushIDEe
 622 035c 1010      		move.b	(%a0),%d0
 623 035e 6000 FFF2 		bra flushIDE1
 624               	flushIDEe:	
 625 0362 4CDF 0101 		movem.l (%sp)+,%a0/%d0
 626 0366 4E75      		rts
 627               		
 628               	
 629               	 
 630               		
 631               	wawa:                           /* simply wait some time ... */
 632 0368 48E7 8000 	 movem.l %d0,-(%a7)
 633 036c 4280      	 clr.l %d0
 634 036e 303C FFFF 	 move #0xFFFF,%d0
 635               	wawa1:
 636 0372 51C8 FFFE 	 dbra %d0,wawa1
 637 0376 4CDF 0001 	 movem.l (%a7)+,%d0
 638 037a 4E75      	 rts	
68K GAS   			page 17


DEFINED SYMBOLS
             gideS.S:7      *ABS*:00000001 CMD_READ
             gideS.S:8      *ABS*:00000002 CMD_WRITE
             gideS.S:11     *ABS*:000000c6 CMD_SET_MULTIPLE_MODE
             gideS.S:13     *ABS*:000000c4 CMD_READ_MULTIPLE
             gideS.S:14     *ABS*:00000020 CMD_READ_SECTORS
             gideS.S:15     *ABS*:00000021 CMD_READ_SECTORS_R
             gideS.S:16     *ABS*:00000040 CMD_READ_SECTORS_V
             gideS.S:17     *ABS*:00000041 CMD_READ_SECTORS_VR
             gideS.S:19     *ABS*:00000030 CMD_WRITE_SECTORS
             gideS.S:20     *ABS*:00000031 CMD_WRITE_SECTORS_R
             gideS.S:21     *ABS*:0000003c CMD_WRITE_SECTORS_V
             gideS.S:23     *ABS*:000000e7 CMD_CACHE_FLUSH
             gideS.S:25     *ABS*:0000ffff DELAY_VAL
             gideS.S:166    .text:0000005a idetifyIDE
             gideS.S:109    .text:00000000 idedisk
             gideS.S:138    .text:00000034 idetest
             gideS.S:216    .text:000000b0 _ide
             gideS.S:149    .text:00000054 idetest_e
             gideS.S:526    .text:00000270 waitRDY
             gideS.S:574    .text:000002e8 waitNBSY
             gideS.S:631    .text:00000368 wawa
             gideS.S:549    .text:000002ac waitDRQ
             gideS.S:184    .text:00000096 L1
             gideS.S:616    .text:0000034a flushIDE
             gideS.S:266    .text:000000ea _iderd
             gideS.S:396    .text:000001a8 _idewr
             gideS.S:510    .text:0000026a _ideend
             gideS.S:270    .text:000000ee _iderd_01
             gideS.S:292    .text:0000011a _iderd_01a
             gideS.S:299    .text:00000128 _iderd_01b
             gideS.S:353    .text:0000018e _iderd_retry
             gideS.S:316    .text:00000148 _iderd_02
             gideS.S:323    .text:0000015a _iderd_02a
             gideS.S:330    .text:00000166 _iderd_03
             gideS.S:367    .text:000001a2 _iderd_success
             gideS.S:358    .text:00000196 _iderd_tryrecover
             gideS.S:363    .text:0000019e _iderd_error
             gideS.S:601    .text:00000324 resetIDE
             gideS.S:370    .text:000001a4 _iderd_end
             gideS.S:400    .text:000001ac _idewr_01
             gideS.S:422    .text:000001d8 _idewr_01a
             gideS.S:428    .text:000001e6 _idewr_01b
             gideS.S:489    .text:00000250 _idewr_retry
             gideS.S:446    .text:00000206 _idewr_02
             gideS.S:453    .text:00000218 _idewr_02a
             gideS.S:460    .text:00000224 _idewr_03
             gideS.S:506    .text:00000264 _idewr_success
             gideS.S:495    .text:00000258 _idewr_tryrecover
             gideS.S:501    .text:00000260 _idewr_error
             gideS.S:508    .text:00000266 _idewr_end
             gideS.S:609    .text:0000033e ideCacheFlush
             gideS.S:528    .text:00000276 waitRDY1
             gideS.S:540    .text:000002a2 waitRDYerr
             gideS.S:543    .text:000002a8 waitRDYsucc
             gideS.S:545    .text:000002aa waitRDYend
             gideS.S:551    .text:000002b2 waitDRQ1
68K GAS   			page 18


             gideS.S:565    .text:000002de waitDRQerr
             gideS.S:568    .text:000002e4 waitDRQsucc
             gideS.S:570    .text:000002e6 waitDRQend
             gideS.S:576    .text:000002ee waitNBSY1
             gideS.S:589    .text:0000031a waitNBSYerr
             gideS.S:593    .text:00000320 waitNBSYsucc
             gideS.S:595    .text:00000322 waitNBSYend
             gideS.S:619    .text:00000352 flushIDE1
             gideS.S:624    .text:00000362 flushIDEe
             gideS.S:635    .text:00000372 wawa1

NO UNDEFINED SYMBOLS
